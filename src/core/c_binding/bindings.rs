/* automatically generated by rust-bindgen 0.66.1 */

#![allow(clippy::all)]
#![allow(warnings)]

pub const FLECS_HI_COMPONENT_ID: u32 = 256;
pub const FLECS_HI_ID_RECORD_ID: u32 = 1024;
pub const FLECS_SPARSE_PAGE_BITS: u32 = 12;
pub const FLECS_ENTITY_PAGE_BITS: u32 = 12;
pub const FLECS_ID_DESC_MAX: u32 = 32;
pub const FLECS_TERM_DESC_MAX: u32 = 16;
pub const FLECS_EVENT_DESC_MAX: u32 = 8;
pub const FLECS_VARIABLE_COUNT_MAX: u32 = 64;
pub const FLECS_QUERY_SCOPE_NESTING_MAX: u32 = 8;
pub const EcsWorldQuitWorkers: u32 = 1;
pub const EcsWorldReadonly: u32 = 2;
pub const EcsWorldInit: u32 = 4;
pub const EcsWorldQuit: u32 = 8;
pub const EcsWorldFini: u32 = 16;
pub const EcsWorldMeasureFrameTime: u32 = 32;
pub const EcsWorldMeasureSystemTime: u32 = 64;
pub const EcsWorldMultiThreaded: u32 = 128;
pub const EcsOsApiHighResolutionTimer: u32 = 1;
pub const EcsOsApiLogWithColors: u32 = 2;
pub const EcsOsApiLogWithTimeStamp: u32 = 4;
pub const EcsOsApiLogWithTimeDelta: u32 = 8;
pub const EcsEntityIsId: u32 = 2147483648;
pub const EcsEntityIsTarget: u32 = 1073741824;
pub const EcsEntityIsTraversable: u32 = 536870912;
pub const EcsIdOnDeleteRemove: u32 = 1;
pub const EcsIdOnDeleteDelete: u32 = 2;
pub const EcsIdOnDeletePanic: u32 = 4;
pub const EcsIdOnDeleteMask: u32 = 7;
pub const EcsIdOnDeleteObjectRemove: u32 = 8;
pub const EcsIdOnDeleteObjectDelete: u32 = 16;
pub const EcsIdOnDeleteObjectPanic: u32 = 32;
pub const EcsIdOnDeleteObjectMask: u32 = 56;
pub const EcsIdExclusive: u32 = 64;
pub const EcsIdDontInherit: u32 = 128;
pub const EcsIdTraversable: u32 = 256;
pub const EcsIdTag: u32 = 512;
pub const EcsIdWith: u32 = 1024;
pub const EcsIdUnion: u32 = 2048;
pub const EcsIdAlwaysOverride: u32 = 4096;
pub const EcsIdHasOnAdd: u32 = 65536;
pub const EcsIdHasOnRemove: u32 = 131072;
pub const EcsIdHasOnSet: u32 = 262144;
pub const EcsIdHasUnSet: u32 = 524288;
pub const EcsIdHasOnTableFill: u32 = 1048576;
pub const EcsIdHasOnTableEmpty: u32 = 2097152;
pub const EcsIdHasOnTableCreate: u32 = 4194304;
pub const EcsIdHasOnTableDelete: u32 = 8388608;
pub const EcsIdEventMask: u32 = 16711680;
pub const EcsIdMarkedForDelete: u32 = 1073741824;
pub const EcsIterIsValid: u32 = 1;
pub const EcsIterNoData: u32 = 2;
pub const EcsIterIsInstanced: u32 = 4;
pub const EcsIterHasShared: u32 = 8;
pub const EcsIterTableOnly: u32 = 16;
pub const EcsIterEntityOptional: u32 = 32;
pub const EcsIterNoResults: u32 = 64;
pub const EcsIterIgnoreThis: u32 = 128;
pub const EcsIterMatchVar: u32 = 256;
pub const EcsIterHasCondSet: u32 = 1024;
pub const EcsIterProfile: u32 = 2048;
pub const EcsEventTableOnly: u32 = 16;
pub const EcsEventNoOnSet: u32 = 65536;
pub const EcsFilterMatchThis: u32 = 2;
pub const EcsFilterMatchOnlyThis: u32 = 4;
pub const EcsFilterMatchPrefab: u32 = 8;
pub const EcsFilterMatchDisabled: u32 = 16;
pub const EcsFilterMatchEmptyTables: u32 = 32;
pub const EcsFilterMatchAnything: u32 = 64;
pub const EcsFilterNoData: u32 = 128;
pub const EcsFilterIsInstanced: u32 = 256;
pub const EcsFilterPopulate: u32 = 512;
pub const EcsFilterHasCondSet: u32 = 1024;
pub const EcsFilterUnresolvedByName: u32 = 2048;
pub const EcsFilterHasPred: u32 = 4096;
pub const EcsFilterHasScopes: u32 = 8192;
pub const EcsTableHasBuiltins: u32 = 2;
pub const EcsTableIsPrefab: u32 = 4;
pub const EcsTableHasIsA: u32 = 8;
pub const EcsTableHasChildOf: u32 = 16;
pub const EcsTableHasName: u32 = 32;
pub const EcsTableHasPairs: u32 = 64;
pub const EcsTableHasModule: u32 = 128;
pub const EcsTableIsDisabled: u32 = 256;
pub const EcsTableHasCtors: u32 = 512;
pub const EcsTableHasDtors: u32 = 1024;
pub const EcsTableHasCopy: u32 = 2048;
pub const EcsTableHasMove: u32 = 4096;
pub const EcsTableHasUnion: u32 = 8192;
pub const EcsTableHasToggle: u32 = 16384;
pub const EcsTableHasOverrides: u32 = 32768;
pub const EcsTableHasOnAdd: u32 = 65536;
pub const EcsTableHasOnRemove: u32 = 131072;
pub const EcsTableHasOnSet: u32 = 262144;
pub const EcsTableHasUnSet: u32 = 524288;
pub const EcsTableHasOnTableFill: u32 = 1048576;
pub const EcsTableHasOnTableEmpty: u32 = 2097152;
pub const EcsTableHasOnTableCreate: u32 = 4194304;
pub const EcsTableHasOnTableDelete: u32 = 8388608;
pub const EcsTableHasTraversable: u32 = 33554432;
pub const EcsTableHasTarget: u32 = 67108864;
pub const EcsTableMarkedForDelete: u32 = 1073741824;
pub const EcsTableHasLifecycle: u32 = 1536;
pub const EcsTableIsComplex: u32 = 26112;
pub const EcsTableHasAddActions: u32 = 336392;
pub const EcsTableHasRemoveActions: u32 = 656392;
pub const EcsQueryHasRefs: u32 = 2;
pub const EcsQueryIsSubquery: u32 = 4;
pub const EcsQueryIsOrphaned: u32 = 8;
pub const EcsQueryHasOutColumns: u32 = 16;
pub const EcsQueryHasMonitor: u32 = 32;
pub const EcsQueryTrivialIter: u32 = 64;
pub const EcsAperiodicEmptyTables: u32 = 2;
pub const EcsAperiodicComponentMonitors: u32 = 4;
pub const EcsAperiodicEmptyQueries: u32 = 16;
pub const ecs_world_t_magic: u32 = 1701016439;
pub const ecs_stage_t_magic: u32 = 1701016435;
pub const ecs_query_t_magic: u32 = 1701016433;
pub const ecs_rule_t_magic: u32 = 1701016437;
pub const ecs_table_t_magic: u32 = 1701016436;
pub const ecs_filter_t_magic: u32 = 1701016422;
pub const ecs_trigger_t_magic: u32 = 1701016434;
pub const ecs_observer_t_magic: u32 = 1701016418;
pub const ECS_ROW_MASK: u32 = 268435455;
pub const ECS_ROW_FLAGS_MASK: i32 = -268435456;
pub const ECS_ID_FLAGS_MASK: i64 = -1152921504606846976;
pub const ECS_ENTITY_MASK: u32 = 4294967295;
pub const ECS_GENERATION_MASK: u64 = 281470681743360;
pub const ECS_COMPONENT_MASK: u64 = 1152921504606846975;
pub const EcsIterNextYield: u32 = 0;
pub const EcsIterYield: i32 = -1;
pub const EcsIterNext: u32 = 1;
pub const FLECS_SPARSE_PAGE_SIZE: u32 = 4096;
pub const ECS_STRBUF_ELEMENT_SIZE: u32 = 511;
pub const ECS_STRBUF_MAX_LIST_DEPTH: u32 = 32;
pub const EcsSelf: u32 = 2;
pub const EcsUp: u32 = 4;
pub const EcsDown: u32 = 8;
pub const EcsTraverseAll: u32 = 16;
pub const EcsCascade: u32 = 32;
pub const EcsParent: u32 = 64;
pub const EcsIsVariable: u32 = 128;
pub const EcsIsEntity: u32 = 256;
pub const EcsIsName: u32 = 512;
pub const EcsFilter: u32 = 1024;
pub const EcsTraverseFlags: u32 = 126;
pub const EcsTermMatchAny: u32 = 1;
pub const EcsTermMatchAnySrc: u32 = 2;
pub const EcsTermSrcFirstEq: u32 = 4;
pub const EcsTermSrcSecondEq: u32 = 8;
pub const EcsTermTransitive: u32 = 16;
pub const EcsTermReflexive: u32 = 32;
pub const EcsTermIdInherited: u32 = 64;
pub const flecs_iter_cache_ids: u32 = 1;
pub const flecs_iter_cache_columns: u32 = 2;
pub const flecs_iter_cache_sources: u32 = 4;
pub const flecs_iter_cache_ptrs: u32 = 8;
pub const flecs_iter_cache_match_indices: u32 = 16;
pub const flecs_iter_cache_variables: u32 = 32;
pub const flecs_iter_cache_all: u32 = 255;
pub const ECS_MAX_RECURSION: u32 = 512;
pub const ECS_MAX_TOKEN_SIZE: u32 = 256;
pub const FLECS__E0: u32 = 0;
pub const ECS_ID_FLAG_BIT: i64 = -9223372036854775808;
pub const EcsFirstUserComponentId: u32 = 8;
pub const EcsFirstUserEntityId: u32 = 384;
pub const ECS_INVALID_OPERATION: u32 = 1;
pub const ECS_INVALID_PARAMETER: u32 = 2;
pub const ECS_CONSTRAINT_VIOLATED: u32 = 3;
pub const ECS_OUT_OF_MEMORY: u32 = 4;
pub const ECS_OUT_OF_RANGE: u32 = 5;
pub const ECS_UNSUPPORTED: u32 = 6;
pub const ECS_INTERNAL_ERROR: u32 = 7;
pub const ECS_ALREADY_DEFINED: u32 = 8;
pub const ECS_MISSING_OS_API: u32 = 9;
pub const ECS_OPERATION_FAILED: u32 = 10;
pub const ECS_INVALID_CONVERSION: u32 = 11;
pub const ECS_ID_IN_USE: u32 = 12;
pub const ECS_CYCLE_DETECTED: u32 = 13;
pub const ECS_LEAK_DETECTED: u32 = 14;
pub const ECS_INCONSISTENT_NAME: u32 = 20;
pub const ECS_NAME_IN_USE: u32 = 21;
pub const ECS_NOT_A_COMPONENT: u32 = 22;
pub const ECS_INVALID_COMPONENT_SIZE: u32 = 23;
pub const ECS_INVALID_COMPONENT_ALIGNMENT: u32 = 24;
pub const ECS_COMPONENT_NOT_REGISTERED: u32 = 25;
pub const ECS_INCONSISTENT_COMPONENT_ID: u32 = 26;
pub const ECS_INCONSISTENT_COMPONENT_ACTION: u32 = 27;
pub const ECS_MODULE_UNDEFINED: u32 = 28;
pub const ECS_MISSING_SYMBOL: u32 = 29;
pub const ECS_ALREADY_IN_USE: u32 = 30;
pub const ECS_ACCESS_VIOLATION: u32 = 40;
pub const ECS_COLUMN_INDEX_OUT_OF_RANGE: u32 = 41;
pub const ECS_COLUMN_IS_NOT_SHARED: u32 = 42;
pub const ECS_COLUMN_IS_SHARED: u32 = 43;
pub const ECS_COLUMN_TYPE_MISMATCH: u32 = 45;
pub const ECS_INVALID_WHILE_READONLY: u32 = 70;
pub const ECS_LOCKED_STORAGE: u32 = 71;
pub const ECS_INVALID_FROM_WORKER: u32 = 72;
pub const ECS_BLACK: &[u8; 8] = b"\x1B[1;30m\0";
pub const ECS_RED: &[u8; 8] = b"\x1B[0;31m\0";
pub const ECS_GREEN: &[u8; 8] = b"\x1B[0;32m\0";
pub const ECS_YELLOW: &[u8; 8] = b"\x1B[0;33m\0";
pub const ECS_BLUE: &[u8; 8] = b"\x1B[0;34m\0";
pub const ECS_MAGENTA: &[u8; 8] = b"\x1B[0;35m\0";
pub const ECS_CYAN: &[u8; 8] = b"\x1B[0;36m\0";
pub const ECS_WHITE: &[u8; 8] = b"\x1B[1;37m\0";
pub const ECS_GREY: &[u8; 8] = b"\x1B[0;37m\0";
pub const ECS_NORMAL: &[u8; 8] = b"\x1B[0;49m\0";
pub const ECS_BOLD: &[u8; 8] = b"\x1B[1;49m\0";
pub const ECS_HTTP_HEADER_COUNT_MAX: u32 = 32;
pub const ECS_HTTP_QUERY_PARAM_COUNT_MAX: u32 = 32;
pub const ECS_REST_DEFAULT_PORT: u32 = 27750;
pub const ECS_STAT_WINDOW: u32 = 60;
pub const ECS_MEMBER_DESC_CACHE_SIZE: u32 = 32;
pub const ECS_META_MAX_SCOPE_DEPTH: u32 = 32;
pub type va_list = *mut ::std::os::raw::c_char;
#[doc = "Utility types to indicate usage as bitmask"]
pub type ecs_flags8_t = u8;
pub type ecs_flags16_t = u16;
pub type ecs_flags32_t = u32;
pub type ecs_flags64_t = u64;
#[doc = "Keep unsigned integers out of the codebase as they do more harm than good"]
pub type ecs_size_t = i32;
#[doc = "A component column."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_vec_t {
    pub array: *mut ::std::os::raw::c_void,
    pub count: i32,
    pub size: i32,
    pub elem_size: ecs_size_t,
}
extern "C" {
    pub fn ecs_vec_init(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    ) -> *mut ecs_vec_t;
}
extern "C" {
    pub fn ecs_vec_init_if(vec: *mut ecs_vec_t, size: ecs_size_t);
}
extern "C" {
    pub fn ecs_vec_fini(allocator: *mut ecs_allocator_t, vec: *mut ecs_vec_t, size: ecs_size_t);
}
extern "C" {
    pub fn ecs_vec_reset(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
    ) -> *mut ecs_vec_t;
}
extern "C" {
    pub fn ecs_vec_clear(vec: *mut ecs_vec_t);
}
extern "C" {
    pub fn ecs_vec_append(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_vec_remove(vec: *mut ecs_vec_t, size: ecs_size_t, elem: i32);
}
extern "C" {
    pub fn ecs_vec_remove_last(vec: *mut ecs_vec_t);
}
extern "C" {
    pub fn ecs_vec_copy(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
    ) -> ecs_vec_t;
}
extern "C" {
    pub fn ecs_vec_reclaim(allocator: *mut ecs_allocator_t, vec: *mut ecs_vec_t, size: ecs_size_t);
}
extern "C" {
    pub fn ecs_vec_set_size(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    );
}
extern "C" {
    pub fn ecs_vec_set_min_size(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    );
}
extern "C" {
    pub fn ecs_vec_set_min_count(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    );
}
extern "C" {
    pub fn ecs_vec_set_min_count_zeromem(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    );
}
extern "C" {
    pub fn ecs_vec_set_count(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    );
}
extern "C" {
    pub fn ecs_vec_grow(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_vec_count(vec: *const ecs_vec_t) -> i32;
}
extern "C" {
    pub fn ecs_vec_size(vec: *const ecs_vec_t) -> i32;
}
extern "C" {
    pub fn ecs_vec_get(
        vec: *const ecs_vec_t,
        size: ecs_size_t,
        index: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_vec_first(vec: *const ecs_vec_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_vec_last(vec: *const ecs_vec_t, size: ecs_size_t) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_sparse_t {
    #[doc = "Dense array with indices to sparse array. The\n dense array stores both alive and not alive\n sparse indices. The 'count' member keeps\n track of which indices are alive."]
    pub dense: ecs_vec_t,
    #[doc = "Chunks with sparse arrays & data"]
    pub pages: ecs_vec_t,
    #[doc = "Element size"]
    pub size: ecs_size_t,
    #[doc = "Number of alive entries"]
    pub count: i32,
    #[doc = "Local max index (if no global is set)"]
    pub max_id: u64,
    pub allocator: *mut ecs_allocator_t,
    pub page_allocator: *mut ecs_block_allocator_t,
}
extern "C" {
    #[doc = "Initialize sparse set"]
    pub fn flecs_sparse_init(
        sparse: *mut ecs_sparse_t,
        allocator: *mut ecs_allocator_t,
        page_allocator: *mut ecs_block_allocator_t,
        elem_size: ecs_size_t,
    );
}
extern "C" {
    pub fn flecs_sparse_fini(sparse: *mut ecs_sparse_t);
}
extern "C" {
    #[doc = "Remove all elements from sparse set"]
    pub fn flecs_sparse_clear(sparse: *mut ecs_sparse_t);
}
extern "C" {
    #[doc = "Add element to sparse set, this generates or recycles an id"]
    pub fn flecs_sparse_add(
        sparse: *mut ecs_sparse_t,
        elem_size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Get last issued id."]
    pub fn flecs_sparse_last_id(sparse: *const ecs_sparse_t) -> u64;
}
extern "C" {
    #[doc = "Generate or recycle a new id."]
    pub fn flecs_sparse_new_id(sparse: *mut ecs_sparse_t) -> u64;
}
extern "C" {
    #[doc = "Remove an element"]
    pub fn flecs_sparse_remove(sparse: *mut ecs_sparse_t, elem_size: ecs_size_t, id: u64);
}
extern "C" {
    #[doc = "Test if id is alive, which requires the generation count to match."]
    pub fn flecs_sparse_is_alive(sparse: *const ecs_sparse_t, id: u64) -> bool;
}
extern "C" {
    #[doc = "Get value from sparse set by dense id. This function is useful in\n combination with flecs_sparse_count for iterating all values in the set."]
    pub fn flecs_sparse_get_dense(
        sparse: *const ecs_sparse_t,
        elem_size: ecs_size_t,
        index: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Get the number of alive elements in the sparse set."]
    pub fn flecs_sparse_count(sparse: *const ecs_sparse_t) -> i32;
}
extern "C" {
    #[doc = "Get element by (sparse) id. The returned pointer is stable for the duration\n of the sparse set, as it is stored in the sparse array."]
    pub fn flecs_sparse_get(
        sparse: *const ecs_sparse_t,
        elem_size: ecs_size_t,
        id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Same as flecs_sparse_get, but doesn't assert if id is not alive."]
    pub fn flecs_sparse_try(
        sparse: *const ecs_sparse_t,
        elem_size: ecs_size_t,
        id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Like get_sparse, but don't care whether element is alive or not."]
    pub fn flecs_sparse_get_any(
        sparse: *const ecs_sparse_t,
        elem_size: ecs_size_t,
        id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Get or create element by (sparse) id."]
    pub fn flecs_sparse_ensure(
        sparse: *mut ecs_sparse_t,
        elem_size: ecs_size_t,
        id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Fast version of ensure, no liveliness checking"]
    pub fn flecs_sparse_ensure_fast(
        sparse: *mut ecs_sparse_t,
        elem_size: ecs_size_t,
        id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Get pointer to ids (alive and not alive). Use with count() or size()."]
    pub fn flecs_sparse_ids(sparse: *const ecs_sparse_t) -> *const u64;
}
extern "C" {
    #[doc = "Publicly exposed APIs\n The flecs_ functions aren't exposed directly as this can cause some\n optimizers to not consider them for link time optimization."]
    pub fn ecs_sparse_init(sparse: *mut ecs_sparse_t, elem_size: ecs_size_t);
}
extern "C" {
    pub fn ecs_sparse_add(
        sparse: *mut ecs_sparse_t,
        elem_size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_sparse_last_id(sparse: *const ecs_sparse_t) -> u64;
}
extern "C" {
    pub fn ecs_sparse_count(sparse: *const ecs_sparse_t) -> i32;
}
extern "C" {
    #[doc = "Override the generation count for a specific id"]
    pub fn flecs_sparse_set_generation(sparse: *mut ecs_sparse_t, id: u64);
}
extern "C" {
    pub fn ecs_sparse_get_dense(
        sparse: *const ecs_sparse_t,
        elem_size: ecs_size_t,
        index: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_sparse_get(
        sparse: *const ecs_sparse_t,
        elem_size: ecs_size_t,
        id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_block_allocator_block_t {
    pub memory: *mut ::std::os::raw::c_void,
    pub next: *mut ecs_block_allocator_block_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_block_allocator_chunk_header_t {
    pub next: *mut ecs_block_allocator_chunk_header_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_block_allocator_t {
    pub head: *mut ecs_block_allocator_chunk_header_t,
    pub block_head: *mut ecs_block_allocator_block_t,
    pub block_tail: *mut ecs_block_allocator_block_t,
    pub chunk_size: i32,
    pub data_size: i32,
    pub chunks_per_block: i32,
    pub block_size: i32,
    pub alloc_count: i32,
}
extern "C" {
    pub fn flecs_ballocator_init(ba: *mut ecs_block_allocator_t, size: ecs_size_t);
}
extern "C" {
    pub fn flecs_ballocator_new(size: ecs_size_t) -> *mut ecs_block_allocator_t;
}
extern "C" {
    pub fn flecs_ballocator_fini(ba: *mut ecs_block_allocator_t);
}
extern "C" {
    pub fn flecs_ballocator_free(ba: *mut ecs_block_allocator_t);
}
extern "C" {
    pub fn flecs_balloc(allocator: *mut ecs_block_allocator_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn flecs_bcalloc(allocator: *mut ecs_block_allocator_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn flecs_bfree(allocator: *mut ecs_block_allocator_t, memory: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn flecs_brealloc(
        dst: *mut ecs_block_allocator_t,
        src: *mut ecs_block_allocator_t,
        memory: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn flecs_bdup(
        ba: *mut ecs_block_allocator_t,
        memory: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
pub type ecs_map_data_t = u64;
pub type ecs_map_key_t = ecs_map_data_t;
pub type ecs_map_val_t = ecs_map_data_t;
#[doc = "Map type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_bucket_entry_t {
    pub key: ecs_map_key_t,
    pub value: ecs_map_val_t,
    pub next: *mut ecs_bucket_entry_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_bucket_t {
    pub first: *mut ecs_bucket_entry_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_map_t {
    pub bucket_shift: u8,
    pub shared_allocator: bool,
    pub buckets: *mut ecs_bucket_t,
    pub bucket_count: i32,
    pub count: i32,
    pub entry_allocator: *mut ecs_block_allocator_t,
    pub allocator: *mut ecs_allocator_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_map_iter_t {
    pub map: *const ecs_map_t,
    pub bucket: *mut ecs_bucket_t,
    pub entry: *mut ecs_bucket_entry_t,
    pub res: *mut ecs_map_data_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_map_params_t {
    pub allocator: *mut ecs_allocator_t,
    pub entry_allocator: ecs_block_allocator_t,
}
extern "C" {
    #[doc = "Function/macro postfixes meaning:\n   _ptr:    access ecs_map_val_t as void*\n   _ref:    access ecs_map_val_t* as T**\n   _deref:  dereferences a _ref\n   _alloc:  if _ptr is NULL, alloc\n   _free:   if _ptr is not NULL, free"]
    pub fn ecs_map_params_init(params: *mut ecs_map_params_t, allocator: *mut ecs_allocator_t);
}
extern "C" {
    pub fn ecs_map_params_fini(params: *mut ecs_map_params_t);
}
extern "C" {
    #[doc = "Initialize new map."]
    pub fn ecs_map_init(map: *mut ecs_map_t, allocator: *mut ecs_allocator_t);
}
extern "C" {
    #[doc = "Initialize new map."]
    pub fn ecs_map_init_w_params(map: *mut ecs_map_t, params: *mut ecs_map_params_t);
}
extern "C" {
    #[doc = "Initialize new map if uninitialized, leave as is otherwise"]
    pub fn ecs_map_init_if(map: *mut ecs_map_t, allocator: *mut ecs_allocator_t);
}
extern "C" {
    pub fn ecs_map_init_w_params_if(result: *mut ecs_map_t, params: *mut ecs_map_params_t);
}
extern "C" {
    #[doc = "Deinitialize map."]
    pub fn ecs_map_fini(map: *mut ecs_map_t);
}
extern "C" {
    #[doc = "Get element for key, returns NULL if they key doesn't exist."]
    pub fn ecs_map_get(map: *const ecs_map_t, key: ecs_map_key_t) -> *mut ecs_map_val_t;
}
extern "C" {
    #[doc = "Get element as pointer (auto-dereferences _ptr)"]
    pub fn _ecs_map_get_deref(
        map: *const ecs_map_t,
        key: ecs_map_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Get or insert element for key."]
    pub fn ecs_map_ensure(map: *mut ecs_map_t, key: ecs_map_key_t) -> *mut ecs_map_val_t;
}
extern "C" {
    #[doc = "Get or insert pointer element for key, allocate if the pointer is NULL"]
    pub fn ecs_map_ensure_alloc(
        map: *mut ecs_map_t,
        elem_size: ecs_size_t,
        key: ecs_map_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Insert element for key."]
    pub fn ecs_map_insert(map: *mut ecs_map_t, key: ecs_map_key_t, value: ecs_map_val_t);
}
extern "C" {
    #[doc = "Insert pointer element for key, populate with new allocation."]
    pub fn ecs_map_insert_alloc(
        map: *mut ecs_map_t,
        elem_size: ecs_size_t,
        key: ecs_map_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Remove key from map."]
    pub fn ecs_map_remove(map: *mut ecs_map_t, key: ecs_map_key_t) -> ecs_map_val_t;
}
extern "C" {
    #[doc = "Remove pointer element, free if not NULL"]
    pub fn ecs_map_remove_free(map: *mut ecs_map_t, key: ecs_map_key_t);
}
extern "C" {
    #[doc = "Remove all elements from map."]
    pub fn ecs_map_clear(map: *mut ecs_map_t);
}
extern "C" {
    #[doc = "Return iterator to map contents."]
    pub fn ecs_map_iter(map: *const ecs_map_t) -> ecs_map_iter_t;
}
extern "C" {
    #[doc = "Obtain next element in map from iterator."]
    pub fn ecs_map_next(iter: *mut ecs_map_iter_t) -> bool;
}
extern "C" {
    #[doc = "Copy map."]
    pub fn ecs_map_copy(dst: *mut ecs_map_t, src: *const ecs_map_t);
}
extern "C" {
    pub static mut ecs_block_allocator_alloc_count: i64;
}
extern "C" {
    pub static mut ecs_block_allocator_free_count: i64;
}
extern "C" {
    pub static mut ecs_stack_allocator_alloc_count: i64;
}
extern "C" {
    pub static mut ecs_stack_allocator_free_count: i64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_allocator_t {
    pub chunks: ecs_block_allocator_t,
    #[doc = "<size, block_allocator_t>"]
    pub sizes: ecs_sparse_t,
}
extern "C" {
    pub fn flecs_allocator_init(a: *mut ecs_allocator_t);
}
extern "C" {
    pub fn flecs_allocator_fini(a: *mut ecs_allocator_t);
}
extern "C" {
    pub fn flecs_allocator_get(
        a: *mut ecs_allocator_t,
        size: ecs_size_t,
    ) -> *mut ecs_block_allocator_t;
}
extern "C" {
    pub fn flecs_strdup(
        a: *mut ecs_allocator_t,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flecs_strfree(a: *mut ecs_allocator_t, str_: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn flecs_dup(
        a: *mut ecs_allocator_t,
        size: ecs_size_t,
        src: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_strbuf_element {
    pub buffer_embedded: bool,
    pub pos: i32,
    pub buf: *mut ::std::os::raw::c_char,
    pub next: *mut ecs_strbuf_element,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_strbuf_element_embedded {
    pub super_: ecs_strbuf_element,
    pub buf: [::std::os::raw::c_char; 512usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_strbuf_element_str {
    pub super_: ecs_strbuf_element,
    pub alloc_str: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_strbuf_list_elem {
    pub count: i32,
    pub separator: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_strbuf_t {
    #[doc = "When set by an application, append will write to this buffer"]
    pub buf: *mut ::std::os::raw::c_char,
    #[doc = "The maximum number of characters that may be printed"]
    pub max: i32,
    #[doc = "Size of elements minus current element"]
    pub size: i32,
    #[doc = "The number of elements in use"]
    pub elementCount: i32,
    #[doc = "Always allocate at least one element"]
    pub firstElement: ecs_strbuf_element_embedded,
    #[doc = "The current element being appended to"]
    pub current: *mut ecs_strbuf_element,
    #[doc = "Stack that keeps track of number of list elements, used for conditionally\n inserting a separator"]
    pub list_stack: [ecs_strbuf_list_elem; 32usize],
    pub list_sp: i32,
    #[doc = "This is set to the output string after calling ecs_strbuf_get"]
    pub content: *mut ::std::os::raw::c_char,
    #[doc = "This is set to the output string length after calling ecs_strbuf_get"]
    pub length: i32,
}
extern "C" {
    #[doc = "Append format string to a buffer.\n Returns false when max is reached, true when there is still space"]
    pub fn ecs_strbuf_append(
        buffer: *mut ecs_strbuf_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> bool;
}
extern "C" {
    #[doc = "Append format string with argument list to a buffer.\n Returns false when max is reached, true when there is still space"]
    pub fn ecs_strbuf_vappend(
        buffer: *mut ecs_strbuf_t,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> bool;
}
extern "C" {
    #[doc = "Append string to buffer.\n Returns false when max is reached, true when there is still space"]
    pub fn ecs_strbuf_appendstr(
        buffer: *mut ecs_strbuf_t,
        str_: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Append character to buffer.\n Returns false when max is reached, true when there is still space"]
    pub fn ecs_strbuf_appendch(buffer: *mut ecs_strbuf_t, ch: ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = "Append int to buffer.\n Returns false when max is reached, true when there is still space"]
    pub fn ecs_strbuf_appendint(buffer: *mut ecs_strbuf_t, v: i64) -> bool;
}
extern "C" {
    #[doc = "Append float to buffer.\n Returns false when max is reached, true when there is still space"]
    pub fn ecs_strbuf_appendflt(
        buffer: *mut ecs_strbuf_t,
        v: f64,
        nan_delim: ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Append source buffer to destination buffer.\n Returns false when max is reached, true when there is still space"]
    pub fn ecs_strbuf_mergebuff(
        dst_buffer: *mut ecs_strbuf_t,
        src_buffer: *mut ecs_strbuf_t,
    ) -> bool;
}
extern "C" {
    #[doc = "Append string to buffer, transfer ownership to buffer.\n Returns false when max is reached, true when there is still space"]
    pub fn ecs_strbuf_appendstr_zerocpy(
        buffer: *mut ecs_strbuf_t,
        str_: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Append string to buffer, transfer ownership to buffer.\n Returns false when max is reached, true when there is still space"]
    pub fn ecs_strbuf_appendstr_zerocpyn(
        buffer: *mut ecs_strbuf_t,
        str_: *mut ::std::os::raw::c_char,
        n: i32,
    ) -> bool;
}
extern "C" {
    #[doc = "Append string to buffer, do not free/modify string.\n Returns false when max is reached, true when there is still space"]
    pub fn ecs_strbuf_appendstr_zerocpy_const(
        buffer: *mut ecs_strbuf_t,
        str_: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Append string to buffer, transfer ownership to buffer.\n Returns false when max is reached, true when there is still space"]
    pub fn ecs_strbuf_appendstr_zerocpyn_const(
        buffer: *mut ecs_strbuf_t,
        str_: *const ::std::os::raw::c_char,
        n: i32,
    ) -> bool;
}
extern "C" {
    #[doc = "Append n characters to buffer.\n Returns false when max is reached, true when there is still space"]
    pub fn ecs_strbuf_appendstrn(
        buffer: *mut ecs_strbuf_t,
        str_: *const ::std::os::raw::c_char,
        n: i32,
    ) -> bool;
}
extern "C" {
    #[doc = "Return result string"]
    pub fn ecs_strbuf_get(buffer: *mut ecs_strbuf_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Return small string from first element (appends \\0)"]
    pub fn ecs_strbuf_get_small(buffer: *mut ecs_strbuf_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Reset buffer without returning a string"]
    pub fn ecs_strbuf_reset(buffer: *mut ecs_strbuf_t);
}
extern "C" {
    #[doc = "Push a list"]
    pub fn ecs_strbuf_list_push(
        buffer: *mut ecs_strbuf_t,
        list_open: *const ::std::os::raw::c_char,
        separator: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "Pop a new list"]
    pub fn ecs_strbuf_list_pop(
        buffer: *mut ecs_strbuf_t,
        list_close: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "Insert a new element in list"]
    pub fn ecs_strbuf_list_next(buffer: *mut ecs_strbuf_t);
}
extern "C" {
    #[doc = "Append character to as new element in list."]
    pub fn ecs_strbuf_list_appendch(buffer: *mut ecs_strbuf_t, ch: ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = "Append formatted string as a new element in list"]
    pub fn ecs_strbuf_list_append(
        buffer: *mut ecs_strbuf_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> bool;
}
extern "C" {
    #[doc = "Append string as a new element in list"]
    pub fn ecs_strbuf_list_appendstr(
        buffer: *mut ecs_strbuf_t,
        str_: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Append string as a new element in list"]
    pub fn ecs_strbuf_list_appendstrn(
        buffer: *mut ecs_strbuf_t,
        str_: *const ::std::os::raw::c_char,
        n: i32,
    ) -> bool;
}
extern "C" {
    pub fn ecs_strbuf_written(buffer: *const ecs_strbuf_t) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_time_t {
    pub sec: u32,
    pub nanosec: u32,
}
extern "C" {
    #[doc = "Allocation counters"]
    pub static mut ecs_os_api_malloc_count: i64;
}
extern "C" {
    pub static mut ecs_os_api_realloc_count: i64;
}
extern "C" {
    pub static mut ecs_os_api_calloc_count: i64;
}
extern "C" {
    pub static mut ecs_os_api_free_count: i64;
}
#[doc = "Use handle types that _at least_ can store pointers"]
pub type ecs_os_thread_t = usize;
pub type ecs_os_cond_t = usize;
pub type ecs_os_mutex_t = usize;
pub type ecs_os_dl_t = usize;
pub type ecs_os_sock_t = usize;
#[doc = "64 bit thread id"]
pub type ecs_os_thread_id_t = u64;
#[doc = "Generic function pointer type"]
pub type ecs_os_proc_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = "OS API init"]
pub type ecs_os_api_init_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = "OS API deinit"]
pub type ecs_os_api_fini_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = "Memory management"]
pub type ecs_os_api_malloc_t =
    ::std::option::Option<unsafe extern "C" fn(size: ecs_size_t) -> *mut ::std::os::raw::c_void>;
pub type ecs_os_api_free_t =
    ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>;
pub type ecs_os_api_realloc_t = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type ecs_os_api_calloc_t =
    ::std::option::Option<unsafe extern "C" fn(size: ecs_size_t) -> *mut ::std::os::raw::c_void>;
pub type ecs_os_api_strdup_t = ::std::option::Option<
    unsafe extern "C" fn(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
#[doc = "Threads"]
pub type ecs_os_thread_callback_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
pub type ecs_os_api_thread_new_t = ::std::option::Option<
    unsafe extern "C" fn(
        callback: ecs_os_thread_callback_t,
        param: *mut ::std::os::raw::c_void,
    ) -> ecs_os_thread_t,
>;
pub type ecs_os_api_thread_join_t = ::std::option::Option<
    unsafe extern "C" fn(thread: ecs_os_thread_t) -> *mut ::std::os::raw::c_void,
>;
pub type ecs_os_api_thread_self_t =
    ::std::option::Option<unsafe extern "C" fn() -> ecs_os_thread_id_t>;
#[doc = "Tasks"]
pub type ecs_os_api_task_new_t = ::std::option::Option<
    unsafe extern "C" fn(
        callback: ecs_os_thread_callback_t,
        param: *mut ::std::os::raw::c_void,
    ) -> ecs_os_thread_t,
>;
pub type ecs_os_api_task_join_t = ::std::option::Option<
    unsafe extern "C" fn(thread: ecs_os_thread_t) -> *mut ::std::os::raw::c_void,
>;
#[doc = "Atomic increment / decrement"]
pub type ecs_os_api_ainc_t = ::std::option::Option<unsafe extern "C" fn(value: *mut i32) -> i32>;
pub type ecs_os_api_lainc_t = ::std::option::Option<unsafe extern "C" fn(value: *mut i64) -> i64>;
#[doc = "Mutex"]
pub type ecs_os_api_mutex_new_t = ::std::option::Option<unsafe extern "C" fn() -> ecs_os_mutex_t>;
pub type ecs_os_api_mutex_lock_t =
    ::std::option::Option<unsafe extern "C" fn(mutex: ecs_os_mutex_t)>;
pub type ecs_os_api_mutex_unlock_t =
    ::std::option::Option<unsafe extern "C" fn(mutex: ecs_os_mutex_t)>;
pub type ecs_os_api_mutex_free_t =
    ::std::option::Option<unsafe extern "C" fn(mutex: ecs_os_mutex_t)>;
#[doc = "Condition variable"]
pub type ecs_os_api_cond_new_t = ::std::option::Option<unsafe extern "C" fn() -> ecs_os_cond_t>;
pub type ecs_os_api_cond_free_t = ::std::option::Option<unsafe extern "C" fn(cond: ecs_os_cond_t)>;
pub type ecs_os_api_cond_signal_t =
    ::std::option::Option<unsafe extern "C" fn(cond: ecs_os_cond_t)>;
pub type ecs_os_api_cond_broadcast_t =
    ::std::option::Option<unsafe extern "C" fn(cond: ecs_os_cond_t)>;
pub type ecs_os_api_cond_wait_t =
    ::std::option::Option<unsafe extern "C" fn(cond: ecs_os_cond_t, mutex: ecs_os_mutex_t)>;
pub type ecs_os_api_sleep_t = ::std::option::Option<unsafe extern "C" fn(sec: i32, nanosec: i32)>;
pub type ecs_os_api_enable_high_timer_resolution_t =
    ::std::option::Option<unsafe extern "C" fn(enable: bool)>;
pub type ecs_os_api_get_time_t =
    ::std::option::Option<unsafe extern "C" fn(time_out: *mut ecs_time_t)>;
pub type ecs_os_api_now_t = ::std::option::Option<unsafe extern "C" fn() -> u64>;
#[doc = "Logging"]
pub type ecs_os_api_log_t = ::std::option::Option<
    unsafe extern "C" fn(
        level: i32,
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    ),
>;
#[doc = "Application termination"]
pub type ecs_os_api_abort_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = "Dynamic libraries"]
pub type ecs_os_api_dlopen_t = ::std::option::Option<
    unsafe extern "C" fn(libname: *const ::std::os::raw::c_char) -> ecs_os_dl_t,
>;
pub type ecs_os_api_dlproc_t = ::std::option::Option<
    unsafe extern "C" fn(
        lib: ecs_os_dl_t,
        procname: *const ::std::os::raw::c_char,
    ) -> ecs_os_proc_t,
>;
pub type ecs_os_api_dlclose_t = ::std::option::Option<unsafe extern "C" fn(lib: ecs_os_dl_t)>;
pub type ecs_os_api_module_to_path_t = ::std::option::Option<
    unsafe extern "C" fn(module_id: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
#[doc = "Prefix members of struct with 'ecs_' as some system headers may define\n macros for functions like \"strdup\", \"log\" or \"_free\""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_os_api_t {
    #[doc = "API init / deinit"]
    pub init_: ecs_os_api_init_t,
    pub fini_: ecs_os_api_fini_t,
    #[doc = "Memory management"]
    pub malloc_: ecs_os_api_malloc_t,
    pub realloc_: ecs_os_api_realloc_t,
    pub calloc_: ecs_os_api_calloc_t,
    pub free_: ecs_os_api_free_t,
    #[doc = "Strings"]
    pub strdup_: ecs_os_api_strdup_t,
    #[doc = "Threads"]
    pub thread_new_: ecs_os_api_thread_new_t,
    pub thread_join_: ecs_os_api_thread_join_t,
    pub thread_self_: ecs_os_api_thread_self_t,
    #[doc = "Tasks"]
    pub task_new_: ecs_os_api_thread_new_t,
    pub task_join_: ecs_os_api_thread_join_t,
    #[doc = "Atomic incremenet / decrement"]
    pub ainc_: ecs_os_api_ainc_t,
    pub adec_: ecs_os_api_ainc_t,
    pub lainc_: ecs_os_api_lainc_t,
    pub ladec_: ecs_os_api_lainc_t,
    #[doc = "Mutex"]
    pub mutex_new_: ecs_os_api_mutex_new_t,
    pub mutex_free_: ecs_os_api_mutex_free_t,
    pub mutex_lock_: ecs_os_api_mutex_lock_t,
    pub mutex_unlock_: ecs_os_api_mutex_lock_t,
    #[doc = "Condition variable"]
    pub cond_new_: ecs_os_api_cond_new_t,
    pub cond_free_: ecs_os_api_cond_free_t,
    pub cond_signal_: ecs_os_api_cond_signal_t,
    pub cond_broadcast_: ecs_os_api_cond_broadcast_t,
    pub cond_wait_: ecs_os_api_cond_wait_t,
    #[doc = "Time"]
    pub sleep_: ecs_os_api_sleep_t,
    pub now_: ecs_os_api_now_t,
    pub get_time_: ecs_os_api_get_time_t,
    #[doc = "Logging function. The level should be interpreted as: */\n/* >0: Debug tracing. Only enabled in debug builds. */\n/*  0: Tracing. Enabled in debug/release builds. */\n/* -2: Warning. An issue occurred, but operation was successful. */\n/* -3: Error. An issue occurred, and operation was unsuccessful. */\n/* -4: Fatal. An issue occurred, and application must quit."]
    pub log_: ecs_os_api_log_t,
    #[doc = "Application termination"]
    pub abort_: ecs_os_api_abort_t,
    #[doc = "Dynamic library loading"]
    pub dlopen_: ecs_os_api_dlopen_t,
    pub dlproc_: ecs_os_api_dlproc_t,
    pub dlclose_: ecs_os_api_dlclose_t,
    #[doc = "Overridable function that translates from a logical module id to a\n shared library filename"]
    pub module_to_dl_: ecs_os_api_module_to_path_t,
    #[doc = "Overridable function that translates from a logical module id to a\n path that contains module-specif resources or assets"]
    pub module_to_etc_: ecs_os_api_module_to_path_t,
    #[doc = "Trace level"]
    pub log_level_: i32,
    #[doc = "Trace indentation"]
    pub log_indent_: i32,
    #[doc = "Last error code"]
    pub log_last_error_: i32,
    #[doc = "Last recorded timestamp"]
    pub log_last_timestamp_: i64,
    #[doc = "OS API flags"]
    pub flags_: ecs_flags32_t,
}
extern "C" {
    pub static mut ecs_os_api: ecs_os_api_t;
}
extern "C" {
    pub fn ecs_os_init();
}
extern "C" {
    pub fn ecs_os_fini();
}
extern "C" {
    pub fn ecs_os_set_api(os_api: *mut ecs_os_api_t);
}
extern "C" {
    pub fn ecs_os_get_api() -> ecs_os_api_t;
}
extern "C" {
    pub fn ecs_os_set_api_defaults();
}
extern "C" {
    #[doc = "Logging"]
    pub fn ecs_os_dbg(
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ecs_os_trace(
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ecs_os_warn(
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ecs_os_err(
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ecs_os_fatal(
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ecs_os_strerror(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecs_os_strset(
        str_: *mut *mut ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "Sleep with floating point time"]
    pub fn ecs_sleepf(t: f64);
}
extern "C" {
    #[doc = "Measure time since provided timestamp"]
    pub fn ecs_time_measure(start: *mut ecs_time_t) -> f64;
}
extern "C" {
    #[doc = "Calculate difference between two timestamps"]
    pub fn ecs_time_sub(t1: ecs_time_t, t2: ecs_time_t) -> ecs_time_t;
}
extern "C" {
    #[doc = "Convert time value to a double"]
    pub fn ecs_time_to_double(t: ecs_time_t) -> f64;
}
extern "C" {
    pub fn ecs_os_memdup(
        src: *const ::std::os::raw::c_void,
        size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Are heap functions available?"]
    pub fn ecs_os_has_heap() -> bool;
}
extern "C" {
    #[doc = "Are threading functions available?"]
    pub fn ecs_os_has_threading() -> bool;
}
extern "C" {
    #[doc = "Are task functions available?"]
    pub fn ecs_os_has_task_support() -> bool;
}
extern "C" {
    #[doc = "Are time functions available?"]
    pub fn ecs_os_has_time() -> bool;
}
extern "C" {
    #[doc = "Are logging functions available?"]
    pub fn ecs_os_has_logging() -> bool;
}
extern "C" {
    #[doc = "Are dynamic library functions available?"]
    pub fn ecs_os_has_dl() -> bool;
}
extern "C" {
    #[doc = "Are module path functions available?"]
    pub fn ecs_os_has_modules() -> bool;
}
#[doc = "An id. Ids are the things that can be added to an entity. An id can be an\n entity or pair, and can have optional id flags."]
pub type ecs_id_t = u64;
#[doc = "An entity identifier."]
pub type ecs_entity_t = ecs_id_t;
#[doc = "An array with (component) ids"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_type_t {
    pub array: *mut ecs_id_t,
    pub count: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_world_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_table_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_rule_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_id_record_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_table_record_t {
    _unused: [u8; 0],
}
#[doc = "A poly object.\n A poly (short for polymorph) object is an object that has a variable list of\n capabilities, determined by a mixin table. This is the current list of types\n in the flecs API that can be used as an ecs_poly_t:\n\n - ecs_world_t\n - ecs_stage_t\n - ecs_query_t\n - ecs_filter_t\n - ecs_rule_t\n - (more to come)\n\n Functions that accept an ecs_poly_t argument can accept objects of these\n types. If the object does not have the requested mixin the API will throw an\n assert.\n\n The poly/mixin framework enables partially overlapping features to be\n implemented once, and enables objects of different types to interact with\n each other depending on what mixins they have, rather than their type\n (in some ways it's like a mini-ECS). Additionally, each poly object has a\n header that enables the API to do sanity checking on the input arguments."]
pub type ecs_poly_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_mixins_t {
    _unused: [u8; 0],
}
#[doc = "Header for ecs_poly_t objects."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_header_t {
    #[doc = "Magic number verifying it's a flecs object"]
    pub magic: i32,
    #[doc = "Magic number indicating which type of flecs object"]
    pub type_: i32,
    #[doc = "Table with offsets to (optional) mixins"]
    pub mixins: *mut ecs_mixins_t,
}
#[doc = "Function prototype for runnables (systems, observers).\n The run callback overrides the default behavior for iterating through the\n results of a runnable object.\n\n The default runnable iterates the iterator, and calls an iter_action (see\n below) for each returned result.\n\n @param it The iterator to be iterated by the runnable."]
pub type ecs_run_action_t = ::std::option::Option<unsafe extern "C" fn(it: *mut ecs_iter_t)>;
#[doc = "Function prototype for iterables.\n A system may invoke a callback multiple times, typically once for each\n matched table.\n\n @param it The iterator containing the data for the current match."]
pub type ecs_iter_action_t = ::std::option::Option<unsafe extern "C" fn(it: *mut ecs_iter_t)>;
#[doc = "Function prototype for creating an iterator from a poly.\n Used to create iterators from poly objects with the iterable mixin. When a\n filter is provided, an array of two iterators must be passed to the function.\n This allows the mixin implementation to create a chained iterator when\n necessary, which requires two iterator objects.\n\n @param world The world or stage for which to create the iterator.\n @param iterable An iterable poly object.\n @param it The iterator to create (out parameter)\n @param filter Optional term to filter results."]
pub type ecs_iter_init_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        world: *const ecs_world_t,
        iterable: *const ecs_poly_t,
        it: *mut ecs_iter_t,
        filter: *mut ecs_term_t,
    ),
>;
#[doc = "Function prototype for iterating an iterator.\n Stored inside initialized iterators. This allows an application to * iterate\n an iterator without needing to know what created it.\n\n @param it The iterator to iterate.\n @return True if iterator has no more results, false if it does."]
pub type ecs_iter_next_action_t =
    ::std::option::Option<unsafe extern "C" fn(it: *mut ecs_iter_t) -> bool>;
#[doc = "Function prototype for freeing an iterator.\n Free iterator resources.\n\n @param it The iterator to free."]
pub type ecs_iter_fini_action_t = ::std::option::Option<unsafe extern "C" fn(it: *mut ecs_iter_t)>;
#[doc = "Callback used for comparing components"]
pub type ecs_order_by_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        e1: ecs_entity_t,
        ptr1: *const ::std::os::raw::c_void,
        e2: ecs_entity_t,
        ptr2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "Callback used for sorting the entire table of components"]
pub type ecs_sort_table_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        world: *mut ecs_world_t,
        table: *mut ecs_table_t,
        entities: *mut ecs_entity_t,
        ptr: *mut ::std::os::raw::c_void,
        size: i32,
        lo: i32,
        hi: i32,
        order_by: ecs_order_by_action_t,
    ),
>;
#[doc = "Callback used for grouping tables in a query"]
pub type ecs_group_by_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        world: *mut ecs_world_t,
        table: *mut ecs_table_t,
        group_id: ecs_id_t,
        ctx: *mut ::std::os::raw::c_void,
    ) -> u64,
>;
#[doc = "Callback invoked when a query creates a new group."]
pub type ecs_group_create_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        world: *mut ecs_world_t,
        group_id: u64,
        group_by_ctx: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = "Callback invoked when a query deletes an existing group."]
pub type ecs_group_delete_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        world: *mut ecs_world_t,
        group_id: u64,
        group_ctx: *mut ::std::os::raw::c_void,
        group_by_ctx: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = "Initialization action for modules"]
pub type ecs_module_action_t = ::std::option::Option<unsafe extern "C" fn(world: *mut ecs_world_t)>;
#[doc = "Action callback on world exit"]
pub type ecs_fini_action_t = ::std::option::Option<
    unsafe extern "C" fn(world: *mut ecs_world_t, ctx: *mut ::std::os::raw::c_void),
>;
#[doc = "Function to cleanup context data"]
pub type ecs_ctx_free_t =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
#[doc = "Callback used for sorting values"]
pub type ecs_compare_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        ptr1: *const ::std::os::raw::c_void,
        ptr2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "Callback used for hashing values"]
pub type ecs_hash_value_action_t =
    ::std::option::Option<unsafe extern "C" fn(ptr: *const ::std::os::raw::c_void) -> u64>;
#[doc = "Constructor/destructor callback"]
pub type ecs_xtor_t = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        count: i32,
        type_info: *const ecs_type_info_t,
    ),
>;
#[doc = "Copy is invoked when a component is copied into another component."]
pub type ecs_copy_t = ::std::option::Option<
    unsafe extern "C" fn(
        dst_ptr: *mut ::std::os::raw::c_void,
        src_ptr: *const ::std::os::raw::c_void,
        count: i32,
        type_info: *const ecs_type_info_t,
    ),
>;
#[doc = "Move is invoked when a component is moved to another component."]
pub type ecs_move_t = ::std::option::Option<
    unsafe extern "C" fn(
        dst_ptr: *mut ::std::os::raw::c_void,
        src_ptr: *mut ::std::os::raw::c_void,
        count: i32,
        type_info: *const ecs_type_info_t,
    ),
>;
#[doc = "Destructor function for poly objects"]
pub type ecs_poly_dtor_t = ::std::option::Option<unsafe extern "C" fn(poly: *mut ecs_poly_t)>;
#[doc = "Iterable mixin.\n Allows its container to be iterated."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_iterable_t {
    #[doc = "< Callback that creates iterator."]
    pub init: ecs_iter_init_action_t,
}
#[doc = "< InOut for regular terms, In for shared terms"]
pub const ecs_inout_kind_t_EcsInOutDefault: ecs_inout_kind_t = 0;
#[doc = "< Term is neither read nor written"]
pub const ecs_inout_kind_t_EcsInOutNone: ecs_inout_kind_t = 1;
#[doc = "< Term is both read and written"]
pub const ecs_inout_kind_t_EcsInOut: ecs_inout_kind_t = 2;
#[doc = "< Term is only read"]
pub const ecs_inout_kind_t_EcsIn: ecs_inout_kind_t = 3;
#[doc = "< Term is only written"]
pub const ecs_inout_kind_t_EcsOut: ecs_inout_kind_t = 4;
#[doc = "Specify read/write access for term"]
pub type ecs_inout_kind_t = ::std::os::raw::c_int;
#[doc = "< The term must match"]
pub const ecs_oper_kind_t_EcsAnd: ecs_oper_kind_t = 0;
#[doc = "< One of the terms in an or chain must match"]
pub const ecs_oper_kind_t_EcsOr: ecs_oper_kind_t = 1;
#[doc = "< The term must not match"]
pub const ecs_oper_kind_t_EcsNot: ecs_oper_kind_t = 2;
#[doc = "< The term may match"]
pub const ecs_oper_kind_t_EcsOptional: ecs_oper_kind_t = 3;
#[doc = "< Term must match all components from term id"]
pub const ecs_oper_kind_t_EcsAndFrom: ecs_oper_kind_t = 4;
#[doc = "< Term must match at least one component from term id"]
pub const ecs_oper_kind_t_EcsOrFrom: ecs_oper_kind_t = 5;
#[doc = "< Term must match none of the components from term id"]
pub const ecs_oper_kind_t_EcsNotFrom: ecs_oper_kind_t = 6;
#[doc = "Specify operator for term"]
pub type ecs_oper_kind_t = ::std::os::raw::c_int;
#[doc = "Type that describes a single identifier in a term"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_term_id_t {
    #[doc = "< Entity id. If left to 0 and flags does not\n specify whether id is an entity or a variable\n the id will be initialized to EcsThis.\n To explicitly set the id to 0, leave the id\n member to 0 and set EcsIsEntity in flags."]
    pub id: ecs_entity_t,
    #[doc = "< Name. This can be either the variable name\n (when the EcsIsVariable flag is set) or an\n entity name. Entity names are used to\n initialize the id member during term\n finalization and will be freed when term.move\n is set to true."]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< Relationship to traverse when looking for the\n component. The relationship must have\n the Traversable property. Default is IsA."]
    pub trav: ecs_entity_t,
    #[doc = "< Term flags"]
    pub flags: ecs_flags32_t,
}
#[doc = "Type that describes a term (single element in a query)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_term_t {
    #[doc = "< Component id to be matched by term. Can be\n set directly, or will be populated from the\n first/second members, which provide more\n flexibility."]
    pub id: ecs_id_t,
    #[doc = "< Source of term"]
    pub src: ecs_term_id_t,
    #[doc = "< Component or first element of pair"]
    pub first: ecs_term_id_t,
    #[doc = "< Second element of pair"]
    pub second: ecs_term_id_t,
    #[doc = "< Access to contents matched by term"]
    pub inout: ecs_inout_kind_t,
    #[doc = "< Operator of term"]
    pub oper: ecs_oper_kind_t,
    #[doc = "< Id flags of term id"]
    pub id_flags: ecs_id_t,
    #[doc = "< Name of term"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< Index of field for term in iterator"]
    pub field_index: i32,
    #[doc = "< Cached pointer to internal index"]
    pub idr: *mut ecs_id_record_t,
    #[doc = "< Flags that help eval, set by ecs_filter_init"]
    pub flags: ecs_flags16_t,
    #[doc = "< Used by internals"]
    pub move_: bool,
}
extern "C" {
    #[doc = "Use this variable to initialize user-allocated filter object"]
    pub static mut ECS_FILTER_INIT: ecs_filter_t;
}
#[doc = "Filters alllow for ad-hoc quick filtering of entity tables."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_filter_t {
    pub hdr: ecs_header_t,
    #[doc = "< Array containing terms for filter"]
    pub terms: *mut ecs_term_t,
    #[doc = "< Number of elements in terms array"]
    pub term_count: i32,
    #[doc = "< Number of fields in iterator for filter"]
    pub field_count: i32,
    #[doc = "< Is filter object owned by filter"]
    pub owned: bool,
    #[doc = "< Is terms array owned by filter"]
    pub terms_owned: bool,
    #[doc = "< Filter flags"]
    pub flags: ecs_flags32_t,
    #[doc = "< Placeholder variable names array"]
    pub variable_names: [*mut ::std::os::raw::c_char; 1usize],
    #[doc = "< Field size (same for each result)"]
    pub sizes: *mut i32,
    #[doc = "< Entity associated with filter (optional)"]
    pub entity: ecs_entity_t,
    #[doc = "< Iterable mixin"]
    pub iterable: ecs_iterable_t,
    #[doc = "< Dtor mixin"]
    pub dtor: ecs_poly_dtor_t,
    #[doc = "< World mixin"]
    pub world: *mut ecs_world_t,
}
#[doc = "An observer reacts to events matching a filter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_observer_t {
    pub hdr: ecs_header_t,
    #[doc = "< Query for observer"]
    pub filter: ecs_filter_t,
    #[doc = "Observer events"]
    pub events: [ecs_entity_t; 8usize],
    pub event_count: i32,
    #[doc = "< See ecs_observer_desc_t::callback"]
    pub callback: ecs_iter_action_t,
    #[doc = "< See ecs_observer_desc_t::run"]
    pub run: ecs_run_action_t,
    #[doc = "< Callback context"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Binding context (for language bindings)"]
    pub binding_ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Callback to free ctx"]
    pub ctx_free: ecs_ctx_free_t,
    #[doc = "< Callback to free binding_ctx"]
    pub binding_ctx_free: ecs_ctx_free_t,
    #[doc = "< Observable for observer"]
    pub observable: *mut ecs_observable_t,
    #[doc = "< Last handled event id"]
    pub last_event_id: *mut i32,
    pub last_event_id_storage: i32,
    #[doc = "< Id observer is registered with (single term observers only)"]
    pub register_id: ecs_id_t,
    #[doc = "< Index of the term in parent observer (single term observers only)"]
    pub term_index: i32,
    #[doc = "< If true, the observer only triggers when the\n filter did not match with the entity before\n the event happened."]
    pub is_monitor: bool,
    #[doc = "< If true, the observer triggers on more than one term"]
    pub is_multi: bool,
    #[doc = "Mixins"]
    pub dtor: ecs_poly_dtor_t,
}
#[doc = "Type that contains component lifecycle callbacks.\n\n \\ingroup components"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_type_hooks_t {
    #[doc = "< ctor"]
    pub ctor: ecs_xtor_t,
    #[doc = "< dtor"]
    pub dtor: ecs_xtor_t,
    #[doc = "< copy assignment"]
    pub copy: ecs_copy_t,
    #[doc = "< move assignment"]
    pub move_: ecs_move_t,
    #[doc = "Ctor + copy"]
    pub copy_ctor: ecs_copy_t,
    #[doc = "Ctor + move"]
    pub move_ctor: ecs_move_t,
    #[doc = "Ctor + move + dtor (or move_ctor + dtor).\n This combination is typically used when a component is moved from one\n location to a new location, like when it is moved to a new table. If\n not set explicitly it will be derived from other callbacks."]
    pub ctor_move_dtor: ecs_move_t,
    #[doc = "Move + dtor.\n This combination is typically used when a component is moved from one\n location to an existing location, like what happens during a remove. If\n not set explicitly it will be derived from other callbacks."]
    pub move_dtor: ecs_move_t,
    #[doc = "Callback that is invoked when an instance of a component is added. This\n callback is invoked before triggers are invoked."]
    pub on_add: ecs_iter_action_t,
    #[doc = "Callback that is invoked when an instance of the component is set. This\n callback is invoked before triggers are invoked, and enable the component\n to respond to changes on itself before others can."]
    pub on_set: ecs_iter_action_t,
    #[doc = "Callback that is invoked when an instance of the component is removed.\n This callback is invoked after the triggers are invoked, and before the\n destructor is invoked."]
    pub on_remove: ecs_iter_action_t,
    #[doc = "< User defined context"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Language binding context"]
    pub binding_ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Callback to free ctx"]
    pub ctx_free: ecs_ctx_free_t,
    #[doc = "< Callback to free binding_ctx"]
    pub binding_ctx_free: ecs_ctx_free_t,
}
#[doc = "Type that contains component information (passed to ctors/dtors/...)\n\n \\ingroup components"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_type_info_t {
    #[doc = "< Size of type"]
    pub size: ecs_size_t,
    #[doc = "< Alignment of type"]
    pub alignment: ecs_size_t,
    #[doc = "< Type hooks"]
    pub hooks: ecs_type_hooks_t,
    #[doc = "< Handle to component (do not set)"]
    pub component: ecs_entity_t,
    #[doc = "< Type name."]
    pub name: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_stage_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_data_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_switch_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_table_match_t {
    _unused: [u8; 0],
}
#[doc = "Mixin for emitting events to triggers/observers */\n/** All observers for a specific event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_event_record_t {
    pub any: *mut ecs_event_id_record_t,
    pub wildcard: *mut ecs_event_id_record_t,
    pub wildcard_pair: *mut ecs_event_id_record_t,
    #[doc = "map<id, ecs_event_id_record_t>"]
    pub event_ids: ecs_map_t,
    pub event: ecs_entity_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_observable_t {
    pub on_add: ecs_event_record_t,
    pub on_remove: ecs_event_record_t,
    pub on_set: ecs_event_record_t,
    pub un_set: ecs_event_record_t,
    pub on_wildcard: ecs_event_record_t,
    #[doc = "sparse<event, ecs_event_record_t>"]
    pub events: ecs_sparse_t,
}
#[doc = "Record for entity index"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_record_t {
    #[doc = "Id record to (*, entity) for target entities"]
    pub idr: *mut ecs_id_record_t,
    #[doc = "Identifies a type (and table) in world"]
    pub table: *mut ecs_table_t,
    #[doc = "Table row of the entity"]
    pub row: u32,
    #[doc = "Index in dense array"]
    pub dense: i32,
}
#[doc = "Range in table"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_table_range_t {
    pub table: *mut ecs_table_t,
    #[doc = "Leave both members to 0 to cover entire table"]
    pub offset: i32,
    pub count: i32,
}
#[doc = "Value of query variable"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_var_t {
    #[doc = "Set when variable stores a range of entities"]
    pub range: ecs_table_range_t,
    #[doc = "Set when variable stores single entity"]
    pub entity: ecs_entity_t,
}
#[doc = "Cached reference."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_ref_t {
    #[doc = "Entity"]
    pub entity: ecs_entity_t,
    #[doc = "Component id"]
    pub id: ecs_entity_t,
    #[doc = "Table record for component"]
    pub tr: *mut ecs_table_record_t,
    #[doc = "Entity index record"]
    pub record: *mut ecs_record_t,
}
#[doc = "Cursor to stack allocator (used internally)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_stack_page_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_stack_cursor_t {
    pub cur: *mut ecs_stack_page_t,
    pub sp: i16,
}
#[doc = "Page-iterator specific data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_page_iter_t {
    pub offset: i32,
    pub limit: i32,
    pub remaining: i32,
}
#[doc = "Worker-iterator specific data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_worker_iter_t {
    pub index: i32,
    pub count: i32,
}
#[doc = "Convenience struct to iterate table array for id"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_table_cache_iter_t {
    pub cur: *mut ecs_table_cache_hdr_t,
    pub next: *mut ecs_table_cache_hdr_t,
    pub next_list: *mut ecs_table_cache_hdr_t,
}
#[doc = "Term-iterator specific data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_term_iter_t {
    pub term: ecs_term_t,
    pub self_index: *mut ecs_id_record_t,
    pub set_index: *mut ecs_id_record_t,
    pub cur: *mut ecs_id_record_t,
    pub it: ecs_table_cache_iter_t,
    pub index: i32,
    pub observed_table_count: i32,
    pub table: *mut ecs_table_t,
    pub cur_match: i32,
    pub match_count: i32,
    pub last_column: i32,
    pub empty_tables: bool,
    #[doc = "Storage"]
    pub id: ecs_id_t,
    pub column: i32,
    pub subject: ecs_entity_t,
    pub size: ecs_size_t,
    pub ptr: *mut ::std::os::raw::c_void,
}
pub const ecs_iter_kind_t_EcsIterEvalCondition: ecs_iter_kind_t = 0;
pub const ecs_iter_kind_t_EcsIterEvalTables: ecs_iter_kind_t = 1;
pub const ecs_iter_kind_t_EcsIterEvalChain: ecs_iter_kind_t = 2;
pub const ecs_iter_kind_t_EcsIterEvalNone: ecs_iter_kind_t = 3;
pub type ecs_iter_kind_t = ::std::os::raw::c_int;
#[doc = "Filter-iterator specific data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_filter_iter_t {
    pub filter: *const ecs_filter_t,
    pub kind: ecs_iter_kind_t,
    pub term_iter: ecs_term_iter_t,
    pub matches_left: i32,
    pub pivot_term: i32,
}
#[doc = "Query-iterator specific data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_iter_t {
    pub query: *mut ecs_query_t,
    pub node: *mut ecs_query_table_match_t,
    pub prev: *mut ecs_query_table_match_t,
    pub last: *mut ecs_query_table_match_t,
    pub sparse_smallest: i32,
    pub sparse_first: i32,
    pub bitset_first: i32,
    pub skip_count: i32,
}
#[doc = "Snapshot-iterator specific data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_snapshot_iter_t {
    pub filter: ecs_filter_t,
    #[doc = "ecs_table_leaf_t"]
    pub tables: ecs_vec_t,
    pub index: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_rule_op_profile_t {
    #[doc = "0 = enter, 1 = redo"]
    pub count: [i32; 2usize],
}
#[doc = "Rule-iterator specific data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_rule_iter_t {
    pub rule: *const ecs_rule_t,
    #[doc = "Variable storage"]
    pub vars: *mut ecs_var_t,
    pub rule_vars: *mut ecs_rule_var_t,
    pub ops: *mut ecs_rule_op_t,
    #[doc = "Operation-specific state"]
    pub op_ctx: *mut ecs_rule_op_ctx_t,
    pub written: *mut u64,
    pub profile: *mut ecs_rule_op_profile_t,
    pub redo: bool,
    pub op: i16,
    pub sp: i16,
}
#[doc = "Inline iterator arrays to prevent allocations for small array sizes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_iter_cache_t {
    #[doc = "Stack cursor to restore to"]
    pub stack_cursor: ecs_stack_cursor_t,
    #[doc = "For which fields is the cache used"]
    pub used: ecs_flags8_t,
    #[doc = "Which fields are allocated"]
    pub allocated: ecs_flags8_t,
}
#[doc = "Private iterator data. Used by iterator implementations to keep track of\n progress & to provide builtin storage."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_iter_private_t {
    #[doc = "Iterator specific data"]
    pub iter: ecs_iter_private_t__bindgen_ty_1,
    #[doc = "Filter applied after matching a table"]
    pub entity_iter: *mut ::std::os::raw::c_void,
    #[doc = "Inline arrays to reduce allocations"]
    pub cache: ecs_iter_cache_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ecs_iter_private_t__bindgen_ty_1 {
    pub term: ecs_term_iter_t,
    pub filter: ecs_filter_iter_t,
    pub query: ecs_query_iter_t,
    pub rule: ecs_rule_iter_t,
    pub snapshot: ecs_snapshot_iter_t,
    pub page: ecs_page_iter_t,
    pub worker: ecs_worker_iter_t,
}
#[doc = "Iterator"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_iter_t {
    #[doc = "The world"]
    pub world: *mut ecs_world_t,
    #[doc = "Actual world. This differs from world when in readonly mode"]
    pub real_world: *mut ecs_world_t,
    #[doc = "Entity identifiers"]
    pub entities: *mut ecs_entity_t,
    #[doc = "Pointers to components. Array if from this, pointer if not."]
    pub ptrs: *mut *mut ::std::os::raw::c_void,
    #[doc = "Component sizes"]
    pub sizes: *mut ecs_size_t,
    #[doc = "Current table"]
    pub table: *mut ecs_table_t,
    #[doc = "Prev or next table when adding/removing"]
    pub other_table: *mut ecs_table_t,
    #[doc = "(Component) ids"]
    pub ids: *mut ecs_id_t,
    #[doc = "Values of variables (if any)"]
    pub variables: *mut ecs_var_t,
    #[doc = "Query term to table column mapping"]
    pub columns: *mut i32,
    #[doc = "Entity on which the id was matched (0 if same as entities)"]
    pub sources: *mut ecs_entity_t,
    #[doc = "Indices of current match for term. Allows an iterator to iterate\n all permutations of wildcards in query."]
    pub match_indices: *mut i32,
    #[doc = "Cached refs to components (if iterating a cache)"]
    pub references: *mut ecs_ref_t,
    #[doc = "Bitset that marks constrained variables"]
    pub constrained_vars: ecs_flags64_t,
    #[doc = "Group id for table, if group_by is used"]
    pub group_id: u64,
    #[doc = "Number of fields in iterator"]
    pub field_count: i32,
    #[doc = "The system (if applicable)"]
    pub system: ecs_entity_t,
    #[doc = "The event (if applicable)"]
    pub event: ecs_entity_t,
    #[doc = "The (component) id for the event"]
    pub event_id: ecs_id_t,
    #[doc = "Terms of query being evaluated"]
    pub terms: *mut ecs_term_t,
    #[doc = "Active table count for query"]
    pub table_count: i32,
    #[doc = "Index of term that emitted an event.\n This field will be set to the 'index' field\n of an observer term."]
    pub term_index: i32,
    #[doc = "Number of variables for query"]
    pub variable_count: i32,
    #[doc = "Names of variables (if any)"]
    pub variable_names: *mut *mut ::std::os::raw::c_char,
    #[doc = "Param passed to ecs_run"]
    pub param: *mut ::std::os::raw::c_void,
    #[doc = "System context"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = "Binding context"]
    pub binding_ctx: *mut ::std::os::raw::c_void,
    #[doc = "Time elapsed since last frame"]
    pub delta_time: f32,
    #[doc = "Time elapsed since last system invocation"]
    pub delta_system_time: f32,
    #[doc = "Offset relative to start of iteration"]
    pub frame_offset: i32,
    #[doc = "Offset relative to current table"]
    pub offset: i32,
    #[doc = "Number of entities to iterate"]
    pub count: i32,
    #[doc = "Number of entities to iterate before next table"]
    pub instance_count: i32,
    #[doc = "Iterator flags"]
    pub flags: ecs_flags32_t,
    #[doc = "When set, system execution is interrupted"]
    pub interrupted_by: ecs_entity_t,
    #[doc = "Private data"]
    pub priv_: ecs_iter_private_t,
    #[doc = "Function to progress iterator"]
    pub next: ecs_iter_next_action_t,
    #[doc = "Callback of system or observer"]
    pub callback: ecs_iter_action_t,
    #[doc = "Function to cleanup iterator resources"]
    pub fini: ecs_iter_fini_action_t,
    #[doc = "Optional, allows for creating iterator chains"]
    pub chain_it: *mut ecs_iter_t,
}
extern "C" {
    pub fn ecs_module_path_from_c(
        c_name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecs_identifier_is_0(id: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = "Constructor that zeromem's a component value"]
    pub fn ecs_default_ctor(
        ptr: *mut ::std::os::raw::c_void,
        count: i32,
        ctx: *const ecs_type_info_t,
    );
}
extern "C" {
    #[doc = "Create allocated string from format"]
    pub fn ecs_vasprintf(
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Create allocated string from format"]
    pub fn ecs_asprintf(fmt: *const ::std::os::raw::c_char, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Convert identifier to snake case"]
    pub fn flecs_to_snake_case(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flecs_table_observed_count(table: *const ecs_table_t) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_hm_bucket_t {
    pub keys: ecs_vec_t,
    pub values: ecs_vec_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_hashmap_t {
    pub hash: ecs_hash_value_action_t,
    pub compare: ecs_compare_action_t,
    pub key_size: ecs_size_t,
    pub value_size: ecs_size_t,
    pub hashmap_allocator: *mut ecs_block_allocator_t,
    pub bucket_allocator: ecs_block_allocator_t,
    pub impl_: ecs_map_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flecs_hashmap_iter_t {
    pub it: ecs_map_iter_t,
    pub bucket: *mut ecs_hm_bucket_t,
    pub index: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flecs_hashmap_result_t {
    pub key: *mut ::std::os::raw::c_void,
    pub value: *mut ::std::os::raw::c_void,
    pub hash: u64,
}
extern "C" {
    pub fn _flecs_hashmap_init(
        hm: *mut ecs_hashmap_t,
        key_size: ecs_size_t,
        value_size: ecs_size_t,
        hash: ecs_hash_value_action_t,
        compare: ecs_compare_action_t,
        allocator: *mut ecs_allocator_t,
    );
}
extern "C" {
    pub fn flecs_hashmap_fini(map: *mut ecs_hashmap_t);
}
extern "C" {
    pub fn _flecs_hashmap_get(
        map: *const ecs_hashmap_t,
        key_size: ecs_size_t,
        key: *const ::std::os::raw::c_void,
        value_size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _flecs_hashmap_ensure(
        map: *mut ecs_hashmap_t,
        key_size: ecs_size_t,
        key: *const ::std::os::raw::c_void,
        value_size: ecs_size_t,
    ) -> flecs_hashmap_result_t;
}
extern "C" {
    pub fn _flecs_hashmap_set(
        map: *mut ecs_hashmap_t,
        key_size: ecs_size_t,
        key: *mut ::std::os::raw::c_void,
        value_size: ecs_size_t,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn _flecs_hashmap_remove(
        map: *mut ecs_hashmap_t,
        key_size: ecs_size_t,
        key: *const ::std::os::raw::c_void,
        value_size: ecs_size_t,
    );
}
extern "C" {
    pub fn _flecs_hashmap_remove_w_hash(
        map: *mut ecs_hashmap_t,
        key_size: ecs_size_t,
        key: *const ::std::os::raw::c_void,
        value_size: ecs_size_t,
        hash: u64,
    );
}
extern "C" {
    pub fn flecs_hashmap_get_bucket(map: *const ecs_hashmap_t, hash: u64) -> *mut ecs_hm_bucket_t;
}
extern "C" {
    pub fn flecs_hm_bucket_remove(
        map: *mut ecs_hashmap_t,
        bucket: *mut ecs_hm_bucket_t,
        hash: u64,
        index: i32,
    );
}
extern "C" {
    pub fn flecs_hashmap_copy(dst: *mut ecs_hashmap_t, src: *const ecs_hashmap_t);
}
extern "C" {
    pub fn flecs_hashmap_iter(map: *mut ecs_hashmap_t) -> flecs_hashmap_iter_t;
}
extern "C" {
    pub fn _flecs_hashmap_next(
        it: *mut flecs_hashmap_iter_t,
        key_size: ecs_size_t,
        key_out: *mut ::std::os::raw::c_void,
        value_size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = "Used with ecs_entity_init\n\n \\ingroup entities"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_entity_desc_t {
    pub _canary: i32,
    #[doc = "< Set to modify existing entity (optional)"]
    pub id: ecs_entity_t,
    #[doc = "< Name of the entity. If no entity is provided, an\n entity with this name will be looked up first. When\n an entity is provided, the name will be verified\n with the existing entity."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Optional custom separator for hierarchical names.\n Leave to NULL for default ('.') separator. Set to\n an empty string to prevent tokenization of name."]
    pub sep: *const ::std::os::raw::c_char,
    #[doc = "< Optional, used for identifiers relative to root"]
    pub root_sep: *const ::std::os::raw::c_char,
    #[doc = "< Optional entity symbol. A symbol is an unscoped\n identifier that can be used to lookup an entity. The\n primary use case for this is to associate the entity\n with a language identifier, such as a type or\n function name, where these identifiers differ from\n the name they are registered with in flecs. For\n example, C type \"EcsPosition\" might be registered\n as \"flecs.components.transform.Position\", with the\n symbol set to \"EcsPosition\"."]
    pub symbol: *const ::std::os::raw::c_char,
    #[doc = "< When set to true, a low id (typically reserved for\n components) will be used to create the entity, if\n no id is specified."]
    pub use_low_id: bool,
    #[doc = "Array of ids to add to the new or existing entity."]
    pub add: [ecs_id_t; 32usize],
    #[doc = "String expression with components to add"]
    pub add_expr: *const ::std::os::raw::c_char,
}
#[doc = "Used with ecs_bulk_init\n\n \\ingroup entities"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_bulk_desc_t {
    pub _canary: i32,
    #[doc = "< Entities to bulk insert. Entity ids provided by\n the application application must be empty (cannot\n have components). If no entity ids are provided, the\n operation will create 'count' new entities."]
    pub entities: *mut ecs_entity_t,
    #[doc = "< Number of entities to create/populate"]
    pub count: i32,
    #[doc = "< Ids to create the entities with"]
    pub ids: [ecs_id_t; 32usize],
    #[doc = "< Array with component data to insert. Each element in\n the array must correspond with an element in the ids\n array. If an element in the ids array is a tag, the\n data array must contain a NULL. An element may be\n set to NULL for a component, in which case the\n component will not be set by the operation."]
    pub data: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Table to insert the entities into. Should not be set\n at the same time as ids. When 'table' is set at the\n same time as 'data', the elements in the data array\n must correspond with the ids in the table's type."]
    pub table: *mut ecs_table_t,
}
#[doc = "Used with ecs_component_init.\n\n \\ingroup components"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_component_desc_t {
    pub _canary: i32,
    #[doc = "Existing entity to associate with observer (optional)"]
    pub entity: ecs_entity_t,
    #[doc = "Parameters for type (size, hooks, ...)"]
    pub type_: ecs_type_info_t,
}
#[doc = "Used with ecs_filter_init.\n\n \\ingroup filters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_filter_desc_t {
    pub _canary: i32,
    #[doc = "Terms of the filter. If a filter has more terms than\n FLECS_TERM_DESC_MAX use terms_buffer"]
    pub terms: [ecs_term_t; 16usize],
    #[doc = "For filters with lots of terms an outside array can be provided."]
    pub terms_buffer: *mut ecs_term_t,
    #[doc = "Number of terms in array provided in terms_buffer."]
    pub terms_buffer_count: i32,
    #[doc = "External storage to prevent allocation of the filter object"]
    pub storage: *mut ecs_filter_t,
    #[doc = "When true, terms returned by an iterator may either contain 1 or N\n elements, where terms with N elements are owned, and terms with 1 element\n are shared, for example from a parent or base entity. When false, the\n iterator will at most return 1 element when the result contains both\n owned and shared terms."]
    pub instanced: bool,
    #[doc = "Flags for advanced usage"]
    pub flags: ecs_flags32_t,
    #[doc = "Filter expression. Should not be set at the same time as terms array"]
    pub expr: *const ::std::os::raw::c_char,
    #[doc = "Entity associated with query (optional)"]
    pub entity: ecs_entity_t,
}
#[doc = "Used with ecs_query_init.\n\n \\ingroup queries"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_desc_t {
    pub _canary: i32,
    #[doc = "Filter for the query"]
    pub filter: ecs_filter_desc_t,
    #[doc = "Component to be used by order_by"]
    pub order_by_component: ecs_entity_t,
    #[doc = "Callback used for ordering query results. If order_by_id is 0, the\n pointer provided to the callback will be NULL. If the callback is not\n set, results will not be ordered."]
    pub order_by: ecs_order_by_action_t,
    #[doc = "Callback used for ordering query results. Same as order_by,\n but more efficient."]
    pub sort_table: ecs_sort_table_action_t,
    #[doc = "Id to be used by group_by. This id is passed to the group_by function and\n can be used identify the part of an entity type that should be used for\n grouping."]
    pub group_by_id: ecs_id_t,
    #[doc = "Callback used for grouping results. If the callback is not set, results\n will not be grouped. When set, this callback will be used to calculate a\n \"rank\" for each entity (table) based on its components. This rank is then\n used to sort entities (tables), so that entities (tables) of the same\n rank are \"grouped\" together when iterated."]
    pub group_by: ecs_group_by_action_t,
    #[doc = "Callback that is invoked when a new group is created. The return value of\n the callback is stored as context for a group."]
    pub on_group_create: ecs_group_create_action_t,
    #[doc = "Callback that is invoked when an existing group is deleted. The return\n value of the on_group_create callback is passed as context parameter."]
    pub on_group_delete: ecs_group_delete_action_t,
    #[doc = "Context to pass to group_by"]
    pub group_by_ctx: *mut ::std::os::raw::c_void,
    #[doc = "Function to free group_by_ctx"]
    pub group_by_ctx_free: ecs_ctx_free_t,
    #[doc = "If set, the query will be created as a subquery. A subquery matches at\n most a subset of its parent query. Subqueries do not directly receive\n (table) notifications from the world. Instead parent queries forward\n results to subqueries. This can improve matching performance, as fewer\n queries need to be matched with new tables.\n Subqueries can be nested."]
    pub parent: *mut ecs_query_t,
}
#[doc = "Used with ecs_observer_init.\n\n \\ingroup observers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_observer_desc_t {
    pub _canary: i32,
    #[doc = "Existing entity to associate with observer (optional)"]
    pub entity: ecs_entity_t,
    #[doc = "Filter for observer"]
    pub filter: ecs_filter_desc_t,
    #[doc = "Events to observe (OnAdd, OnRemove, OnSet, UnSet)"]
    pub events: [ecs_entity_t; 8usize],
    #[doc = "When observer is created, generate events from existing data. For example,\n EcsOnAdd Position would match all existing instances of Position.\n This is only supported for events that are iterable (see EcsIterable)"]
    pub yield_existing: bool,
    #[doc = "Callback to invoke on an event, invoked when the observer matches."]
    pub callback: ecs_iter_action_t,
    #[doc = "Callback invoked on an event. When left to NULL the default runner\n is used which matches the event with the observer's filter, and calls\n 'callback' when it matches.\n A reason to override the run function is to improve performance, if there\n are more efficient way to test whether an event matches the observer than\n the general purpose query matcher."]
    pub run: ecs_run_action_t,
    #[doc = "User context to pass to callback"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = "Context to be used for language bindings"]
    pub binding_ctx: *mut ::std::os::raw::c_void,
    #[doc = "Callback to free ctx"]
    pub ctx_free: ecs_ctx_free_t,
    #[doc = "Callback to free binding_ctx"]
    pub binding_ctx_free: ecs_ctx_free_t,
    #[doc = "Observable with which to register the observer"]
    pub observable: *mut ecs_poly_t,
    #[doc = "Optional shared last event id for multiple observers. Ensures only one\n of the observers with the shared id gets triggered for an event"]
    pub last_event_id: *mut i32,
    #[doc = "Used for internal purposes"]
    pub term_index: i32,
}
#[doc = "Utility to hold a value of a dynamic type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_value_t {
    pub type_: ecs_entity_t,
    pub ptr: *mut ::std::os::raw::c_void,
}
#[doc = "Type that contains information about the world."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_world_info_t {
    #[doc = "< Last issued component entity id"]
    pub last_component_id: ecs_entity_t,
    #[doc = "< First allowed entity id"]
    pub min_id: ecs_entity_t,
    #[doc = "< Last allowed entity id"]
    pub max_id: ecs_entity_t,
    #[doc = "< Raw delta time (no time scaling)"]
    pub delta_time_raw: f32,
    #[doc = "< Time passed to or computed by ecs_progress"]
    pub delta_time: f32,
    #[doc = "< Time scale applied to delta_time"]
    pub time_scale: f32,
    #[doc = "< Target fps"]
    pub target_fps: f32,
    #[doc = "< Total time spent processing a frame"]
    pub frame_time_total: f32,
    #[doc = "< Total time spent in systems"]
    pub system_time_total: f32,
    #[doc = "< Total time spent notifying observers"]
    pub emit_time_total: f32,
    #[doc = "< Total time spent in merges"]
    pub merge_time_total: f32,
    #[doc = "< Time elapsed in simulation"]
    pub world_time_total: f32,
    #[doc = "< Time elapsed in simulation (no scaling)"]
    pub world_time_total_raw: f32,
    #[doc = "< Time spent on query rematching"]
    pub rematch_time_total: f32,
    #[doc = "< Total number of frames"]
    pub frame_count_total: i64,
    #[doc = "< Total number of merges"]
    pub merge_count_total: i64,
    #[doc = "< Total number of rematches"]
    pub rematch_count_total: i64,
    #[doc = "< Total number of times a new id was created"]
    pub id_create_total: i64,
    #[doc = "< Total number of times an id was deleted"]
    pub id_delete_total: i64,
    #[doc = "< Total number of times a table was created"]
    pub table_create_total: i64,
    #[doc = "< Total number of times a table was deleted"]
    pub table_delete_total: i64,
    #[doc = "< Total number of pipeline builds"]
    pub pipeline_build_count_total: i64,
    #[doc = "< Total number of systems ran in last frame"]
    pub systems_ran_frame: i64,
    #[doc = "< Total number of times observer was invoked"]
    pub observers_ran_frame: i64,
    #[doc = "< Number of ids in the world (excluding wildcards)"]
    pub id_count: i32,
    #[doc = "< Number of tag (no data) ids in the world"]
    pub tag_id_count: i32,
    #[doc = "< Number of component (data) ids in the world"]
    pub component_id_count: i32,
    #[doc = "< Number of pair ids in the world"]
    pub pair_id_count: i32,
    #[doc = "< Number of wildcard ids"]
    pub wildcard_id_count: i32,
    #[doc = "< Number of tables"]
    pub table_count: i32,
    #[doc = "< Number of tag-only tables"]
    pub tag_table_count: i32,
    #[doc = "< Number of tables with trivial components (no lifecycle callbacks)"]
    pub trivial_table_count: i32,
    #[doc = "< Number of tables without entities"]
    pub empty_table_count: i32,
    #[doc = "< Total number of table records (entries in table caches)"]
    pub table_record_count: i32,
    #[doc = "< Total number of table storages"]
    pub table_storage_count: i32,
    pub cmd: ecs_world_info_t__bindgen_ty_1,
    #[doc = "< Value set by ecs_set_name_prefix. Used\n to remove library prefixes of symbol\n names (such as Ecs, ecs_) when\n registering them as names."]
    pub name_prefix: *const ::std::os::raw::c_char,
}
#[doc = "-- Command counts --"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_world_info_t__bindgen_ty_1 {
    #[doc = "< add commands processed"]
    pub add_count: i64,
    #[doc = "< remove commands processed"]
    pub remove_count: i64,
    #[doc = "< delete commands processed"]
    pub delete_count: i64,
    #[doc = "< clear commands processed"]
    pub clear_count: i64,
    #[doc = "< set commands processed"]
    pub set_count: i64,
    #[doc = "< get_mut/emplace commands processed"]
    pub get_mut_count: i64,
    #[doc = "< modified commands processed"]
    pub modified_count: i64,
    #[doc = "< other commands processed"]
    pub other_count: i64,
    #[doc = "< commands discarded, happens when entity is no longer alive when running the command"]
    pub discard_count: i64,
    #[doc = "< entities for which commands were batched"]
    pub batched_entity_count: i64,
    #[doc = "< commands batched"]
    pub batched_command_count: i64,
}
#[doc = "Type that contains information about a query group."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_group_info_t {
    #[doc = "< How often tables have been matched/unmatched"]
    pub match_count: i32,
    #[doc = "< Number of tables in group"]
    pub table_count: i32,
    #[doc = "< Group context, returned by on_group_create"]
    pub ctx: *mut ::std::os::raw::c_void,
}
#[doc = "A (string) identifier. Used as pair with EcsName and EcsSymbol tags"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsIdentifier {
    #[doc = "< Identifier string"]
    pub value: *mut ::std::os::raw::c_char,
    #[doc = "< Length of identifier"]
    pub length: ecs_size_t,
    #[doc = "< Hash of current value"]
    pub hash: u64,
    #[doc = "< Hash of existing record in current index"]
    pub index_hash: u64,
    #[doc = "< Current index"]
    pub index: *mut ecs_hashmap_t,
}
#[doc = "Component information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsComponent {
    #[doc = "< Component size"]
    pub size: ecs_size_t,
    #[doc = "< Component alignment"]
    pub alignment: ecs_size_t,
}
#[doc = "Component for storing a poly object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsPoly {
    #[doc = "< Pointer to poly object"]
    pub poly: *mut ecs_poly_t,
}
#[doc = "Target data for flattened relationships."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsTarget {
    pub count: i32,
    pub target: *mut ecs_record_t,
}
#[doc = "Component for iterable entities"]
pub type EcsIterable = ecs_iterable_t;
extern "C" {
    #[doc = "Indicates that the id is a pair."]
    pub static ECS_PAIR: ecs_id_t;
}
extern "C" {
    #[doc = "Automatically override component when it is inherited"]
    pub static ECS_OVERRIDE: ecs_id_t;
}
extern "C" {
    #[doc = "Adds bitset to storage which allows component to be enabled/disabled"]
    pub static ECS_TOGGLE: ecs_id_t;
}
extern "C" {
    #[doc = "Include all components from entity to which AND is applied"]
    pub static ECS_AND: ecs_id_t;
}
extern "C" {
    pub static FLECS__EEcsComponent: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsIdentifier: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsIterable: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsPoly: ecs_entity_t;
}
extern "C" {
    pub static EcsQuery: ecs_entity_t;
}
extern "C" {
    pub static EcsObserver: ecs_entity_t;
}
extern "C" {
    #[doc = "System module component ids"]
    pub static EcsSystem: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsTickSource: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsPipelineQuery: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsTimer: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsRateFilter: ecs_entity_t;
}
extern "C" {
    #[doc = "Root scope for builtin flecs entities"]
    pub static EcsFlecs: ecs_entity_t;
}
extern "C" {
    #[doc = "Core module scope"]
    pub static EcsFlecsCore: ecs_entity_t;
}
extern "C" {
    #[doc = "Entity associated with world (used for \"attaching\" components to world)"]
    pub static EcsWorld: ecs_entity_t;
}
extern "C" {
    #[doc = "Wildcard entity (\"*\"). Matches any id, returns all matches."]
    pub static EcsWildcard: ecs_entity_t;
}
extern "C" {
    #[doc = "Any entity (\"_\"). Matches any id, returns only the first."]
    pub static EcsAny: ecs_entity_t;
}
extern "C" {
    #[doc = "This entity. Default source for queries."]
    pub static EcsThis: ecs_entity_t;
}
extern "C" {
    #[doc = "Variable entity (\"$\"). Used in expressions to prefix variable names"]
    pub static EcsVariable: ecs_entity_t;
}
extern "C" {
    #[doc = "Marks a relationship as transitive.\n Behavior:\n   if R(X, Y) and R(Y, Z) then R(X, Z)"]
    pub static EcsTransitive: ecs_entity_t;
}
extern "C" {
    #[doc = "Marks a relatoinship as reflexive.\n Behavior:\n   R(X, X) == true"]
    pub static EcsReflexive: ecs_entity_t;
}
extern "C" {
    #[doc = "Ensures that entity/component cannot be used as target in IsA relationship.\n Final can improve the performance of rule-based queries, as they will not\n attempt to substitute a final component with its subsets.\n\n Behavior:\n   if IsA(X, Y) and Final(Y) throw error"]
    pub static EcsFinal: ecs_entity_t;
}
extern "C" {
    #[doc = "Ensures that component is never inherited from an IsA target.\n\n Behavior:\n   if DontInherit(X) and X(B) and IsA(A, B) then X(A) is false."]
    pub static EcsDontInherit: ecs_entity_t;
}
extern "C" {
    #[doc = "Ensures a component is always overridden.\n\n Behavior:\n   As if the component is added together with OVERRIDE | T"]
    pub static EcsAlwaysOverride: ecs_entity_t;
}
extern "C" {
    #[doc = "Marks relationship as commutative.\n Behavior:\n   if R(X, Y) then R(Y, X)"]
    pub static EcsSymmetric: ecs_entity_t;
}
extern "C" {
    #[doc = "Can be added to relationship to indicate that the relationship can only occur\n once on an entity. Adding a 2nd instance will replace the 1st.\n\n Behavior:\n   R(X, Y) + R(X, Z) = R(X, Z)"]
    pub static EcsExclusive: ecs_entity_t;
}
extern "C" {
    #[doc = "Marks a relationship as acyclic. Acyclic relationships may not form cycles."]
    pub static EcsAcyclic: ecs_entity_t;
}
extern "C" {
    #[doc = "Marks a relationship as traversable. Traversable relationships may be\n traversed with \"up\" queries. Traversable relatinoships are acyclic."]
    pub static EcsTraversable: ecs_entity_t;
}
extern "C" {
    #[doc = "Ensure that a component always is added together with another component.\n\n Behavior:\n   If With(R, O) and R(X) then O(X)\n   If With(R, O) and R(X, Y) then O(X, Y)"]
    pub static EcsWith: ecs_entity_t;
}
extern "C" {
    #[doc = "Ensure that relationship target is child of specified entity.\n\n Behavior:\n   If OneOf(R, O) and R(X, Y), Y must be a child of O\n   If OneOf(R) and R(X, Y), Y must be a child of R"]
    pub static EcsOneOf: ecs_entity_t;
}
extern "C" {
    #[doc = "Can be added to relationship to indicate that it should never hold data, even\n when it or the relationship target is a component."]
    pub static EcsTag: ecs_entity_t;
}
extern "C" {
    #[doc = "Tag to indicate that relationship is stored as union. Union relationships enable\n changing the target of a union without switching tables. Union relationships\n are also marked as exclusive."]
    pub static EcsUnion: ecs_entity_t;
}
extern "C" {
    #[doc = "Tag to indicate name identifier"]
    pub static EcsName: ecs_entity_t;
}
extern "C" {
    #[doc = "Tag to indicate symbol identifier"]
    pub static EcsSymbol: ecs_entity_t;
}
extern "C" {
    #[doc = "Tag to indicate alias identifier"]
    pub static EcsAlias: ecs_entity_t;
}
extern "C" {
    #[doc = "Used to express parent-child relationships."]
    pub static EcsChildOf: ecs_entity_t;
}
extern "C" {
    #[doc = "Used to express inheritance relationships."]
    pub static EcsIsA: ecs_entity_t;
}
extern "C" {
    #[doc = "Used to express dependency relationships"]
    pub static EcsDependsOn: ecs_entity_t;
}
extern "C" {
    #[doc = "Used to express a slot (used with prefab inheritance)"]
    pub static EcsSlotOf: ecs_entity_t;
}
extern "C" {
    #[doc = "Tag added to module entities"]
    pub static EcsModule: ecs_entity_t;
}
extern "C" {
    #[doc = "Tag to indicate an entity/component/system is private to a module"]
    pub static EcsPrivate: ecs_entity_t;
}
extern "C" {
    #[doc = "Tag added to prefab entities. Any entity with this tag is automatically\n ignored by filters/queries, unless EcsPrefab is explicitly added."]
    pub static EcsPrefab: ecs_entity_t;
}
extern "C" {
    #[doc = "When this tag is added to an entity it is skipped by all queries/filters"]
    pub static EcsDisabled: ecs_entity_t;
}
extern "C" {
    #[doc = "Event. Triggers when an id (component, tag, pair) is added to an entity"]
    pub static EcsOnAdd: ecs_entity_t;
}
extern "C" {
    #[doc = "Event. Triggers when an id (component, tag, pair) is removed from an entity"]
    pub static EcsOnRemove: ecs_entity_t;
}
extern "C" {
    #[doc = "Event. Triggers when a component is set for an entity"]
    pub static EcsOnSet: ecs_entity_t;
}
extern "C" {
    #[doc = "Event. Triggers when a component is unset for an entity"]
    pub static EcsUnSet: ecs_entity_t;
}
extern "C" {
    #[doc = "Event. Exactly-once observer for when an entity matches/unmatches a filter"]
    pub static EcsMonitor: ecs_entity_t;
}
extern "C" {
    #[doc = "Event. Triggers when an entity is deleted.\n Also used as relationship for defining cleanup behavior, see:\n <https://github.com/SanderMertens/flecs/blob/master/docs/Relationships.md#cleanup-properties>"]
    pub static EcsOnDelete: ecs_entity_t;
}
extern "C" {
    #[doc = "Event. Triggers when a table is created."]
    pub static EcsOnTableCreate: ecs_entity_t;
}
extern "C" {
    #[doc = "Event. Triggers when a table is deleted."]
    pub static EcsOnTableDelete: ecs_entity_t;
}
extern "C" {
    #[doc = "Event. Triggers when a table becomes empty (doesn't emit on creation)."]
    pub static EcsOnTableEmpty: ecs_entity_t;
}
extern "C" {
    #[doc = "Event. Triggers when a table becomes non-empty."]
    pub static EcsOnTableFill: ecs_entity_t;
}
extern "C" {
    #[doc = "Relationship used to define what should happen when a target entity (second\n element of a pair) is deleted. For details see:\n <https://github.com/SanderMertens/flecs/blob/master/docs/Relationships.md#cleanup-properties>"]
    pub static EcsOnDeleteTarget: ecs_entity_t;
}
extern "C" {
    #[doc = "Remove cleanup policy. Must be used as target in pair with EcsOnDelete or\n EcsOnDeleteTarget."]
    pub static EcsRemove: ecs_entity_t;
}
extern "C" {
    #[doc = "Delete cleanup policy. Must be used as target in pair with EcsOnDelete or\n EcsOnDeleteTarget."]
    pub static EcsDelete: ecs_entity_t;
}
extern "C" {
    #[doc = "Panic cleanup policy. Must be used as target in pair with EcsOnDelete or\n EcsOnDeleteTarget."]
    pub static EcsPanic: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsTarget: ecs_entity_t;
}
extern "C" {
    pub static EcsFlatten: ecs_entity_t;
}
extern "C" {
    #[doc = "Used like (EcsDefaultChildComponent, Component). When added to an entity,\n this informs serialization formats which component to use when a value is\n assigned to an entity without specifying the component. This is intended as\n a hint, serialization formats are not required to use it. Adding this\n component does not change the behavior of core ECS operations."]
    pub static EcsDefaultChildComponent: ecs_entity_t;
}
extern "C" {
    #[doc = "Builtin predicates for comparing entity ids in queries. Only supported by rules"]
    pub static EcsPredEq: ecs_entity_t;
}
extern "C" {
    pub static EcsPredMatch: ecs_entity_t;
}
extern "C" {
    pub static EcsPredLookup: ecs_entity_t;
}
extern "C" {
    #[doc = "Builtin marker entities for opening/closing query scopes"]
    pub static EcsScopeOpen: ecs_entity_t;
}
extern "C" {
    pub static EcsScopeClose: ecs_entity_t;
}
extern "C" {
    #[doc = "Tag used to indicate query is empty"]
    pub static EcsEmpty: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsPipeline: ecs_entity_t;
}
extern "C" {
    pub static EcsOnStart: ecs_entity_t;
}
extern "C" {
    pub static EcsPreFrame: ecs_entity_t;
}
extern "C" {
    pub static EcsOnLoad: ecs_entity_t;
}
extern "C" {
    pub static EcsPostLoad: ecs_entity_t;
}
extern "C" {
    pub static EcsPreUpdate: ecs_entity_t;
}
extern "C" {
    pub static EcsOnUpdate: ecs_entity_t;
}
extern "C" {
    pub static EcsOnValidate: ecs_entity_t;
}
extern "C" {
    pub static EcsPostUpdate: ecs_entity_t;
}
extern "C" {
    pub static EcsPreStore: ecs_entity_t;
}
extern "C" {
    pub static EcsOnStore: ecs_entity_t;
}
extern "C" {
    pub static EcsPostFrame: ecs_entity_t;
}
extern "C" {
    pub static EcsPhase: ecs_entity_t;
}
extern "C" {
    #[doc = "Create a new world.\n A world manages all the ECS data and supporting infrastructure. Applications\n must have at least one world. Entities, component and system handles are\n local to a world and should not be shared between worlds.\n\n This operation creates a world with all builtin modules loaded.\n\n @return A new world"]
    pub fn ecs_init() -> *mut ecs_world_t;
}
extern "C" {
    #[doc = "Same as ecs_init, but with minimal set of modules loaded.\n\n @return A new tiny world"]
    pub fn ecs_mini() -> *mut ecs_world_t;
}
extern "C" {
    #[doc = "Create a new world with arguments.\n Same as ecs_init, but allows passing in command line arguments. These can be\n used to dynamically enable flecs features to an application. Currently these\n arguments are not used.\n\n @return A new world"]
    pub fn ecs_init_w_args(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ecs_world_t;
}
extern "C" {
    #[doc = "Delete a world.\n This operation deletes the world, and everything it contains.\n\n @param world The world to delete.\n @return Zero if successful, non-zero if failed."]
    pub fn ecs_fini(world: *mut ecs_world_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Returns whether the world is being deleted.\n\n @param world The world.\n @return True if being deleted, false if not."]
    pub fn ecs_is_fini(world: *const ecs_world_t) -> bool;
}
extern "C" {
    #[doc = "Register action to be executed when world is destroyed.\n Fini actions are typically used when a module needs to clean up before a\n world shuts down.\n\n @param world The world.\n @param action The function to execute.\n @param ctx Userdata to pass to the function"]
    pub fn ecs_atfini(
        world: *mut ecs_world_t,
        action: ecs_fini_action_t,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "Begin frame.\n When an application does not use ecs_progress to control the main loop, it\n can still use Flecs features such as FPS limiting and time measurements. This\n operation needs to be invoked whenever a new frame is about to get processed.\n\n Calls to ecs_frame_begin must always be followed by ecs_frame_end.\n\n The function accepts a delta_time parameter, which will get passed to\n systems. This value is also used to compute the amount of time the function\n needs to sleep to ensure it does not exceed the target_fps, when it is set.\n When 0 is provided for delta_time, the time will be measured.\n\n This function should only be ran from the main thread.\n\n @param world The world.\n @param delta_time Time elapsed since the last frame.\n @return The provided delta_time, or measured time if 0 was provided."]
    pub fn ecs_frame_begin(world: *mut ecs_world_t, delta_time: f32) -> f32;
}
extern "C" {
    #[doc = "End frame.\n This operation must be called at the end of the frame, and always after\n ecs_frame_begin.\n\n @param world The world."]
    pub fn ecs_frame_end(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = "Register action to be executed once after frame.\n Post frame actions are typically used for calling operations that cannot be\n invoked during iteration, such as changing the number of threads.\n\n @param world The world.\n @param action The function to execute.\n @param ctx Userdata to pass to the function"]
    pub fn ecs_run_post_frame(
        world: *mut ecs_world_t,
        action: ecs_fini_action_t,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "Signal exit\n This operation signals that the application should quit. It will cause\n ecs_progress to return false.\n\n @param world The world to quit."]
    pub fn ecs_quit(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = "Return whether a quit has been signaled.\n\n @param world The world."]
    pub fn ecs_should_quit(world: *const ecs_world_t) -> bool;
}
extern "C" {
    #[doc = "Measure frame time.\n Frame time measurements measure the total time passed in a single frame, and\n how much of that time was spent on systems and on merging.\n\n Frame time measurements add a small constant-time overhead to an application.\n When an application sets a target FPS, frame time measurements are enabled by\n default.\n\n @param world The world.\n @param enable Whether to enable or disable frame time measuring."]
    pub fn ecs_measure_frame_time(world: *mut ecs_world_t, enable: bool);
}
extern "C" {
    #[doc = "Measure system time.\n System time measurements measure the time spent in each system.\n\n System time measurements add overhead to every system invocation and\n therefore have a small but measurable impact on application performance.\n System time measurements must be enabled before obtaining system statistics.\n\n @param world The world.\n @param enable Whether to enable or disable system time measuring."]
    pub fn ecs_measure_system_time(world: *mut ecs_world_t, enable: bool);
}
extern "C" {
    #[doc = "Set target frames per second (FPS) for application.\n Setting the target FPS ensures that ecs_progress is not invoked faster than\n the specified FPS. When enabled, ecs_progress tracks the time passed since\n the last invocation, and sleeps the remaining time of the frame (if any).\n\n This feature ensures systems are ran at a consistent interval, as well as\n conserving CPU time by not running systems more often than required.\n\n Note that ecs_progress only sleeps if there is time left in the frame. Both\n time spent in flecs as time spent outside of flecs are taken into\n account.\n\n @param world The world.\n @param fps The target FPS."]
    pub fn ecs_set_target_fps(world: *mut ecs_world_t, fps: f32);
}
extern "C" {
    #[doc = "Begin readonly mode.\n Readonly mode guarantees that no mutations will occur on the world, which\n makes the world safe to access from multiple threads. While the world is in\n readonly mode, operations are deferred.\n\n Note that while similar to ecs_defer_begin, deferring only does not guarantee\n the world is not mutated. Operations that are not deferred (like creating a\n query) update data structures on the world and are allowed when deferring is\n enabled, but not when the world is in readonly mode.\n\n A call to ecs_readonly_begin must be followed up with ecs_readonly_end.\n\n The ecs_progress() function automatically enables readonly mode while systems\n are executed.\n\n When a world has more than one stage, the specific stage must be provided to\n mutating ECS operations. Failing to do so will throw a readonly assert. A\n world typically has more than one stage when using threads. An example:\n\n ecs_set_stage_count(world, 2);\n ecs_stage_t *stage = ecs_get_stage(world, 1);\n\n ecs_readonly_begin(world);\n ecs_add(world, e, Tag); // readonly assert\n ecs_add(stage, e, Tag); // OK\n\n @param world The world\n @return Whether world is in readonly mode."]
    pub fn ecs_readonly_begin(world: *mut ecs_world_t) -> bool;
}
extern "C" {
    #[doc = "End readonly mode.\n This operation ends readonly mode, and must be called after\n ecs_readonly_begin. Operations that were deferred while the world was in\n readonly mode will be flushed.\n\n @param world The world"]
    pub fn ecs_readonly_end(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = "Merge world or stage.\n When automatic merging is disabled, an application can call this\n operation on either an individual stage, or on the world which will merge\n all stages. This operation may only be called when staging is not enabled\n (either after progress() or after readonly_end()).\n\n This operation may be called on an already merged stage or world.\n\n @param world The world."]
    pub fn ecs_merge(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = "Defer operations until end of frame.\n When this operation is invoked while iterating, operations inbetween the\n defer_begin and defer_end operations are executed at the end of the frame.\n\n This operation is thread safe.\n\n @param world The world.\n @return true if world changed from non-deferred mode to deferred mode."]
    pub fn ecs_defer_begin(world: *mut ecs_world_t) -> bool;
}
extern "C" {
    #[doc = "Test if deferring is enabled for current stage.\n\n @param world The world.\n @return True if deferred, false if not."]
    pub fn ecs_is_deferred(world: *const ecs_world_t) -> bool;
}
extern "C" {
    #[doc = "End block of operations to defer.\n See defer_begin.\n\n This operation is thread safe.\n\n @param world The world.\n @return true if world changed from deferred mode to non-deferred mode."]
    pub fn ecs_defer_end(world: *mut ecs_world_t) -> bool;
}
extern "C" {
    #[doc = "Suspend deferring but do not flush queue.\n This operation can be used to do an undeferred operation while not flushing\n the operations in the queue.\n\n An application should invoke ecs_defer_resume before ecs_defer_end is called.\n The operation may only be called when deferring is enabled.\n\n @param world The world."]
    pub fn ecs_defer_suspend(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = "Resume deferring.\n See ecs_defer_suspend.\n\n @param world The world."]
    pub fn ecs_defer_resume(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = "Enable/disable automerging for world or stage.\n When automerging is enabled, staged data will automatically be merged with\n the world when staging ends. This happens at the end of progress(), at a\n sync point or when readonly_end() is called.\n\n Applications can exercise more control over when data from a stage is merged\n by disabling automerging. This requires an application to explicitly call\n merge() on the stage.\n\n When this function is invoked on the world, it sets all current stages to\n the provided value and sets the default for new stages. When this function is\n invoked on a stage, automerging is only set for that specific stage.\n\n @param world The world.\n @param automerge Whether to enable or disable automerging."]
    pub fn ecs_set_automerge(world: *mut ecs_world_t, automerge: bool);
}
extern "C" {
    #[doc = "Configure world to have N stages.\n This initializes N stages, which allows applications to defer operations to\n multiple isolated defer queues. This is typically used for applications with\n multiple threads, where each thread gets its own queue, and commands are\n merged when threads are synchronized.\n\n Note that the ecs_set_threads function already creates the appropriate\n number of stages. The set_stage_count() operation is useful for applications that\n want to manage their own stages and/or threads.\n\n @param world The world.\n @param stages The number of stages."]
    pub fn ecs_set_stage_count(world: *mut ecs_world_t, stages: i32);
}
extern "C" {
    #[doc = "Get number of configured stages.\n Return number of stages set by ecs_set_stage_count.\n\n @param world The world.\n @return The number of stages used for threading."]
    pub fn ecs_get_stage_count(world: *const ecs_world_t) -> i32;
}
extern "C" {
    #[doc = "Get current stage id.\n The stage id can be used by an application to learn about which stage it is\n using, which typically corresponds with the worker thread id.\n\n @param world The world.\n @return The stage id."]
    pub fn ecs_get_stage_id(world: *const ecs_world_t) -> i32;
}
extern "C" {
    #[doc = "Get stage-specific world pointer.\n Flecs threads can safely invoke the API as long as they have a private\n context to write to, also referred to as the stage. This function returns a\n pointer to a stage, disguised as a world pointer.\n\n Note that this function does not(!) create a new world. It simply wraps the\n existing world in a thread-specific context, which the API knows how to\n unwrap. The reason the stage is returned as an ecs_world_t is so that it\n can be passed transparently to the existing API functions, vs. having to\n create a dediated API for threading.\n\n @param world The world.\n @param stage_id The index of the stage to retrieve.\n @return A thread-specific pointer to the world."]
    pub fn ecs_get_stage(world: *const ecs_world_t, stage_id: i32) -> *mut ecs_world_t;
}
extern "C" {
    #[doc = "Test whether the current world is readonly.\n This function allows the code to test whether the currently used world\n is readonly or whether it allows for writing.\n\n @param world A pointer to a stage or the world.\n @return True if the world or stage is readonly."]
    pub fn ecs_stage_is_readonly(world: *const ecs_world_t) -> bool;
}
extern "C" {
    #[doc = "Create asynchronous stage.\n An asynchronous stage can be used to asynchronously queue operations for\n later merging with the world. An asynchronous stage is similar to a regular\n stage, except that it does not allow reading from the world.\n\n Asynchronous stages are never merged automatically, and must therefore be\n manually merged with the ecs_merge function. It is not necessary to call\n defer_begin or defer_end before and after enqueuing commands, as an\n asynchronous stage unconditionally defers operations.\n\n The application must ensure that no commands are added to the stage while the\n stage is being merged.\n\n An asynchronous stage must be cleaned up by ecs_async_stage_free.\n\n @param world The world.\n @return The stage."]
    pub fn ecs_async_stage_new(world: *mut ecs_world_t) -> *mut ecs_world_t;
}
extern "C" {
    #[doc = "Free asynchronous stage.\n The provided stage must be an asynchronous stage. If a non-asynchronous stage\n is provided, the operation will fail.\n\n @param stage The stage to free."]
    pub fn ecs_async_stage_free(stage: *mut ecs_world_t);
}
extern "C" {
    #[doc = "Test whether provided stage is asynchronous.\n\n @param stage The stage.\n @return True when the stage is asynchronous, false for a regular stage or\n         world."]
    pub fn ecs_stage_is_async(stage: *mut ecs_world_t) -> bool;
}
extern "C" {
    #[doc = "Set a world context.\n This operation allows an application to register custom data with a world\n that can be accessed anywhere where the application has the world.\n\n @param world The world.\n @param ctx A pointer to a user defined structure."]
    pub fn ecs_set_context(world: *mut ecs_world_t, ctx: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "Get the world context.\n This operation retrieves a previously set world context.\n\n @param world The world.\n @return The context set with ecs_set_context. If no context was set, the\n         function returns NULL."]
    pub fn ecs_get_context(world: *const ecs_world_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Get world info.\n\n @param world The world.\n @return Pointer to the world info. This pointer will remain valid for as long\n         as the world is valid."]
    pub fn ecs_get_world_info(world: *const ecs_world_t) -> *const ecs_world_info_t;
}
extern "C" {
    #[doc = "Dimension the world for a specified number of entities.\n This operation will preallocate memory in the world for the specified number\n of entities. Specifying a number lower than the current number of entities in\n the world will have no effect.\n\n @param world The world.\n @param entity_count The number of entities to preallocate."]
    pub fn ecs_dim(world: *mut ecs_world_t, entity_count: i32);
}
extern "C" {
    #[doc = "Set a range for issueing new entity ids.\n This function constrains the entity identifiers returned by ecs_new to the\n specified range. This operation can be used to ensure that multiple processes\n can run in the same simulation without requiring a central service that\n coordinates issueing identifiers.\n\n If id_end is set to 0, the range is infinite. If id_end is set to a non-zero\n value, it has to be larger than id_start. If id_end is set and ecs_new is\n invoked after an id is issued that is equal to id_end, the application will\n abort.\n\n @param world The world.\n @param id_start The start of the range.\n @param id_end The end of the range."]
    pub fn ecs_set_entity_range(
        world: *mut ecs_world_t,
        id_start: ecs_entity_t,
        id_end: ecs_entity_t,
    );
}
extern "C" {
    #[doc = "Enable/disable range limits.\n When an application is both a receiver of range-limited entities and a\n producer of range-limited entities, range checking needs to be temporarily\n disabled when inserting received entities. Range checking is disabled on a\n stage, so setting this value is thread safe.\n\n @param world The world.\n @param enable True if range checking should be enabled, false to disable.\n @return The previous value."]
    pub fn ecs_enable_range_check(world: *mut ecs_world_t, enable: bool) -> bool;
}
extern "C" {
    #[doc = "Get the largest issued entity id (not counting generation).\n\n @param world The world."]
    pub fn ecs_get_max_id(world: *const ecs_world_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Force aperiodic actions.\n The world may delay certain operations until they are necessary for the\n application to function correctly. This may cause observable side effects\n such as delayed triggering of events, which can be inconvenient when for\n example running a test suite.\n\n The flags parameter specifies which aperiodic actions to run. Specify 0 to\n run all actions. Supported flags start with 'EcsAperiodic'. Flags identify\n internal mechanisms and may change unannounced.\n\n @param world The world.\n @param flags The flags specifying which actions to run."]
    pub fn ecs_run_aperiodic(world: *mut ecs_world_t, flags: ecs_flags32_t);
}
extern "C" {
    #[doc = "Cleanup empty tables.\n This operation cleans up empty tables that meet certain conditions. Having\n large amounts of empty tables does not negatively impact performance of the\n ECS, but can take up considerable amounts of memory, especially in\n applications with many components, and many components per entity.\n\n The generation specifies the minimum number of times this operation has\n to be called before an empty table is cleaned up. If a table becomes non\n empty, the generation is reset.\n\n The operation allows for both a \"clear\" generation and a \"delete\"\n generation. When the clear generation is reached, the table's\n resources are freed (like component arrays) but the table itself is not\n deleted. When the delete generation is reached, the empty table is deleted.\n\n By specifying a non-zero id the cleanup logic can be limited to tables with\n a specific (component) id. The operation will only increase the generation\n count of matching tables.\n\n The min_id_count specifies a lower bound for the number of components a table\n should have. Often the more components a table has, the more specific it is\n and therefore less likely to be reused.\n\n The time budget specifies how long the operation should take at most.\n\n @param world The world.\n @param id Optional component filter for the tables to evaluate.\n @param clear_generation Free table data when generation > clear_generation.\n @param delete_generation Delete table when generation > delete_generation.\n @param min_id_count Minimum number of component ids the table should have.\n @param time_budget_seconds Amount of time operation is allowed to spend.\n @return Number of deleted tables."]
    pub fn ecs_delete_empty_tables(
        world: *mut ecs_world_t,
        id: ecs_id_t,
        clear_generation: u16,
        delete_generation: u16,
        min_id_count: i32,
        time_budget_seconds: f64,
    ) -> i32;
}
extern "C" {
    #[doc = "Get world from poly.\n\n @param poly A pointer to a poly object.\n @return The world."]
    pub fn ecs_get_world(poly: *const ecs_poly_t) -> *const ecs_world_t;
}
extern "C" {
    #[doc = "Get entity from poly.\n\n @param poly A pointer to a poly object.\n @return Entity associated with the poly object."]
    pub fn ecs_get_entity(poly: *const ecs_poly_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Test if pointer is of specified type.\n Usage:\n   ecs_poly_is(ptr, ecs_world_t)\n\n This operation only works for poly types.\n\n @param object The object to test.\n @param type The id of the type.\n @return True if the pointer is of the specified type."]
    pub fn _ecs_poly_is(object: *const ecs_poly_t, type_: i32) -> bool;
}
extern "C" {
    #[doc = "Make a pair id.\n This function is equivalent to using the ecs_pair macro, and is added for\n convenience to make it easier for non C/C++ bindings to work with pairs.\n\n @param first The first element of the pair of the pair.\n @param second The target of the pair."]
    pub fn ecs_make_pair(first: ecs_entity_t, second: ecs_entity_t) -> ecs_id_t;
}
extern "C" {
    #[doc = "Create new entity id.\n This operation returns an unused entity id. This operation is guaranteed to\n return an empty entity as it does not use values set by ecs_set_scope or\n ecs_set_with.\n\n @param world The world.\n @return The new entity id."]
    pub fn ecs_new_id(world: *mut ecs_world_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Create new low id.\n This operation returns a new low id. Entity ids start after the\n FLECS_HI_COMPONENT_ID constant. This reserves a range of low ids for things\n like components, and allows parts of the code to optimize operations.\n\n Note that FLECS_HI_COMPONENT_ID does not represent the maximum number of\n components that can be created, only the maximum number of components that\n can take advantage of these optimizations.\n\n This operation is guaranteed to return an empty entity as it does not use\n values set by ecs_set_scope or ecs_set_with.\n\n This operation does not recycle ids.\n\n @param world The world.\n @return The new component id."]
    pub fn ecs_new_low_id(world: *mut ecs_world_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Create new entity with (component) id.\n This operation creates a new entity with an optional (component) id. When 0\n is passed to the id paramter, no component is added to the new entity.\n\n @param world The world.\n @param id The component id to initialize the new entity with.\n @return The new entity."]
    pub fn ecs_new_w_id(world: *mut ecs_world_t, id: ecs_id_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Create new entity in table.\n This operation creates a new entity in the specified table.\n\n @param world The world.\n @param table The table to which to add the new entity.\n @return The new entity."]
    pub fn ecs_new_w_table(world: *mut ecs_world_t, table: *mut ecs_table_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Find or create an entity.\n This operation creates a new entity, or modifies an existing one. When a name\n is set in the ecs_entity_desc_t::name field and ecs_entity_desc_t::entity is\n not set, the operation will first attempt to find an existing entity by that\n name. If no entity with that name can be found, it will be created.\n\n If both a name and entity handle are provided, the operation will check if\n the entity name matches with the provided name. If the names do not match,\n the function will fail and return 0.\n\n If an id to a non-existing entity is provided, that entity id become alive.\n\n See the documentation of ecs_entity_desc_t for more details.\n\n @param world The world.\n @param desc Entity init parameters.\n @return A handle to the new or existing entity, or 0 if failed."]
    pub fn ecs_entity_init(world: *mut ecs_world_t, desc: *const ecs_entity_desc_t)
        -> ecs_entity_t;
}
extern "C" {
    #[doc = "Bulk create/populate new entities.\n This operation bulk inserts a list of new or predefined entities into a\n single table.\n\n The operation does not take ownership of component arrays provided by the\n application. Components that are non-trivially copyable will be moved into\n the storage.\n\n The operation will emit OnAdd events for each added id, and OnSet events for\n each component that has been set.\n\n If no entity ids are provided by the application, the returned array of ids\n points to an internal datastructure which changes when new entities are\n created/deleted.\n\n If as a result of the operation triggers are invoked that deletes\n entities and no entity ids were provided by the application, the returned\n array of identifiers may be incorrect. To avoid this problem, an application\n can first call ecs_bulk_init to create empty entities, copy the array to one\n that is owned by the application, and then use this array to populate the\n entities.\n\n @param world The world.\n @param desc Bulk creation parameters.\n @return Array with the list of entity ids created/populated."]
    pub fn ecs_bulk_init(
        world: *mut ecs_world_t,
        desc: *const ecs_bulk_desc_t,
    ) -> *const ecs_entity_t;
}
extern "C" {
    #[doc = "Create N new entities.\n This operation is the same as ecs_new_w_id, but creates N entities\n instead of one.\n\n @param world The world.\n @param id The component id to create the entities with.\n @param count The number of entities to create.\n @return The first entity id of the newly created entities."]
    pub fn ecs_bulk_new_w_id(
        world: *mut ecs_world_t,
        id: ecs_id_t,
        count: i32,
    ) -> *const ecs_entity_t;
}
extern "C" {
    #[doc = "Clone an entity\n This operation clones the components of one entity into another entity. If\n no destination entity is provided, a new entity will be created. Component\n values are not copied unless copy_value is true.\n\n @param world The world.\n @param dst The entity to copy the components to.\n @param src The entity to copy the components from.\n @param copy_value If true, the value of components will be copied to dst.\n @return The destination entity."]
    pub fn ecs_clone(
        world: *mut ecs_world_t,
        dst: ecs_entity_t,
        src: ecs_entity_t,
        copy_value: bool,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Delete an entity.\n This operation will delete an entity and all of its components. The entity id\n will be recycled. Repeatedly calling ecs_delete without ecs_new or\n ecs_new_w_id will cause a memory leak as it will cause\n the list with ids that can be recycled to grow unbounded.\n\n @param world The world.\n @param entity The entity."]
    pub fn ecs_delete(world: *mut ecs_world_t, entity: ecs_entity_t);
}
extern "C" {
    #[doc = "Delete all entities with the specified id.\n This will delete all entities (tables) that have the specified id. The id\n may be a wildcard and/or a pair.\n\n @param world The world.\n @param id The id."]
    pub fn ecs_delete_with(world: *mut ecs_world_t, id: ecs_id_t);
}
extern "C" {
    #[doc = "Add a (component) id to an entity.\n This operation adds a single (component) id to an entity. If the entity\n already has the id, this operation has no side effects.\n\n @param world The world.\n @param entity The entity.\n @param id The id to add."]
    pub fn ecs_add_id(world: *mut ecs_world_t, entity: ecs_entity_t, id: ecs_id_t);
}
extern "C" {
    #[doc = "Remove a (component) id from an entity.\n This operation removes a single (component) id to an entity. If the entity\n does not have the id, this operation has no side effects.\n\n @param world The world.\n @param entity The entity.\n @param id The id to remove."]
    pub fn ecs_remove_id(world: *mut ecs_world_t, entity: ecs_entity_t, id: ecs_id_t);
}
extern "C" {
    #[doc = "Add override for (component) id.\n Adding an override to an entity ensures that when the entity is instantiated\n (by adding an IsA relationship to it) the component with the override is\n copied to a component that is private to the instance. By default components\n reachable through an IsA relationship are shared.\n\n Adding an override does not add the component. If an override is added to an\n entity that does not have the component, it will still be added to the\n instance, but with an uninitialized value (unless the component has a ctor).\n When the entity does have the entity, the component of the instance will be\n initialized with the value of the component on the entity.\n\n This is the same as what happens when calling ecs_add_id for an id that is\n inherited (reachable through an IsA relationship).\n\n This operation is equivalent to doing:\n   ecs_add_id(world, entity, ECS_OVERRIDE | id);\n\n @param world The world.\n @param entity The entity.\n @param id The id to override."]
    pub fn ecs_override_id(world: *mut ecs_world_t, entity: ecs_entity_t, id: ecs_id_t);
}
extern "C" {
    #[doc = "Clear all components.\n This operation will clear all components from an entity but will not delete\n the entity itself. This effectively prevents the entity id from being\n recycled.\n\n @param world The world.\n @param entity The entity."]
    pub fn ecs_clear(world: *mut ecs_world_t, entity: ecs_entity_t);
}
extern "C" {
    #[doc = "Remove all instances of the specified id.\n This will remove the specified id from all entities (tables). Teh id may be\n a wildcard and/or a pair.\n\n @param world The world.\n @param id The id."]
    pub fn ecs_remove_all(world: *mut ecs_world_t, id: ecs_id_t);
}
extern "C" {
    #[doc = "Set current with id.\n New entities are automatically created with the specified id.\n\n @param world The world.\n @param id The id.\n @return The previous id."]
    pub fn ecs_set_with(world: *mut ecs_world_t, id: ecs_id_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Get current with id.\n Get the id set with ecs_set_with.\n\n @param world The world.\n @return The last id provided to ecs_set_with."]
    pub fn ecs_get_with(world: *const ecs_world_t) -> ecs_id_t;
}
extern "C" {
    #[doc = "Enable or disable entity.\n This operation enables or disables an entity by adding or removing the\n EcsDisabled tag. A disabled entity will not be matched with any systems,\n unless the system explicitly specifies the EcsDisabled tag.\n\n @param world The world.\n @param entity The entity to enable or disable.\n @param enabled true to enable the entity, false to disable."]
    pub fn ecs_enable(world: *mut ecs_world_t, entity: ecs_entity_t, enabled: bool);
}
extern "C" {
    #[doc = "Enable or disable component.\n Enabling or disabling a component does not add or remove a component from an\n entity, but prevents it from being matched with queries. This operation can\n be useful when a component must be temporarily disabled without destroying\n its value. It is also a more performant operation for when an application\n needs to add/remove components at high frequency, as enabling/disabling is\n cheaper than a regular add or remove.\n\n @param world The world.\n @param entity The entity.\n @param id The component.\n @param enable True to enable the component, false to disable."]
    pub fn ecs_enable_id(world: *mut ecs_world_t, entity: ecs_entity_t, id: ecs_id_t, enable: bool);
}
extern "C" {
    #[doc = "Test if component is enabled.\n Test whether a component is currently enabled or disabled. This operation\n will return true when the entity has the component and if it has not been\n disabled by ecs_enable_component.\n\n @param world The world.\n @param entity The entity.\n @param id The component.\n @return True if the component is enabled, otherwise false."]
    pub fn ecs_is_enabled_id(world: *const ecs_world_t, entity: ecs_entity_t, id: ecs_id_t)
        -> bool;
}
extern "C" {
    #[doc = "Get an immutable pointer to a component.\n This operation obtains a const pointer to the requested component. The\n operation accepts the component entity id.\n\n @param world The world.\n @param entity The entity.\n @param id The id of the component to get.\n @return The component pointer, NULL if the entity does not have the component."]
    pub fn ecs_get_id(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Create a component ref.\n A ref is a handle to an entity + component which caches a small amount of\n data to reduce overhead of repeatedly accessing the component. Use\n ecs_ref_get to get the component data.\n\n @param world The world.\n @param entity The entity.\n @param id The id of the component.\n @return The reference."]
    pub fn ecs_ref_init_id(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
    ) -> ecs_ref_t;
}
extern "C" {
    #[doc = "Get component from ref.\n Get component pointer from ref. The ref must be created with ecs_ref_init.\n\n @param world The world.\n @param ref The ref.\n @param id The component id.\n @return The component pointer, NULL if the entity does not have the component."]
    pub fn ecs_ref_get_id(
        world: *const ecs_world_t,
        ref_: *mut ecs_ref_t,
        id: ecs_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Update ref.\n Ensures contents of ref are up to date. Same as ecs_ref_get_id, but does not\n return pointer to component id.\n\n @param world The world.\n @param ref The ref."]
    pub fn ecs_ref_update(world: *const ecs_world_t, ref_: *mut ecs_ref_t);
}
extern "C" {
    #[doc = "Get a mutable pointer to a component.\n This operation returns a mutable pointer to a component. If the component did\n not yet exist, it will be added.\n\n If get_mut is called when the world is in deferred/readonly mode, the\n function will:\n - return a pointer to a temp storage if the component does not yet exist, or\n - return a pointer to the existing component if it exists\n\n @param world The world.\n @param entity The entity.\n @param id The entity id of the component to obtain.\n @return The component pointer."]
    pub fn ecs_get_mut_id(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Begin exclusive write access to entity.\n This operation provides safe exclusive access to the components of an entity\n without the overhead of deferring operations.\n\n When this operation is called simultaneously for the same entity more than\n once it will throw an assert. Note that for this to happen, asserts must be\n enabled. It is up to the application to ensure that access is exclusive, for\n example by using a read-write mutex.\n\n Exclusive access is enforced at the table level, so only one entity can be\n exclusively accessed per table. The exclusive access check is thread safe.\n\n This operation must be followed up with ecs_write_end.\n\n @param world The world.\n @param entity The entity.\n @return A record to the entity."]
    pub fn ecs_write_begin(world: *mut ecs_world_t, entity: ecs_entity_t) -> *mut ecs_record_t;
}
extern "C" {
    #[doc = "End exclusive write access to entity.\n This operation ends exclusive access, and must be called after\n ecs_write_begin.\n\n @param record Record to the entity."]
    pub fn ecs_write_end(record: *mut ecs_record_t);
}
extern "C" {
    #[doc = "Begin read access to entity.\n This operation provides safe read access to the components of an entity.\n Multiple simultaneous reads are allowed per entity.\n\n This operation ensures that code attempting to mutate the entity's table will\n throw an assert. Note that for this to happen, asserts must be enabled. It is\n up to the application to ensure that this does not happen, for example by\n using a read-write mutex.\n\n This operation does *not* provide the same guarantees as a read-write mutex,\n as it is possible to call ecs_read_begin after calling ecs_write_begin. It is\n up to application has to ensure that this does not happen.\n\n This operation must be followed up with ecs_read_end.\n\n @param world The world.\n @param entity The entity.\n @return A record to the entity."]
    pub fn ecs_read_begin(world: *mut ecs_world_t, entity: ecs_entity_t) -> *const ecs_record_t;
}
extern "C" {
    #[doc = "End read access to entity.\n This operation ends read access, and must be called after ecs_read_begin.\n\n @param record Record to the entity."]
    pub fn ecs_read_end(record: *const ecs_record_t);
}
extern "C" {
    #[doc = "Get entity corresponding with record.\n This operation only works for entities that are not empty.\n\n @param record The record for which to obtain the entity id."]
    pub fn ecs_record_get_entity(record: *const ecs_record_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Get component from entity record.\n This operation returns a pointer to a component for the entity\n associated with the provided record. For safe access to the component, obtain\n the record with ecs_read_begin or ecs_write_begin.\n\n Obtaining a component from a record is faster than obtaining it from the\n entity handle, as it reduces the number of lookups required.\n\n @param world The world.\n @param record Record to the entity.\n @param id The (component) id.\n @return Pointer to component, or NULL if entity does not have the component."]
    pub fn ecs_record_get_id(
        world: *mut ecs_world_t,
        record: *const ecs_record_t,
        id: ecs_id_t,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Same as ecs_record_get_id, but returns a mutable pointer.\n For safe access to the component, obtain the record with ecs_write_begin.\n\n @param world The world.\n @param record Record to the entity.\n @param id The (component) id.\n @return Pointer to component, or NULL if entity does not have the component."]
    pub fn ecs_record_get_mut_id(
        world: *mut ecs_world_t,
        record: *mut ecs_record_t,
        id: ecs_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Test if entity for record has component.\n\n @param world The world.\n @param record Record to the entity.\n @param id The (component) id."]
    pub fn ecs_record_has_id(
        world: *mut ecs_world_t,
        record: *const ecs_record_t,
        id: ecs_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "Emplace a component.\n Emplace is similar to get_mut except that the component constructor is not\n invoked for the returned pointer, allowing the component to be \"constructed\"\n directly in the storage.\n\n Emplace can only be used if the entity does not yet have the component. If\n the entity has the component, the operation will fail.\n\n @param world The world.\n @param entity The entity.\n @param id The component to obtain.\n @return The (uninitialized) component pointer."]
    pub fn ecs_emplace_id(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Signal that a component has been modified.\n This operation allows an application to signal to Flecs that a component has\n been modified. As a result, OnSet systems will be invoked.\n\n This operation is commonly used together with ecs_get_mut.\n\n @param world The world.\n @param entity The entity.\n @param id The id of the component that was modified."]
    pub fn ecs_modified_id(world: *mut ecs_world_t, entity: ecs_entity_t, id: ecs_id_t);
}
extern "C" {
    #[doc = "Set the value of a component.\n This operation allows an application to set the value of a component. The\n operation is equivalent to calling ecs_get_mut and ecs_modified.\n\n If the provided entity is 0, a new entity will be created.\n\n @param world The world.\n @param entity The entity.\n @param id The id of the component to set.\n @param size The size of the pointer to the value.\n @param ptr The pointer to the value.\n @return The entity. A new entity if no entity was provided."]
    pub fn ecs_set_id(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
        size: usize,
        ptr: *const ::std::os::raw::c_void,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Test whether an entity is valid.\n Entities that are valid can be used with API functions.\n\n An entity is valid if it is not 0 and if it is alive. If the provided id is\n a pair, the contents of the pair will be checked for validity.\n\n is_valid will return true for ids that don't exist (alive or not alive). This\n allows for using ids that have never been created by ecs_new or similar. In\n this the function differs from ecs_is_alive, which will return false for\n entities that do not yet exist.\n\n The operation will return false for an id that exists and is not alive, as\n using this id with an API operation would cause it to assert.\n\n @param world The world.\n @param e The entity.\n @return True if the entity is valid, false if the entity is not valid."]
    pub fn ecs_is_valid(world: *const ecs_world_t, e: ecs_entity_t) -> bool;
}
extern "C" {
    #[doc = "Test whether an entity is alive.\n An entity is alive when it has been returned by ecs_new (or similar) or if\n it is not empty (componentts have been explicitly added to the id).\n\n @param world The world.\n @param e The entity.\n @return True if the entity is alive, false if the entity is not alive."]
    pub fn ecs_is_alive(world: *const ecs_world_t, e: ecs_entity_t) -> bool;
}
extern "C" {
    #[doc = "Remove generation from entity id.\n\n @param e The entity id.\n @return The entity id without the generation count."]
    pub fn ecs_strip_generation(e: ecs_entity_t) -> ecs_id_t;
}
extern "C" {
    #[doc = "Override the generation of an entity.\n The generation count of an entity is increased each time an entity is deleted\n and is used to test whether an entity id is alive.\n\n This operation overrides the current generation of an entity with the\n specified generation, which can be useful if an entity is externally managed,\n like for external pools, savefiles or netcode.\n\n @param world The world.\n @param entity Entity for which to set the generation with the new generation."]
    pub fn ecs_set_entity_generation(world: *mut ecs_world_t, entity: ecs_entity_t);
}
extern "C" {
    #[doc = "Get alive identifier.\n In some cases an application may need to work with identifiers from which\n the generation has been stripped. A typical scenario in which this happens is\n when iterating relationships in an entity type.\n\n For example, when obtaining the parent id from a ChildOf relationship, the parent\n (second element of the pair) will have been stored in a 32 bit value, which\n cannot store the entity generation. This function can retrieve the identifier\n with the current generation for that id.\n\n If the provided identifier is not alive, the function will return 0.\n\n @param world The world.\n @param e The for which to obtain the current alive entity id.\n @return The alive entity id if there is one, or 0 if the id is not alive."]
    pub fn ecs_get_alive(world: *const ecs_world_t, e: ecs_entity_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Ensure id is alive.\n This operation ensures that the provided id is alive. This is useful in\n scenarios where an application has an existing id that has not been created\n with ecs_new (such as a global constant or an id from a remote application).\n\n When this operation is successful it guarantees that the provided id exists,\n is valid and is alive.\n\n Before this operation the id must either not be alive or have a generation\n that is equal to the passed in entity.\n\n If the provided id has a non-zero generation count and the id does not exist\n in the world, the id will be created with the specified generation.\n\n If the provided id is alive and has a generation count that does not match\n the provided id, the operation will fail.\n\n @param world The world.\n @param entity The entity id to make alive."]
    pub fn ecs_ensure(world: *mut ecs_world_t, entity: ecs_entity_t);
}
extern "C" {
    #[doc = "Same as ecs_ensure, but for (component) ids.\n An id can be an entity or pair, and can contain id flags. This operation\n ensures that the entity (or entities, for a pair) are alive.\n\n When this operation is successful it guarantees that the provided id can be\n used in operations that accept an id.\n\n Since entities in a pair do not encode their generation ids, this operation\n will not fail when an entity with non-zero generation count already exists in\n the world.\n\n This is different from ecs_ensure, which will fail if attempted with an id\n that has generation 0 and an entity with a non-zero generation is currently\n alive.\n\n @param world The world.\n @param id The id to make alive."]
    pub fn ecs_ensure_id(world: *mut ecs_world_t, id: ecs_id_t);
}
extern "C" {
    #[doc = "Test whether an entity exists.\n Similar as ecs_is_alive, but ignores entity generation count.\n\n @param world The world.\n @param entity The entity.\n @return True if the entity exists, false if the entity does not exist."]
    pub fn ecs_exists(world: *const ecs_world_t, entity: ecs_entity_t) -> bool;
}
extern "C" {
    #[doc = "Get the type of an entity.\n\n @param world The world.\n @param entity The entity.\n @return The type of the entity, NULL if the entity has no components."]
    pub fn ecs_get_type(world: *const ecs_world_t, entity: ecs_entity_t) -> *const ecs_type_t;
}
extern "C" {
    #[doc = "Get the table of an entity.\n\n @param world The world.\n @param entity The entity.\n @return The table of the entity, NULL if the entity has no components/tags."]
    pub fn ecs_get_table(world: *const ecs_world_t, entity: ecs_entity_t) -> *mut ecs_table_t;
}
extern "C" {
    #[doc = "Convert type to string.\n The result of this operation must be freed with ecs_os_free.\n\n @param world The world.\n @param type The type.\n @return The stringified type."]
    pub fn ecs_type_str(
        world: *const ecs_world_t,
        type_: *const ecs_type_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Convert table to string.\n Same as ecs_type_str(world, ecs_table_get_type(table)). The result of this\n operation must be freed with ecs_os_free.\n\n @param world The world.\n @param table The table.\n @return The stringified table type."]
    pub fn ecs_table_str(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Convert entity to string.\n Same as combining:\n - ecs_get_fullpath(world, entity)\n - ecs_type_str(world, ecs_get_type(world, entity))\n\n The result of this operation must be freed with ecs_os_free.\n\n @param world The world.\n @param entity The entity.\n @return The entity path with stringified type."]
    pub fn ecs_entity_str(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Test if an entity has an id.\n This operation returns true if the entity has or inherits the specified id.\n\n @param world The world.\n @param entity The entity.\n @param id The id to test for.\n @return True if the entity has the id, false if not."]
    pub fn ecs_has_id(world: *const ecs_world_t, entity: ecs_entity_t, id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = "Test if an entity owns an id.\n This operation returns true if the entity has the specified id. Other than\n ecs_has_id this operation will not return true if the id is inherited.\n\n @param world The world.\n @param entity The entity.\n @param id The id to test for.\n @return True if the entity has the id, false if not."]
    pub fn ecs_owns_id(world: *const ecs_world_t, entity: ecs_entity_t, id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = "Get the target of a relationship.\n This will return a target (second element of a pair) of the entity for the\n specified relationship. The index allows for iterating through the targets, if a\n single entity has multiple targets for the same relationship.\n\n If the index is larger than the total number of instances the entity has for\n the relationship, the operation will return 0.\n\n @param world The world.\n @param entity The entity.\n @param rel The relationship between the entity and the target.\n @param index The index of the relationship instance.\n @return The target for the relationship at the specified index."]
    pub fn ecs_get_target(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        rel: ecs_entity_t,
        index: i32,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Get parent (target of ChildOf relationship) for entity.\n This operation is the same as calling:\n   ecs_get_target(world, entity, EcsChildOf, 0);\n\n @param world The world.\n @param entity The entity.\n @return The parent of the entity, 0 if the entity has no parent."]
    pub fn ecs_get_parent(world: *const ecs_world_t, entity: ecs_entity_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Get the target of a relationship for a given id.\n This operation returns the first entity that has the provided id by following\n the specified relationship. If the entity itself has the id then entity will\n be returned. If the id cannot be found on the entity or by following the\n relationship, the operation will return 0.\n\n This operation can be used to lookup, for example, which prefab is providing\n a component by specifying the IsA relationship:\n\n   // Is Position provided by the entity or one of its base entities?\n   ecs_get_target_for_id(world, entity, EcsIsA, ecs_id(Position))\n\n @param world The world.\n @param entity The entity.\n @param rel The relationship to follow.\n @param id The id to lookup.\n @return The entity for which the target has been found."]
    pub fn ecs_get_target_for_id(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        rel: ecs_entity_t,
        id: ecs_id_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Return depth for entity in tree for relationship rel.\n Depth is determined by counting the number of targets encountered while\n traversing up the relationship tree for rel. Only acyclic relationships are\n supported.\n\n @param world The world.\n @param entity The entity.\n @param rel The relationship.\n @return The depth of the entity in the tree."]
    pub fn ecs_get_depth(world: *const ecs_world_t, entity: ecs_entity_t, rel: ecs_entity_t)
        -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_flatten_desc_t {
    #[doc = "When true, the flatten operation will not remove names from entities in\n the flattened tree. This may fail if entities from different subtrees\n have the same name."]
    pub keep_names: bool,
    #[doc = "When true, the flattened tree won't contain information about the\n original depth of the entities. This can reduce fragmentation, but may\n cause existing code, such as cascade queries, to no longer work."]
    pub lose_depth: bool,
}
extern "C" {
    #[doc = "Recursively flatten relationship for target entity (experimental).\n This operation combines entities in the subtree of the specified pair from\n different parents in the same table. This can reduce memory fragmentation\n and reduces the number of tables in the storage, which improves RAM\n utilization and various other operations, such as entity cleanup.\n\n The lifecycle of entities in a fixed subtree are bound to the specified\n parent. Entities in a fixed subtree cannot be deleted individually. Entities\n can also not change the target of the fixed relationship, which includes\n removing the relationship.\n\n Entities in a fixed subtree are still fragmented on subtree depth. This\n ensures that entities can still be iterated in breadth-first order with the\n cascade query modifier.\n\n The current implementation is limited to exclusive acyclic relationships, and\n does not allow for adding/removing to entities in flattened tables. An entity\n may only be flattened for a single relationship. Future iterations of the\n feature may remove these limitations.\n\n @param world The world.\n @param pair The relationship pair from which to start flattening.\n @param desc Options for flattening the tree."]
    pub fn ecs_flatten(world: *mut ecs_world_t, pair: ecs_id_t, desc: *const ecs_flatten_desc_t);
}
extern "C" {
    #[doc = "Count entities that have the specified id.\n Returns the number of entities that have the specified id.\n\n @param world The world.\n @param entity The id to search for.\n @return The number of entities that have the id."]
    pub fn ecs_count_id(world: *const ecs_world_t, entity: ecs_id_t) -> i32;
}
extern "C" {
    #[doc = "Get the name of an entity.\n This will return the name stored in (EcsIdentifier, EcsName).\n\n @param world The world.\n @param entity The entity.\n @return The type of the entity, NULL if the entity has no name."]
    pub fn ecs_get_name(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Get the symbol of an entity.\n This will return the symbol stored in (EcsIdentifier, EcsSymbol).\n\n @param world The world.\n @param entity The entity.\n @return The type of the entity, NULL if the entity has no name."]
    pub fn ecs_get_symbol(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Set the name of an entity.\n This will set or overwrite the name of an entity. If no entity is provided,\n a new entity will be created.\n\n The name is stored in (EcsIdentifier, EcsName).\n\n @param world The world.\n @param entity The entity.\n @param name The name.\n @return The provided entity, or a new entity if 0 was provided."]
    pub fn ecs_set_name(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        name: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Set the symbol of an entity.\n This will set or overwrite the symbol of an entity. If no entity is provided,\n a new entity will be created.\n\n The symbol is stored in (EcsIdentifier, EcsSymbol).\n\n @param world The world.\n @param entity The entity.\n @param symbol The symbol.\n @return The provided entity, or a new entity if 0 was provided."]
    pub fn ecs_set_symbol(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        symbol: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Set alias for entity.\n An entity can be looked up using its alias from the root scope without\n providing the fully qualified name if its parent. An entity can only have\n a single alias.\n\n The symbol is stored in (EcsIdentifier, EcsAlias).\n\n @param world The world.\n @param entity The entity.\n @param alias The alias."]
    pub fn ecs_set_alias(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        alias: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "Lookup an entity by name.\n Returns an entity that matches the specified name. Only looks for entities in\n the current scope (root if no scope is provided).\n\n @param world The world.\n @param name The entity name.\n @return The entity with the specified name, or 0 if no entity was found."]
    pub fn ecs_lookup(
        world: *const ecs_world_t,
        name: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Lookup a child entity by name.\n Returns an entity that matches the specified name. Only looks for entities in\n the provided parent. If no parent is provided, look in the current scope (\n root if no scope is provided).\n\n @param world The world.\n @param name The entity name.\n @return The entity with the specified name, or 0 if no entity was found."]
    pub fn ecs_lookup_child(
        world: *const ecs_world_t,
        parent: ecs_entity_t,
        name: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Lookup an entity from a path.\n Lookup an entity from a provided path, relative to the provided parent. The\n operation will use the provided separator to tokenize the path expression. If\n the provided path contains the prefix, the search will start from the root.\n\n If the entity is not found in the provided parent, the operation will\n continue to search in the parent of the parent, until the root is reached. If\n the entity is still not found, the lookup will search in the flecs.core\n scope. If the entity is not found there either, the function returns 0.\n\n @param world The world.\n @param parent The entity from which to resolve the path.\n @param path The path to resolve.\n @param sep The path separator.\n @param prefix The path prefix.\n @param recursive Recursively traverse up the tree until entity is found.\n @return The entity if found, else 0."]
    pub fn ecs_lookup_path_w_sep(
        world: *const ecs_world_t,
        parent: ecs_entity_t,
        path: *const ::std::os::raw::c_char,
        sep: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
        recursive: bool,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Lookup an entity by its symbol name.\n This looks up an entity by symbol stored in (EcsIdentifier, EcsSymbol). The\n operation does not take into account hierarchies.\n\n This operation can be useful to resolve, for example, a type by its C\n identifier, which does not include the Flecs namespacing."]
    pub fn ecs_lookup_symbol(
        world: *const ecs_world_t,
        symbol: *const ::std::os::raw::c_char,
        lookup_as_path: bool,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Get a path identifier for an entity.\n This operation creates a path that contains the names of the entities from\n the specified parent to the provided entity, separated by the provided\n separator. If no parent is provided the path will be relative to the root. If\n a prefix is provided, the path will be prefixed by the prefix.\n\n If the parent is equal to the provided child, the operation will return an\n empty string. If a nonzero component is provided, the path will be created by\n looking for parents with that component.\n\n The returned path should be freed by the application.\n\n @param world The world.\n @param parent The entity from which to create the path.\n @param child The entity to which to create the path.\n @param sep The separator to use between path elements.\n @param prefix The initial character to use for root elements.\n @return The relative entity path."]
    pub fn ecs_get_path_w_sep(
        world: *const ecs_world_t,
        parent: ecs_entity_t,
        child: ecs_entity_t,
        sep: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Write path identifier to buffer.\n Same as ecs_get_path_w_sep, but writes result to an ecs_strbuf_t.\n\n @param world The world.\n @param parent The entity from which to create the path.\n @param child The entity to which to create the path.\n @param sep The separator to use between path elements.\n @param prefix The initial character to use for root elements.\n @param buf The buffer to write to."]
    pub fn ecs_get_path_w_sep_buf(
        world: *const ecs_world_t,
        parent: ecs_entity_t,
        child: ecs_entity_t,
        sep: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
        buf: *mut ecs_strbuf_t,
    );
}
extern "C" {
    #[doc = "Find or create entity from path.\n This operation will find or create an entity from a path, and will create any\n intermediate entities if required. If the entity already exists, no entities\n will be created.\n\n If the path starts with the prefix, then the entity will be created from the\n root scope.\n\n @param world The world.\n @param parent The entity relative to which the entity should be created.\n @param path The path to create the entity for.\n @param sep The separator used in the path.\n @param prefix The prefix used in the path.\n @return The entity."]
    pub fn ecs_new_from_path_w_sep(
        world: *mut ecs_world_t,
        parent: ecs_entity_t,
        path: *const ::std::os::raw::c_char,
        sep: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Add specified path to entity.\n This operation is similar to ecs_new_from_path, but will instead add the path\n to an existing entity.\n\n If an entity already exists for the path, it will be returned instead.\n\n @param world The world.\n @param entity The entity to which to add the path.\n @param parent The entity relative to which the entity should be created.\n @param path The path to create the entity for.\n @param sep The separator used in the path.\n @param prefix The prefix used in the path.\n @return The entity."]
    pub fn ecs_add_path_w_sep(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        parent: ecs_entity_t,
        path: *const ::std::os::raw::c_char,
        sep: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Set the current scope.\n This operation sets the scope of the current stage to the provided entity.\n As a result new entities will be created in this scope, and lookups will be\n relative to the provided scope.\n\n It is considered good practice to restore the scope to the old value.\n\n @param world The world.\n @param scope The entity to use as scope.\n @return The previous scope."]
    pub fn ecs_set_scope(world: *mut ecs_world_t, scope: ecs_entity_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Get the current scope.\n Get the scope set by ecs_set_scope. If no scope is set, this operation will\n return 0.\n\n @param world The world.\n @return The current scope."]
    pub fn ecs_get_scope(world: *const ecs_world_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Set a name prefix for newly created entities.\n This is a utility that lets C modules use prefixed names for C types and\n C functions, while using names for the entity names that do not have the\n prefix. The name prefix is currently only used by ECS_COMPONENT.\n\n @param world The world.\n @param prefix The name prefix to use.\n @return The previous prefix."]
    pub fn ecs_set_name_prefix(
        world: *mut ecs_world_t,
        prefix: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Set search path for lookup operations.\n This operation accepts an array of entity ids that will be used as search\n scopes by lookup operations. The operation returns the current search path.\n It is good practice to restore the old search path.\n\n The search path will be evaluated starting from the last element.\n\n The default search path includes flecs.core. When a custom search path is\n provided it overwrites the existing search path. Operations that rely on\n looking up names from flecs.core without providing the namespace may fail if\n the custom search path does not include flecs.core (EcsFlecsCore).\n\n The search path array is not copied into managed memory. The application must\n ensure that the provided array is valid for as long as it is used as the\n search path.\n\n The provided array must be terminated with a 0 element. This enables an\n application to push/pop elements to an existing array without invoking the\n ecs_set_lookup_path operation again.\n\n @param world The world.\n @param lookup_path 0-terminated array with entity ids for the lookup path.\n @return Current lookup path array."]
    pub fn ecs_set_lookup_path(
        world: *mut ecs_world_t,
        lookup_path: *const ecs_entity_t,
    ) -> *mut ecs_entity_t;
}
extern "C" {
    #[doc = "Get current lookup path.\n Returns value set by ecs_set_lookup_path.\n\n @param world The world.\n @return The current lookup path."]
    pub fn ecs_get_lookup_path(world: *const ecs_world_t) -> *mut ecs_entity_t;
}
extern "C" {
    #[doc = "Find or create a component.\n This operation creates a new component, or finds an existing one. The find or\n create behavior is the same as ecs_entity_init.\n\n When an existing component is found, the size and alignment are verified with\n the provided values. If the values do not match, the operation will fail.\n\n See the documentation of ecs_component_desc_t for more details.\n\n @param world The world.\n @param desc Component init parameters.\n @return A handle to the new or existing component, or 0 if failed."]
    pub fn ecs_component_init(
        world: *mut ecs_world_t,
        desc: *const ecs_component_desc_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Register hooks for component.\n Hooks allow for the execution of user code when components are constructed,\n copied, moved, destructed, added, removed or set. Hooks can be assigned as\n as long as a component has not yet been used (added to an entity).\n\n The hooks that are currently set can be accessed with ecs_get_type_info.\n\n @param world The world.\n @param id The component id for which to register the actions\n @param hooks Type that contains the component actions."]
    pub fn ecs_set_hooks_id(
        world: *mut ecs_world_t,
        id: ecs_entity_t,
        hooks: *const ecs_type_hooks_t,
    );
}
extern "C" {
    #[doc = "Get hooks for component.\n\n @param world The world.\n @param id The component id for which to retrieve the hooks.\n @return The hooks for the component, or NULL if not registered."]
    pub fn ecs_get_hooks_id(world: *mut ecs_world_t, id: ecs_entity_t) -> *const ecs_type_hooks_t;
}
extern "C" {
    #[doc = "Returns whether specified id a tag.\n This operation returns whether the specified type is a tag (a component\n without data/size).\n\n An id is a tag when:\n - it is an entity without the EcsComponent component\n - it has an EcsComponent with size member set to 0\n - it is a pair where both elements are a tag\n - it is a pair where the first element has the EcsTag tag\n\n @param world The world.\n @param id The id.\n @return Whether the provided id is a tag."]
    pub fn ecs_id_is_tag(world: *const ecs_world_t, id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = "Return whether represents a union.\n This operation returns whether the specified type represents a union. Only\n pair ids can be unions.\n\n An id represents a union when:\n - The first element of the pair is EcsUnion/flecs::Union\n - The first element of the pair has EcsUnion/flecs::Union\n\n @param world The world.\n @param id The id.\n @return Whether the provided id represents a union."]
    pub fn ecs_id_is_union(world: *const ecs_world_t, id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = "Returns whether specified id is in use.\n This operation returns whether an id is in use in the world. An id is in use\n if it has been added to one or more tables.\n\n @param world The world.\n @param id The id.\n @return Whether the id is in use."]
    pub fn ecs_id_in_use(world: *const ecs_world_t, id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = "Get the type for an id.\n This function returnsthe type information for an id. The specified id can be\n any valid id. For the rules on how type information is determined based on\n id, see ecs_get_typeid.\n\n @param world The world.\n @param id The id.\n @return The type information of the id."]
    pub fn ecs_get_type_info(world: *const ecs_world_t, id: ecs_id_t) -> *const ecs_type_info_t;
}
extern "C" {
    #[doc = "Get the type for an id.\n This operation returns the component id for an id, if the id is associated\n with a type. For a regular component with a non-zero size (an entity with the\n EcsComponent component) the operation will return the entity itself.\n\n For an entity that does not have the EcsComponent component, or with an\n EcsComponent value with size 0, the operation will return 0.\n\n For a pair id the operation will return the type associated with the pair, by\n applying the following rules in order:\n - The first pair element is returned if it is a component\n - 0 is returned if the relationship entity has the Tag property\n - The second pair element is returned if it is a component\n - 0 is returned.\n\n @param world The world.\n @param id The id.\n @return The type id of the id."]
    pub fn ecs_get_typeid(world: *const ecs_world_t, id: ecs_id_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Utility to match an id with a pattern.\n This operation returns true if the provided pattern matches the provided\n id. The pattern may contain a wildcard (or wildcards, when a pair).\n\n @param id The id.\n @param pattern The pattern to compare with."]
    pub fn ecs_id_match(id: ecs_id_t, pattern: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = "Utility to check if id is a pair.\n\n @param id The id.\n @return True if id is a pair."]
    pub fn ecs_id_is_pair(id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = "Utility to check if id is a wildcard.\n\n @param id The id.\n @return True if id is a wildcard or a pair containing a wildcard."]
    pub fn ecs_id_is_wildcard(id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = "Utility to check if id is valid.\n A valid id is an id that can be added to an entity. Invalid ids are:\n - ids that contain wildcards\n - ids that contain invalid entities\n - ids that are 0 or contain 0 entities\n\n Note that the same rules apply to removing from an entity, with the exception\n of wildcards.\n\n @param world The world.\n @param id The id.\n @return True if the id is valid."]
    pub fn ecs_id_is_valid(world: *const ecs_world_t, id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = "Get flags associated with id.\n This operation returns the internal flags (see api_flags.h) that are\n associated with the provided id.\n\n @param world The world.\n @param id The id.\n @return Flags associated with the id, or 0 if the id is not in use."]
    pub fn ecs_id_get_flags(world: *const ecs_world_t, id: ecs_id_t) -> ecs_flags32_t;
}
extern "C" {
    #[doc = "Convert id flag to string.\n This operation converts a id flag to a string.\n\n @param id_flags The id flag.\n @return The id flag string, or NULL if no valid id is provided."]
    pub fn ecs_id_flag_str(id_flags: ecs_id_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Convert id to string.\n This operation interprets the structure of an id and converts it to a string.\n\n @param world The world.\n @param id The id to convert to a string.\n @return The id converted to a string."]
    pub fn ecs_id_str(world: *const ecs_world_t, id: ecs_id_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Write id string to buffer.\n Same as ecs_id_str but writes result to ecs_strbuf_t.\n\n @param world The world.\n @param id The id to convert to a string.\n @param buf The buffer to write to."]
    pub fn ecs_id_str_buf(world: *const ecs_world_t, id: ecs_id_t, buf: *mut ecs_strbuf_t);
}
extern "C" {
    #[doc = "Iterator for a single (component) id.\n A term iterator returns all entities (tables) that match a single (component)\n id. The search for the matching set of entities (tables) is performed in\n constant time.\n\n @param world The world.\n @param term The term.\n @return The iterator."]
    pub fn ecs_term_iter(world: *const ecs_world_t, term: *mut ecs_term_t) -> ecs_iter_t;
}
extern "C" {
    #[doc = "Return a chained term iterator.\n A chained iterator applies a filter to the results of the input iterator. The\n resulting iterator must be iterated with ecs_term_next.\n\n @param it The input iterator\n @param term The term filter to apply to the iterator.\n @return The chained iterator."]
    pub fn ecs_term_chain_iter(it: *const ecs_iter_t, term: *mut ecs_term_t) -> ecs_iter_t;
}
extern "C" {
    #[doc = "Progress a term iterator.\n This operation progresses the term iterator to the next table. The\n iterator must have been initialized with `ecs_term_iter`. This operation\n must be invoked at least once before interpreting the contents of the\n iterator.\n\n @param it The iterator.\n @returns True if more data is available, false if not."]
    pub fn ecs_term_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = "Iterator for a parent's children.\n This operation is equivalent to a term iterator for (ChildOf, parent).\n Iterate the result with ecs_children_next.\n\n @param world The world.\n @param parent The parent for which to iterate the children.\n @return The iterator."]
    pub fn ecs_children(world: *const ecs_world_t, parent: ecs_entity_t) -> ecs_iter_t;
}
extern "C" {
    #[doc = "Progress a children iterator.\n Equivalent to ecs_term_next.\n\n @param it The iterator.\n @returns True if more data is available, false if not."]
    pub fn ecs_children_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = "Test whether term id is set.\n\n @param id The term id.\n @return True when set, false when not set."]
    pub fn ecs_term_id_is_set(id: *const ecs_term_id_t) -> bool;
}
extern "C" {
    #[doc = "Test whether a term is set.\n This operation can be used to test whether a term has been initialized with\n values or whether it is empty.\n\n An application generally does not need to invoke this operation. It is useful\n when initializing a 0-initialized array of terms (like in ecs_term_desc_t) as\n this operation can be used to find the last initialized element.\n\n @param term The term.\n @return True when set, false when not set."]
    pub fn ecs_term_is_initialized(term: *const ecs_term_t) -> bool;
}
extern "C" {
    pub fn ecs_term_match_this(term: *const ecs_term_t) -> bool;
}
extern "C" {
    pub fn ecs_term_match_0(term: *const ecs_term_t) -> bool;
}
extern "C" {
    #[doc = "Finalize term.\n Ensure that all fields of a term are consistent and filled out. This\n operation should be invoked before using and after assigning members to, or\n parsing a term. When a term contains unresolved identifiers, this operation\n will resolve and assign the identifiers. If the term contains any identifiers\n that cannot be resolved, the operation will fail.\n\n An application generally does not need to invoke this operation as the APIs\n that use terms (such as filters, queries and triggers) will finalize terms\n when they are created.\n\n The name and expr parameters are optional, and only used for giving more\n descriptive error messages.\n\n @param world The world.\n @param term The term to finalize.\n @return Zero if success, nonzero if an error occurred."]
    pub fn ecs_term_finalize(
        world: *const ecs_world_t,
        term: *mut ecs_term_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Copy resources of a term to another term.\n This operation copies one term to another term. If the source term contains\n allocated resources (such as identifiers), they will be duplicated so that\n no memory is shared between the terms.\n\n @param src The term to copy from.\n @return The destination term."]
    pub fn ecs_term_copy(src: *const ecs_term_t) -> ecs_term_t;
}
extern "C" {
    #[doc = "Move resources of a term to another term.\n Same as copy, but moves resources from src, if src->move is set to true. If\n src->move is not set to true, this operation will do a copy.\n\n The conditional move reduces redundant allocations in scenarios where a list\n of terms is partially created with allocated resources.\n\n @param src The term to move from.\n @return The destination term."]
    pub fn ecs_term_move(src: *mut ecs_term_t) -> ecs_term_t;
}
extern "C" {
    #[doc = "Free resources of term.\n This operation frees all resources (such as identifiers) of a term. The term\n itself is not freed.\n\n @param term The term to free."]
    pub fn ecs_term_fini(term: *mut ecs_term_t);
}
extern "C" {
    #[doc = "Initialize filter\n A filter is a lightweight object that can be used to query for entities in\n a world. Filters, as opposed to queries, do not cache results. They are\n therefore slower to iterate, but are faster to create.\n\n When a filter is copied by value, make sure to use \"ecs_filter_move\" to\n ensure that the terms pointer still points to the inline array:\n\n   ecs_filter_move(&dst_filter, &src_filter)\n\n Alternatively, the ecs_filter_move function can be called with both arguments\n set to the same filter, to ensure the pointer is valid:\n\n   ecs_filter_move(&f, &f)\n\n It is possible to create a filter without allocating any memory, by setting\n the .storage member in ecs_filter_desc_t. See the documentation for the\n member for more details.\n\n @param world The world.\n @param desc Properties for the filter to create.\n @return The filter if successful, NULL if not successful."]
    pub fn ecs_filter_init(
        world: *mut ecs_world_t,
        desc: *const ecs_filter_desc_t,
    ) -> *mut ecs_filter_t;
}
extern "C" {
    #[doc = "Deinitialize filter.\n Free resources associated with filter.\n\n @param filter The filter to deinitialize."]
    pub fn ecs_filter_fini(filter: *mut ecs_filter_t);
}
extern "C" {
    #[doc = "Finalize filter.\n When manually assigning an array of terms to the filter struct (so not when\n using ecs_filter_init), this operation should be used to ensure that all\n terms are assigned properly and all (derived) fields have been set.\n\n When ecs_filter_init is used to create the filter, this function should not\n be called. The purpose of this operation is to support creation of filters\n without allocating memory.\n\n @param filter The filter to finalize.\n @return Zero if filter is valid, non-zero if it contains errors.\n @"]
    pub fn ecs_filter_finalize(
        world: *const ecs_world_t,
        filter: *mut ecs_filter_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Find index for This variable.\n This operation looks up the index of the This variable. This index can\n be used in operations like ecs_iter_set_var and ecs_iter_get_var.\n\n The operation will return -1 if the variable was not found. This happens when\n a filter only has terms that are not matched on the This variable, like a\n filter that exclusively matches singleton components.\n\n @param filter The rule.\n @return The index of the This variable."]
    pub fn ecs_filter_find_this_var(filter: *const ecs_filter_t) -> i32;
}
extern "C" {
    #[doc = "Convert ter, to string expression.\n Convert term to a string expression. The resulting expression is equivalent\n to the same term, with the exception of And & Or operators."]
    pub fn ecs_term_str(
        world: *const ecs_world_t,
        term: *const ecs_term_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Convert filter to string expression.\n Convert filter terms to a string expression. The resulting expression can be\n parsed to create the same filter."]
    pub fn ecs_filter_str(
        world: *const ecs_world_t,
        filter: *const ecs_filter_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Return a filter iterator.\n A filter iterator lets an application iterate over entities that match the\n specified filter.\n\n @param world The world.\n @param filter The filter.\n @return An iterator that can be used with ecs_filter_next."]
    pub fn ecs_filter_iter(world: *const ecs_world_t, filter: *const ecs_filter_t) -> ecs_iter_t;
}
extern "C" {
    #[doc = "Return a chained filter iterator.\n A chained iterator applies a filter to the results of the input iterator. The\n resulting iterator must be iterated with ecs_filter_next.\n\n @param it The input iterator\n @param filter The filter to apply to the iterator.\n @return The chained iterator."]
    pub fn ecs_filter_chain_iter(it: *const ecs_iter_t, filter: *const ecs_filter_t) -> ecs_iter_t;
}
extern "C" {
    #[doc = "Get pivot term for filter.\n The pivot term is the term that matches the smallest set of tables, and is\n a good default starting point for a search.\n\n The following conditions must be met for a term to be considered as pivot:\n - It must have a This subject\n - It must have the And operator\n\n When a filter does not have any terms that match those conditions, it will\n return -1.\n\n If one or more terms in the filter have no matching tables the filter won't\n yield any results. In this case the operation will return -2 which gives a\n search function the option to early out.\n\n @param world The world.\n @param filter The filter.\n @return Index of the pivot term (use with filter->terms)"]
    pub fn ecs_filter_pivot_term(world: *const ecs_world_t, filter: *const ecs_filter_t) -> i32;
}
extern "C" {
    #[doc = "Iterate tables matched by filter.\n This operation progresses the filter iterator to the next table. The\n iterator must have been initialized with `ecs_filter_iter`. This operation\n must be invoked at least once before interpreting the contents of the\n iterator.\n\n @param it The iterator\n @return True if more data is available, false if not."]
    pub fn ecs_filter_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = "Same as ecs_filter_next, but always instanced.\n See instanced property of ecs_filter_desc_t."]
    pub fn ecs_filter_next_instanced(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = "Move resources of one filter to another."]
    pub fn ecs_filter_move(dst: *mut ecs_filter_t, src: *mut ecs_filter_t);
}
extern "C" {
    #[doc = "Copy resources of one filter to another."]
    pub fn ecs_filter_copy(dst: *mut ecs_filter_t, src: *const ecs_filter_t);
}
extern "C" {
    #[doc = "Create a query.\n This operation creates a query. Queries are used to iterate over entities\n that match a filter and are the fastest way to find and iterate over entities\n and their components.\n\n Queries should be created once, and reused multiple times. While iterating a\n query is a cheap operation, creating and deleting a query is expensive. The\n reason for this is that queries are \"prematched\", which means that a query\n stores state about which entities (or rather, tables) match with the query.\n Building up this state happens during query creation.\n\n Once a query is created, matching only happens when new tables are created.\n In most applications this is an infrequent process, since it only occurs when\n a new combination of components is introduced. While matching is expensive,\n it is importent to note that matching does not happen on a per-entity basis,\n but on a per-table basis. This means that the average time spent on matching\n per frame should rapidly approach zero over the lifetime of an application.\n\n A query provides direct access to the component arrays. When an application\n creates/deletes entities or adds/removes components, these arrays can shift\n component values around, or may grow in size. This can cause unexpected or\n undefined behavior to occur if these operations are performed while\n iterating. To prevent this from happening an application should either not\n perform these operations while iterating, or use deferred operations (see\n ecs_defer_begin and ecs_defer_end).\n\n Queries can be created and deleted dynamically. If a query was not deleted\n (using ecs_query_fini) before the world is deleted, it will be deleted\n automatically.\n\n @param world The world.\n @param desc A structure describing the query properties.\n @return The new query."]
    pub fn ecs_query_init(
        world: *mut ecs_world_t,
        desc: *const ecs_query_desc_t,
    ) -> *mut ecs_query_t;
}
extern "C" {
    #[doc = "Destroy a query.\n This operation destroys a query and its resources. If the query is used as\n the parent of subqueries, those subqueries will be orphaned and must be\n deinitialized as well.\n\n @param query The query."]
    pub fn ecs_query_fini(query: *mut ecs_query_t);
}
extern "C" {
    #[doc = "Get filter from a query.\n This operation obtains a pointer to the internally constructed filter\n of the query and can be used to introspect the query terms.\n\n @param query The query."]
    pub fn ecs_query_get_filter(query: *const ecs_query_t) -> *const ecs_filter_t;
}
extern "C" {
    #[doc = "Return a query iterator.\n A query iterator lets an application iterate over entities that match the\n specified query. If a sorting function is specified, the query will check\n whether a resort is required upon creating the iterator.\n\n Creating a query iterator is a cheap operation that does not allocate any\n resources. An application does not need to deinitialize or free a query\n iterator before it goes out of scope.\n\n To iterate the iterator, an application should use ecs_query_next to progress\n the iterator and test if it has data.\n\n Query iteration requires an outer and an inner loop. The outer loop uses\n ecs_query_next to test if new tables are available. The inner loop iterates\n the entities in the table, and is usually a for loop that uses iter.count to\n loop through the entities and component arrays.\n\n The two loops are necessary because of how data is stored internally.\n Entities are grouped by the components they have, in tables. A single query\n can (and often does) match with multiple tables. Because each table has its\n own set of arrays, an application has to reobtain pointers to those arrays\n for each matching table.\n\n @param world The world or stage, when iterating in readonly mode.\n @param query The query to iterate.\n @return The query iterator."]
    pub fn ecs_query_iter(world: *const ecs_world_t, query: *mut ecs_query_t) -> ecs_iter_t;
}
extern "C" {
    #[doc = "Progress the query iterator.\n This operation progresses the query iterator to the next table. The\n iterator must have been initialized with `ecs_query_iter`. This operation\n must be invoked at least once before interpreting the contents of the\n iterator.\n\n @param iter The iterator.\n @returns True if more data is available, false if not."]
    pub fn ecs_query_next(iter: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = "Same as ecs_query_next, but always instanced.\n See \"instanced\" property of ecs_filter_desc_t."]
    pub fn ecs_query_next_instanced(iter: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = "Fast alternative to ecs_query_next that only returns matched tables.\n This operation only populates the ecs_iter_t::table field. To access the\n matched components, call ecs_query_populate.\n\n If this operation is used with a query that has inout/out terms, those terms\n will not be marked dirty unless ecs_query_populate is called.\n\n @param iter The iterator.\n @returns True if more data is available, false if not."]
    pub fn ecs_query_next_table(iter: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = "Populate iterator fields.\n This operation can be combined with ecs_query_next_table to populate the\n iterator fields for the current table.\n\n Populating fields conditionally can save time when a query uses change\n detection, and only needs iterator data when the table has changed. When this\n operation is called, inout/out terms will be marked dirty.\n\n In cases where inout/out terms are conditionally written and no changes\n were made after calling ecs_query_populate, the ecs_query_skip function can\n be called to prevent the matched table components from being marked dirty.\n\n This operation does should not be used with queries that match disabled\n components, union relationships, or with queries that use order_by.\n\n When the when_changed argument is set to true, the iterator data will only\n populate when the data has changed, using query change detection.\n\n @param iter The iterator.\n @param when_changed Only populate data when result has changed."]
    pub fn ecs_query_populate(iter: *mut ecs_iter_t, when_changed: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Returns whether the query data changed since the last iteration.\n The operation will return true after:\n - new entities have been matched with\n - new tables have been matched/unmatched with\n - matched entities were deleted\n - matched components were changed\n\n The operation will not return true after a write-only (EcsOut) or filter\n (EcsInOutNone) term has changed, when a term is not matched with the\n current table (This subject) or for tag terms.\n\n The changed state of a table is reset after it is iterated. If a iterator was\n not iterated until completion, tables may still be marked as changed.\n\n If no iterator is provided the operation will return the changed state of the\n all matched tables of the query.\n\n If an iterator is provided, the operation will return the changed state of\n the currently returned iterator result. The following preconditions must be\n met before using an iterator with change detection:\n\n - The iterator is a query iterator (created with ecs_query_iter)\n - The iterator must be valid (ecs_query_next must have returned true)\n - The iterator must be instanced\n\n @param query The query (optional if 'it' is provided).\n @param it The iterator result to test (optional if 'query' is provided).\n @return true if entities changed, otherwise false."]
    pub fn ecs_query_changed(query: *mut ecs_query_t, it: *const ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = "Skip a table while iterating.\n This operation lets the query iterator know that a table was skipped while\n iterating. A skipped table will not reset its changed state, and the query\n will not update the dirty flags of the table for its out columns.\n\n Only valid iterators must be provided (next has to be called at least once &\n return true) and the iterator must be a query iterator.\n\n @param it The iterator result to skip."]
    pub fn ecs_query_skip(it: *mut ecs_iter_t);
}
extern "C" {
    #[doc = "Set group to iterate for query iterator.\n This operation limits the results returned by the query to only the selected\n group id. The query must have a group_by function, and the iterator must\n be a query iterator.\n\n Groups are sets of tables that are stored together in the query cache based\n on a group id, which is calculated per table by the group_by function. To\n iterate a group, an iterator only needs to know the first and last cache node\n for that group, which can both be found in a fast O(1) operation.\n\n As a result, group iteration is one of the most efficient mechanisms to\n filter out large numbers of entities, even if those entities are distributed\n across many tables. This makes it a good fit for things like dividing up\n a world into cells, and only iterating cells close to a player.\n\n The group to iterate must be set before the first call to ecs_query_next. No\n operations that can add/remove components should be invoked between calling\n ecs_query_set_group and ecs_query_next.\n\n @param it The query iterator.\n @param group_id The group to iterate."]
    pub fn ecs_query_set_group(it: *mut ecs_iter_t, group_id: u64);
}
extern "C" {
    #[doc = "Get context of query group.\n This operation returns the context of a query group as returned by the\n on_group_create callback.\n\n @param query The query.\n @param group_id The group for which to obtain the context.\n @return The group context, NULL if the group doesn't exist."]
    pub fn ecs_query_get_group_ctx(
        query: *const ecs_query_t,
        group_id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Get information about query group.\n This operation returns information about a query group, including the group\n context returned by the on_group_create callback.\n\n @param query The query.\n @param group_id The group for which to obtain the group info.\n @return The group info, NULL if the group doesn't exist."]
    pub fn ecs_query_get_group_info(
        query: *const ecs_query_t,
        group_id: u64,
    ) -> *const ecs_query_group_info_t;
}
extern "C" {
    #[doc = "Returns whether query is orphaned.\n When the parent query of a subquery is deleted, it is left in an orphaned\n state. The only valid operation on an orphaned query is deleting it. Only\n subqueries can be orphaned.\n\n @param query The query.\n @return true if query is orphaned, otherwise false."]
    pub fn ecs_query_orphaned(query: *const ecs_query_t) -> bool;
}
extern "C" {
    #[doc = "Convert query to string.\n\n @param query The query.\n @return The query string."]
    pub fn ecs_query_str(query: *const ecs_query_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Returns number of tables query matched with.\n\n @param query The query.\n @return The number of matched tables."]
    pub fn ecs_query_table_count(query: *const ecs_query_t) -> i32;
}
extern "C" {
    #[doc = "Returns number of empty tables query matched with.\n\n @param query The query.\n @return The number of matched empty tables."]
    pub fn ecs_query_empty_table_count(query: *const ecs_query_t) -> i32;
}
extern "C" {
    #[doc = "Returns number of entities query matched with.\n This operation iterates all non-empty tables in the query cache to find the\n total number of entities.\n\n @param query The query.\n @return The number of matched entities."]
    pub fn ecs_query_entity_count(query: *const ecs_query_t) -> i32;
}
#[doc = "@defgroup observer Observers\n @brief Functions for working with events and observers.\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_event_desc_t {
    #[doc = "The event id. Only triggers for the specified event will be notified"]
    pub event: ecs_entity_t,
    #[doc = "Component ids. Only triggers with a matching component id will be\n notified. Observers are guaranteed to get notified once, even if they\n match more than one id."]
    pub ids: *const ecs_type_t,
    #[doc = "The table for which to notify."]
    pub table: *mut ecs_table_t,
    #[doc = "Optional 2nd table to notify. This can be used to communicate the\n previous or next table, in case an entity is moved between tables."]
    pub other_table: *mut ecs_table_t,
    #[doc = "Limit notified entities to ones starting from offset (row) in table"]
    pub offset: i32,
    #[doc = "Limit number of notified entities to count. offset+count must be less\n than the total number of entities in the table. If left to 0, it will be\n automatically determined by doing ecs_table_count(table) - offset."]
    pub count: i32,
    #[doc = "Single-entity alternative to setting table / offset / count"]
    pub entity: ecs_entity_t,
    #[doc = "Optional context. Assigned to iter param member"]
    pub param: *const ::std::os::raw::c_void,
    #[doc = "Observable (usually the world)"]
    pub observable: *mut ecs_poly_t,
    #[doc = "Event flags"]
    pub flags: ecs_flags32_t,
}
extern "C" {
    #[doc = "Send event.\n This sends an event to matching triggers & is the mechanism used by flecs\n itself to send OnAdd, OnRemove, etc events.\n\n Applications can use this function to send custom events, where a custom\n event can be any regular entity.\n\n Applications should not send builtin flecs events, as this may violate\n assumptions the code makes about the conditions under which those events are\n sent.\n\n Triggers are invoked synchronously. It is therefore safe to use stack-based\n data as event context, which can be set in the \"param\" member.\n\n To send a notification for a single entity, an application should set the\n following members in the event descriptor:\n\n - table: set to the table of the entity\n - offset: set to the row of the entity in the table\n - count: set to 1\n\n The table & row of the entity can be obtained like this:\n   ecs_record_t *r = ecs_record_find(world, e);\n   desc.table = r->table;\n   desc.offset = ECS_RECORD_TO_ROW(r->row);\n\n @param world The world.\n @param desc Event parameters."]
    pub fn ecs_emit(world: *mut ecs_world_t, desc: *mut ecs_event_desc_t);
}
extern "C" {
    #[doc = "Create observer.\n Observers are like triggers, but can subscribe for multiple terms. An\n observer only triggers when the source of the event meets all terms.\n\n See the documentation for ecs_observer_desc_t for more details.\n\n @param world The world.\n @param desc The observer creation parameters."]
    pub fn ecs_observer_init(
        world: *mut ecs_world_t,
        desc: *const ecs_observer_desc_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Default run action for observer.\n This function can be called from a custom observer run action (see\n ecs_observer_desc_t::run for more details). This function ensures that the\n observer's filter is applied to the iterator's table, filters out duplicate\n events and implements EcsMonitor logic.\n\n @param it The iterator.\n @return True if the observer was invoked."]
    pub fn ecs_observer_default_run_action(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    pub fn ecs_get_observer_ctx(
        world: *const ecs_world_t,
        observer: ecs_entity_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_get_observer_binding_ctx(
        world: *const ecs_world_t,
        observer: ecs_entity_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Create iterator from poly object.\n The provided poly object must have the iterable mixin. If an object is\n provided that does not have the mixin, the function will assert.\n\n When a filter is provided, an array of two iterators must be passed to the\n function. This allows the mixin implementation to create a chained iterator\n when necessary, which requires two iterator objects.\n\n If a filter is provided, the first element in the array of two iterators is\n the one that should be iterated. The mixin implementation may or may not set\n the second element, depending on whether an iterator chain is required.\n\n Additionally, when a filter is provided the returned iterator will be for a\n single term with the provided filter id. If the iterator is chained, the\n previous iterator in the chain can be accessed through it->chain_it.\n\n @param world The world or stage for which to create the iterator.\n @param poly The poly object from which to create the iterator.\n @param iter The iterator (out, ecs_iter_t\\[2\\] when filter is set).\n @param filter Optional term used for filtering the results."]
    pub fn ecs_iter_poly(
        world: *const ecs_world_t,
        poly: *const ecs_poly_t,
        iter: *mut ecs_iter_t,
        filter: *mut ecs_term_t,
    );
}
extern "C" {
    #[doc = "Progress any iterator.\n This operation is useful in combination with iterators for which it is not\n known what created them. Example use cases are functions that should accept\n any kind of iterator (such as serializers) or iterators created from poly\n objects.\n\n This operation is slightly slower than using a type-specific iterator (e.g.\n ecs_filter_next, ecs_query_next) as it has to call a function pointer which\n introduces a level of indirection.\n\n @param it The iterator.\n @return True if iterator has more results, false if not."]
    pub fn ecs_iter_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = "Cleanup iterator resources.\n This operation cleans up any resources associated with the iterator.\n\n This operation should only be used when an iterator is not iterated until\n completion (next has not yet returned false). When an iterator is iterated\n until completion, resources are automatically freed.\n\n @param it The iterator."]
    pub fn ecs_iter_fini(it: *mut ecs_iter_t);
}
extern "C" {
    #[doc = "Count number of matched entities in query.\n This operation returns the number of matched entities. If a query contains no\n matched entities but still yields results (e.g. it has no terms with This\n sources) the operation will return 0.\n\n To determine the number of matched entities, the operation iterates the\n iterator until it yields no more results.\n\n @param it The iterator.\n @return True if iterator has more results, false if not."]
    pub fn ecs_iter_count(it: *mut ecs_iter_t) -> i32;
}
extern "C" {
    #[doc = "Test if iterator is true.\n This operation will return true if the iterator returns at least one result.\n This is especially useful in combination with fact-checking rules (see the\n rules addon).\n\n The operation requires a valid iterator. After the operation is invoked, the\n application should no longer invoke next on the iterator and should treat it\n as if the iterator is iterated until completion.\n\n @param it The iterator.\n @return true if the iterator returns at least one result."]
    pub fn ecs_iter_is_true(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = "Get first matching entity from iterator.\n After this operation the application should treat the iterator as if it has\n been iterated until completion.\n\n @param it The iterator.\n @return The first matching entity, or 0 if no entities were matched."]
    pub fn ecs_iter_first(it: *mut ecs_iter_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Set value for iterator variable.\n This constrains the iterator to return only results for which the variable\n equals the specified value. The default value for all variables is\n EcsWildcard, which means the variable can assume any value.\n\n Example:\n\n // Rule that matches (Eats, *)\n ecs_rule_t *r = ecs_rule_init(world, &(ecs_filter_desc_t){\n   .terms = {\n     { .first.id = Eats, .second.name = \"_Food\" }\n   }\n });\n\n int food_var = ecs_rule_find_var(r, \"Food\");\n\n // Set Food to Apples, so we're only matching (Eats, Apples)\n ecs_iter_t it = ecs_rule_iter(world, r);\n ecs_iter_set_var(&it, food_var, Apples);\n\n while (ecs_rule_next(&it)) {\n   for (int i = 0; i < it.count; i ++) {\n     // iterate as usual\n   }\n }\n\n The variable must be initialized after creating the iterator and before the\n first call to next.\n\n @param it The iterator.\n @param var_id The variable index.\n @param entity The entity variable value."]
    pub fn ecs_iter_set_var(it: *mut ecs_iter_t, var_id: i32, entity: ecs_entity_t);
}
extern "C" {
    #[doc = "Same as ecs_iter_set_var, but for a table.\n This constrains the variable to all entities in a table.\n\n @param it The iterator.\n @param var_id The variable index.\n @param table The table variable value."]
    pub fn ecs_iter_set_var_as_table(it: *mut ecs_iter_t, var_id: i32, table: *const ecs_table_t);
}
extern "C" {
    #[doc = "Same as ecs_iter_set_var, but for a range of entities\n This constrains the variable to a range of entities in a table.\n\n @param it The iterator.\n @param var_id The variable index.\n @param range The range variable value."]
    pub fn ecs_iter_set_var_as_range(
        it: *mut ecs_iter_t,
        var_id: i32,
        range: *const ecs_table_range_t,
    );
}
extern "C" {
    #[doc = "Get value of iterator variable as entity.\n A variable can be interpreted as entity if it is set to an entity, or if it\n is set to a table range with count 1.\n\n This operation can only be invoked on valid iterators. The variable index\n must be smaller than the total number of variables provided by the iterator\n (as set in ecs_iter_t::variable_count).\n\n @param it The iterator.\n @param var_id The variable index."]
    pub fn ecs_iter_get_var(it: *mut ecs_iter_t, var_id: i32) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Get value of iterator variable as table.\n A variable can be interpreted as table if it is set as table range with\n both offset and count set to 0, or if offset is 0 and count matches the\n number of elements in the table.\n\n This operation can only be invoked on valid iterators. The variable index\n must be smaller than the total number of variables provided by the iterator\n (as set in ecs_iter_t::variable_count).\n\n @param it The iterator.\n @param var_id The variable index."]
    pub fn ecs_iter_get_var_as_table(it: *mut ecs_iter_t, var_id: i32) -> *mut ecs_table_t;
}
extern "C" {
    #[doc = "Get value of iterator variable as table range.\n A value can be interpreted as table range if it is set as table range, or if\n it is set to an entity with a non-empty type (the entity must have at least\n one component, tag or relationship in its type).\n\n This operation can only be invoked on valid iterators. The variable index\n must be smaller than the total number of variables provided by the iterator\n (as set in ecs_iter_t::variable_count).\n\n @param it The iterator.\n @param var_id The variable index."]
    pub fn ecs_iter_get_var_as_range(it: *mut ecs_iter_t, var_id: i32) -> ecs_table_range_t;
}
extern "C" {
    #[doc = "Returns whether variable is constrained.\n This operation returns true for variables set by one of the ecs_iter_set_var*\n operations.\n\n A constrained variable is guaranteed not to change values while results are\n being iterated.\n\n @param it The iterator.\n @param var_id The variable index.\n @return Whether the variable is constrained to a specified value."]
    pub fn ecs_iter_var_is_constrained(it: *mut ecs_iter_t, var_id: i32) -> bool;
}
extern "C" {
    #[doc = "Create a paged iterator.\n Paged iterators limit the results to those starting from 'offset', and will\n return at most 'limit' results.\n\n The iterator must be iterated with ecs_page_next.\n\n A paged iterator acts as a passthrough for data exposed by the parent\n iterator, so that any data provided by the parent will also be provided by\n the paged iterator.\n\n @param it The source iterator.\n @param offset The number of entities to skip.\n @param limit The maximum number of entities to iterate.\n @return A page iterator."]
    pub fn ecs_page_iter(it: *const ecs_iter_t, offset: i32, limit: i32) -> ecs_iter_t;
}
extern "C" {
    #[doc = "Progress a paged iterator.\n Progresses an iterator created by ecs_page_iter.\n\n @param it The iterator.\n @return true if iterator has more results, false if not."]
    pub fn ecs_page_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = "Create a worker iterator.\n Worker iterators can be used to equally divide the number of matched entities\n across N resources (usually threads). Each resource will process the total\n number of matched entities divided by 'count'.\n\n Entities are distributed across resources such that the distribution is\n stable between queries. Two queries that match the same table are guaranteed\n to match the same entities in that table.\n\n The iterator must be iterated with ecs_worker_next.\n\n A worker iterator acts as a passthrough for data exposed by the parent\n iterator, so that any data provided by the parent will also be provided by\n the worker iterator.\n\n @param it The source iterator.\n @param index The index of the current resource.\n @param count The total number of resources to divide entities between.\n @return A worker iterator."]
    pub fn ecs_worker_iter(it: *const ecs_iter_t, index: i32, count: i32) -> ecs_iter_t;
}
extern "C" {
    #[doc = "Progress a worker iterator.\n Progresses an iterator created by ecs_worker_iter.\n\n @param it The iterator.\n @return true if iterator has more results, false if not."]
    pub fn ecs_worker_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = "Obtain data for a query field.\n This operation retrieves a pointer to an array of data that belongs to the\n term in the query. The index refers to the location of the term in the query,\n and starts counting from one.\n\n For example, the query \"Position, Velocity\" will return the Position array\n for index 1, and the Velocity array for index 2.\n\n When the specified field is not owned by the entity this function returns a\n pointer instead of an array. This happens when the source of a field is not\n the entity being iterated, such as a shared component (from a prefab), a\n component from a parent, or another entity. The ecs_field_is_self operation\n can be used to test dynamically if a field is owned.\n\n The provided size must be either 0 or must match the size of the datatype\n of the returned array. If the size does not match, the operation may assert.\n The size can be dynamically obtained with ecs_field_size.\n\n @param it The iterator.\n @param size The type size of the requested data.\n @param index The index of the field in the iterator.\n @return A pointer to the data of the field."]
    pub fn ecs_field_w_size(
        it: *const ecs_iter_t,
        size: usize,
        index: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Test whether the field is readonly.\n This operation returns whether the field is readonly. Readonly fields are\n annotated with \\[in\\], or are added as a const type in the C++ API.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return Whether the field is readonly."]
    pub fn ecs_field_is_readonly(it: *const ecs_iter_t, index: i32) -> bool;
}
extern "C" {
    #[doc = "Test whether the field is writeonly.\n This operation returns whether this is a writeonly field. Writeonly terms are\n annotated with \\[out\\].\n\n Serializers are not required to serialize the values of a writeonly field.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return Whether the field is writeonly."]
    pub fn ecs_field_is_writeonly(it: *const ecs_iter_t, index: i32) -> bool;
}
extern "C" {
    #[doc = "Test whether field is set.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return Whether the field is set."]
    pub fn ecs_field_is_set(it: *const ecs_iter_t, index: i32) -> bool;
}
extern "C" {
    #[doc = "Return id matched for field.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return The id matched for the field."]
    pub fn ecs_field_id(it: *const ecs_iter_t, index: i32) -> ecs_id_t;
}
extern "C" {
    #[doc = "Return index of matched table column.\n This function only returns column indices for fields that have been matched\n on the the $this variable. Fields matched on other tables will return -1.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return The index of the matched column, -1 if not matched."]
    pub fn ecs_field_column_index(it: *const ecs_iter_t, index: i32) -> i32;
}
extern "C" {
    #[doc = "Return field source.\n The field source is the entity on which the field was matched.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return The source for the field."]
    pub fn ecs_field_src(it: *const ecs_iter_t, index: i32) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Return field type size.\n Return type size of the data returned by field. Returns 0 if field has no\n data.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return The type size for the field."]
    pub fn ecs_field_size(it: *const ecs_iter_t, index: i32) -> usize;
}
extern "C" {
    #[doc = "Test whether the field is matched on self.\n This operation returns whether the field is matched on the currently iterated\n entity. This function will return false when the field is owned by another\n entity, such as a parent or a prefab.\n\n When this operation returns false, the field must be accessed as a single\n value instead of an array. Fields for which this operation returns true\n return arrays with it->count values.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return Whether the field is matched on self."]
    pub fn ecs_field_is_self(it: *const ecs_iter_t, index: i32) -> bool;
}
extern "C" {
    #[doc = "Convert iterator to string.\n Prints the contents of an iterator to a string. Useful for debugging and/or\n testing the output of an iterator.\n\n The function only converts the currently iterated data to a string. To\n convert all data, the application has to manually call the next function and\n call ecs_iter_str on each result.\n\n @param it The iterator.\n @return A string representing the contents of the iterator."]
    pub fn ecs_iter_str(it: *const ecs_iter_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Get type for table.\n\n @param table The table.\n @return The type of the table."]
    pub fn ecs_table_get_type(table: *const ecs_table_t) -> *const ecs_type_t;
}
extern "C" {
    #[doc = "Get column from table.\n This operation returns the component array for the provided index.\n\n @param table The table.\n @param index The index of the column (corresponds with element in type).\n @param offset The index of the first row to return (0 for entire column).\n @return The component array, or NULL if the index is not a component."]
    pub fn ecs_table_get_column(
        table: *const ecs_table_t,
        index: i32,
        offset: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Get column size from table.\n This operation returns the component size for the provided index.\n\n @param table The table.\n @param index The index of the column (corresponds with element in type).\n @return The component size, or 0 if the index is not a component."]
    pub fn ecs_table_get_column_size(table: *const ecs_table_t, index: i32) -> usize;
}
extern "C" {
    #[doc = "Get column index for id.\n This operation returns the index for an id in the table's type.\n\n @param world The world.\n @param table The table.\n @param id The id.\n @return The index of the id in the table type, or -1 if not found."]
    pub fn ecs_table_get_index(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        id: ecs_id_t,
    ) -> i32;
}
extern "C" {
    #[doc = "Test if table has id.\n Same as ecs_table_get_index(world, table, id) != -1.\n\n @param world The world.\n @param table The table.\n @param id The id.\n @return True if the table has the id, false if the table doesn't."]
    pub fn ecs_table_has_id(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        id: ecs_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "Get column from table by component id.\n This operation returns the component array for the provided component  id.\n\n @param table The table.\n @param id The component id for the column.\n @param offset The index of the first row to return (0 for entire column).\n @return The component array, or NULL if the index is not a component."]
    pub fn ecs_table_get_id(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        id: ecs_id_t,
        offset: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Return depth for table in tree for relationship rel.\n Depth is determined by counting the number of targets encountered while\n traversing up the relationship tree for rel. Only acyclic relationships are\n supported.\n\n @param world The world.\n @param table The table.\n @param rel The relationship.\n @return The depth of the table in the tree."]
    pub fn ecs_table_get_depth(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        rel: ecs_entity_t,
    ) -> i32;
}
extern "C" {
    #[doc = "Get storage type for table.\n\n @param table The table.\n @return The storage type of the table (components only)."]
    pub fn ecs_table_get_storage_table(table: *const ecs_table_t) -> *mut ecs_table_t;
}
extern "C" {
    #[doc = "Convert index in table type to index in table storage type."]
    pub fn ecs_table_type_to_storage_index(table: *const ecs_table_t, index: i32) -> i32;
}
extern "C" {
    #[doc = "Convert index in table storage type to index in table type."]
    pub fn ecs_table_storage_to_type_index(table: *const ecs_table_t, index: i32) -> i32;
}
extern "C" {
    #[doc = "Returns the number of records in the table.\n This operation returns the number of records that have been populated through\n the regular (entity) API as well as the number of records that have been\n inserted using the direct access API.\n\n @param table The table.\n @return The number of records in a table."]
    pub fn ecs_table_count(table: *const ecs_table_t) -> i32;
}
extern "C" {
    #[doc = "Get table that has all components of current table plus the specified id.\n If the provided table already has the provided id, the operation will return\n the provided table.\n\n @param world The world.\n @param table The table.\n @param id The id to add.\n @result The resulting table."]
    pub fn ecs_table_add_id(
        world: *mut ecs_world_t,
        table: *mut ecs_table_t,
        id: ecs_id_t,
    ) -> *mut ecs_table_t;
}
extern "C" {
    #[doc = "Find table from id array.\n This operation finds or creates a table with the specified array of\n (component) ids. The ids in the array must be sorted, and it may not contain\n duplicate elements.\n\n @param world The world.\n @param ids The id array.\n @param id_count The number of elements in the id array.\n @return The table with the specified (component) ids."]
    pub fn ecs_table_find(
        world: *mut ecs_world_t,
        ids: *const ecs_id_t,
        id_count: i32,
    ) -> *mut ecs_table_t;
}
extern "C" {
    #[doc = "Get table that has all components of current table minus the specified id.\n If the provided table doesn't have the provided id, the operation will return\n the provided table.\n\n @param world The world.\n @param table The table.\n @param id The id to remove.\n @result The resulting table."]
    pub fn ecs_table_remove_id(
        world: *mut ecs_world_t,
        table: *mut ecs_table_t,
        id: ecs_id_t,
    ) -> *mut ecs_table_t;
}
extern "C" {
    #[doc = "Lock or unlock table.\n When a table is locked, modifications to it will throw an assert. When the\n table is locked recursively, it will take an equal amount of unlock\n operations to actually unlock the table.\n\n Table locks can be used to build safe iterators where it is guaranteed that\n the contents of a table are not modified while it is being iterated.\n\n The operation only works when called on the world, and has no side effects\n when called on a stage. The assumption is that when called on a stage,\n operations are deferred already.\n\n @param world The world.\n @param table The table to lock."]
    pub fn ecs_table_lock(world: *mut ecs_world_t, table: *mut ecs_table_t);
}
extern "C" {
    #[doc = "Unlock a table.\n Must be called after calling ecs_table_lock.\n\n @param world The world.\n @param table The table to unlock."]
    pub fn ecs_table_unlock(world: *mut ecs_world_t, table: *mut ecs_table_t);
}
extern "C" {
    #[doc = "Returns whether table is a module or contains module contents\n Returns true for tables that have module contents. Can be used to filter out\n tables that do not contain application data.\n\n @param table The table.\n @return true if table contains module contents, false if not."]
    pub fn ecs_table_has_module(table: *mut ecs_table_t) -> bool;
}
extern "C" {
    #[doc = "Swaps two elements inside the table. This is useful for implementing custom\n table sorting algorithms.\n @param world The world\n @param table The table to swap elements in\n @param row_1 Table element to swap with row_2\n @param row_2 Table element to swap with row_1"]
    pub fn ecs_table_swap_rows(
        world: *mut ecs_world_t,
        table: *mut ecs_table_t,
        row_1: i32,
        row_2: i32,
    );
}
extern "C" {
    #[doc = "Commit (move) entity to a table.\n This operation moves an entity from its current table to the specified\n table. This may cause the following actions:\n - Ctor for each component in the target table\n - Move for each overlapping component\n - Dtor for each component in the source table.\n - OnAdd triggers for non-overlapping components in the target table\n - OnRemove triggers for non-overlapping components in the source table.\n\n This operation is a faster than adding/removing components individually.\n\n The application must explicitly provide the difference in components between\n tables as the added/removed parameters. This can usually be derived directly\n from the result of ecs_table_add_id and esc_table_remove_id. These arrays are\n required to properly execute OnAdd/OnRemove triggers.\n\n @param world The world.\n @param entity The entity to commit.\n @param record The entity's record (optional, providing it saves a lookup).\n @param table The table to commit the entity to.\n @return True if the entity got moved, false otherwise."]
    pub fn ecs_commit(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        record: *mut ecs_record_t,
        table: *mut ecs_table_t,
        added: *const ecs_type_t,
        removed: *const ecs_type_t,
    ) -> bool;
}
extern "C" {
    #[doc = "Find record for entity."]
    pub fn ecs_record_find(world: *const ecs_world_t, entity: ecs_entity_t) -> *mut ecs_record_t;
}
extern "C" {
    #[doc = "Get component pointer from column/record."]
    pub fn ecs_record_get_column(
        r: *const ecs_record_t,
        column: i32,
        c_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Search for component id in table type.\n This operation returns the index of first occurrance of the id in the table\n type. The id may be a wildcard.\n\n When id_out is provided, the function will assign it with the found id. The\n found id may be different from the provided id if it is a wildcard.\n\n This is a constant time operation.\n\n @param world The world.\n @param table The table.\n @param id The id to search for.\n @param id_out If provided, it will be set to the found id (optional).\n @return The index of the id in the table type."]
    pub fn ecs_search(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        id: ecs_id_t,
        id_out: *mut ecs_id_t,
    ) -> i32;
}
extern "C" {
    #[doc = "Search for component id in table type starting from an offset.\n This operation is the same as ecs_search, but starts searching from an offset\n in the table type.\n\n This operation is typically called in a loop where the resulting index is\n used in the next iteration as offset:\n\n int32_t index = -1;\n while ((index = ecs_search_offset(world, table, offset, id, NULL))) {\n   // do stuff\n }\n\n Depending on how the operation is used it is either linear or constant time.\n When the id has the form (id) or (rel, *) and the operation is invoked as\n in the above example, it is guaranteed to be constant time.\n\n If the provided id has the form (*, tgt) the operation takes linear time. The\n reason for this is that ids for an target are not packed together, as they\n are sorted relationship first.\n\n If the id at the offset does not match the provided id, the operation will do\n a linear search to find a matching id.\n\n @param world The world.\n @param table The table.\n @param offset Offset from where to start searching.\n @param id The id to search for.\n @param id_out If provided, it will be set to the found id (optional).\n @return The index of the id in the table type."]
    pub fn ecs_search_offset(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        offset: i32,
        id: ecs_id_t,
        id_out: *mut ecs_id_t,
    ) -> i32;
}
extern "C" {
    #[doc = "Search for component/relationship id in table type starting from an offset.\n This operation is the same as ecs_search_offset, but has the additional\n capability of traversing relationships to find a component. For example, if\n an application wants to find a component for either the provided table or a\n prefab (using the IsA relationship) of that table, it could use the operation\n like this:\n\n int32_t index = ecs_search_relation(\n   world,            // the world\n   table,            // the table\n   0,                // offset 0\n   ecs_id(Position), // the component id\n   EcsIsA,           // the relationship to traverse\n   0,                // start at depth 0 (the table itself)\n   0,                // no depth limit\n   NULL,             // (optional) entity on which component was found\n   NULL,             // see above\n   NULL);            // internal type with information about matched id\n\n The operation searches depth first. If a table type has 2 IsA relationships, the\n operation will first search the IsA tree of the first relationship.\n\n When choosing betwen ecs_search, ecs_search_offset and ecs_search_relation,\n the simpler the function the better its performance.\n\n @param world The world.\n @param table The table.\n @param offset Offset from where to start searching.\n @param id The id to search for.\n @param rel The relationship to traverse (optional).\n @param flags Whether to search EcsSelf and/or EcsUp.\n @param subject_out If provided, it will be set to the matched entity.\n @param id_out If provided, it will be set to the found id (optional).\n @param tr_out Internal datatype.\n @return The index of the id in the table type."]
    pub fn ecs_search_relation(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        offset: i32,
        id: ecs_id_t,
        rel: ecs_entity_t,
        flags: ecs_flags32_t,
        subject_out: *mut ecs_entity_t,
        id_out: *mut ecs_id_t,
        tr_out: *mut *mut ecs_table_record_t,
    ) -> i32;
}
extern "C" {
    #[doc = "Construct a value in existing storage\n\n @param world The world.\n @param type The type of the value to create.\n @param ptr Pointer to a value of type 'type'\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_init(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Construct a value in existing storage\n\n @param world The world.\n @param ti The type info of the type to create.\n @param ptr Pointer to a value of type 'type'\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_init_w_type_info(
        world: *const ecs_world_t,
        ti: *const ecs_type_info_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Construct a value in new storage\n\n @param world The world.\n @param type The type of the value to create.\n @return Pointer to type if success, NULL if failed."]
    pub fn ecs_value_new(
        world: *mut ecs_world_t,
        type_: ecs_entity_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Construct a value in new storage\n\n @param world The world.\n @param ti The type info of the type to create.\n @return Pointer to type if success, NULL if failed."]
    pub fn ecs_value_new_w_type_info(
        world: *mut ecs_world_t,
        ti: *const ecs_type_info_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Destruct a value\n\n @param world The world.\n @param ti Type info of the value to destruct.\n @param ptr Pointer to constructed value of type 'type'.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_fini_w_type_info(
        world: *const ecs_world_t,
        ti: *const ecs_type_info_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Destruct a value\n\n @param world The world.\n @param type The type of the value to destruct.\n @param ptr Pointer to constructed value of type 'type'.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_fini(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Destruct a value, free storage\n\n @param world The world.\n @param type The type of the value to destruct.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_free(
        world: *mut ecs_world_t,
        type_: ecs_entity_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Copy value.\n\n @param world The world.\n @param ti Type info of the value to copy.\n @param dst Pointer to the storage to copy to.\n @param src Pointer to the value to copy.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_copy_w_type_info(
        world: *const ecs_world_t,
        ti: *const ecs_type_info_t,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Copy value.\n\n @param world The world.\n @param type The type of the value to copy.\n @param dst Pointer to the storage to copy to.\n @param src Pointer to the value to copy.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_copy(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Move value.\n\n @param world The world.\n @param ti Type info of the value to move.\n @param dst Pointer to the storage to move to.\n @param src Pointer to the value to move.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_move_w_type_info(
        world: *const ecs_world_t,
        ti: *const ecs_type_info_t,
        dst: *mut ::std::os::raw::c_void,
        src: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Move value.\n\n @param world The world.\n @param type The type of the value to move.\n @param dst Pointer to the storage to move to.\n @param src Pointer to the value to move.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_move(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        dst: *mut ::std::os::raw::c_void,
        src: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Move construct value.\n\n @param world The world.\n @param ti Type info of the value to move.\n @param dst Pointer to the storage to move to.\n @param src Pointer to the value to move.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_move_ctor_w_type_info(
        world: *const ecs_world_t,
        ti: *const ecs_type_info_t,
        dst: *mut ::std::os::raw::c_void,
        src: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Move construct value.\n\n @param world The world.\n @param type The type of the value to move.\n @param dst Pointer to the storage to move to.\n @param src Pointer to the value to move.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_move_ctor(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        dst: *mut ::std::os::raw::c_void,
        src: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Tracing"]
    pub fn _ecs_deprecated(
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "Increase log stack.\n This operation increases the indent_ value of the OS API and can be useful to\n make nested behavior more visible.\n\n @param level The log level."]
    pub fn _ecs_log_push(level: i32);
}
extern "C" {
    #[doc = "Decrease log stack.\n This operation decreases the indent_ value of the OS API and can be useful to\n make nested behavior more visible.\n\n @param level The log level."]
    pub fn _ecs_log_pop(level: i32);
}
extern "C" {
    #[doc = "Should current level be logged.\n This operation returns true when the specified log level should be logged\n with the current log level.\n\n @param level The log level to check for.\n @return Whether logging is enabled for the current level."]
    pub fn ecs_should_log(level: i32) -> bool;
}
extern "C" {
    #[doc = "Get description for error code"]
    pub fn ecs_strerror(error_code: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Logging functions (do nothing when logging is enabled)"]
    pub fn _ecs_print(
        level: i32,
        file: *const ::std::os::raw::c_char,
        line: i32,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn _ecs_printv(
        level: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: i32,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn _ecs_log(
        level: i32,
        file: *const ::std::os::raw::c_char,
        line: i32,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn _ecs_logv(
        level: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: i32,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn _ecs_abort(
        error_code: i32,
        file: *const ::std::os::raw::c_char,
        line: i32,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn _ecs_assert(
        condition: bool,
        error_code: i32,
        condition_str: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: i32,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> bool;
}
extern "C" {
    pub fn _ecs_parser_error(
        name: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        column: i64,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn _ecs_parser_errorv(
        name: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        column: i64,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    );
}
extern "C" {
    #[doc = "Enable or disable log.\n This will enable builtin log. For log to work, it will have to be\n compiled in which requires defining one of the following macros:\n\n FLECS_LOG_0 - All log is disabled\n FLECS_LOG_1 - Enable log level 1\n FLECS_LOG_2 - Enable log level 2 and below\n FLECS_LOG_3 - Enable log level 3 and below\n\n If no log level is defined and this is a debug build, FLECS_LOG_3 will\n have been automatically defined.\n\n The provided level corresponds with the log level. If -1 is provided as\n value, warnings are disabled. If -2 is provided, errors are disabled as well.\n\n @param level Desired tracing level.\n @return Previous log level."]
    pub fn ecs_log_set_level(level: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get current log level.\n\n @return Previous log level."]
    pub fn ecs_log_get_level() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Enable/disable tracing with colors.\n By default colors are enabled.\n\n @param enabled Whether to enable tracing with colors.\n @return Previous color setting."]
    pub fn ecs_log_enable_colors(enabled: bool) -> bool;
}
extern "C" {
    #[doc = "Enable/disable logging timestamp.\n By default timestamps are disabled. Note that enabling timestamps introduces\n overhead as the logging code will need to obtain the current time.\n\n @param enabled Whether to enable tracing with timestamps.\n @return Previous timestamp setting."]
    pub fn ecs_log_enable_timestamp(enabled: bool) -> bool;
}
extern "C" {
    #[doc = "Enable/disable logging time since last log.\n By default deltatime is disabled. Note that enabling timestamps introduces\n overhead as the logging code will need to obtain the current time.\n\n When enabled, this logs the amount of time in seconds passed since the last\n log, when this amount is non-zero. The format is a '+' character followed by\n the number of seconds:\n\n   +1 trace: log message\n\n @param enabled Whether to enable tracing with timestamps.\n @return Previous timestamp setting."]
    pub fn ecs_log_enable_timedelta(enabled: bool) -> bool;
}
extern "C" {
    #[doc = "Get last logged error code.\n Calling this operation resets the error code.\n\n @return Last error, 0 if none was logged since last call to last_error."]
    pub fn ecs_log_last_error() -> ::std::os::raw::c_int;
}
#[doc = "Callback type for init action."]
pub type ecs_app_init_action_t =
    ::std::option::Option<unsafe extern "C" fn(world: *mut ecs_world_t) -> ::std::os::raw::c_int>;
#[doc = "Used with ecs_app_run."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_app_desc_t {
    #[doc = "< Target FPS."]
    pub target_fps: f32,
    #[doc = "< Frame time increment (0 for measured values)"]
    pub delta_time: f32,
    #[doc = "< Number of threads."]
    pub threads: i32,
    #[doc = "< Number of frames to run (0 for infinite)"]
    pub frames: i32,
    #[doc = "< Enables ECS access over HTTP, necessary for explorer"]
    pub enable_rest: bool,
    #[doc = "< Periodically collect statistics"]
    pub enable_monitor: bool,
    #[doc = "< HTTP port used by REST API"]
    pub port: u16,
    #[doc = "< If set, function is ran before starting the\n main loop."]
    pub init: ecs_app_init_action_t,
    #[doc = "< Reserved for custom run/frame actions"]
    pub ctx: *mut ::std::os::raw::c_void,
}
#[doc = "Callback type for run action."]
pub type ecs_app_run_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        world: *mut ecs_world_t,
        desc: *mut ecs_app_desc_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "Callback type for frame action."]
pub type ecs_app_frame_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        world: *mut ecs_world_t,
        desc: *const ecs_app_desc_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = "Run application.\n This will run the application with the parameters specified in desc. After\n the application quits (ecs_quit is called) the world will be cleaned up.\n\n If a custom run action is set, it will be invoked by this operation. The\n default run action calls the frame action in a loop until it returns a\n non-zero value.\n\n @param world The world.\n @param desc Application parameters."]
    pub fn ecs_app_run(world: *mut ecs_world_t, desc: *mut ecs_app_desc_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Default frame callback.\n This operation will run a single frame. By default this operation will invoke\n ecs_progress directly, unless a custom frame action is set.\n\n @param world The world.\n @param desc The desc struct passed to ecs_app_run.\n @return value returned by ecs_progress"]
    pub fn ecs_app_run_frame(
        world: *mut ecs_world_t,
        desc: *const ecs_app_desc_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set custom run action.\n See ecs_app_run.\n\n @param callback The run action."]
    pub fn ecs_app_set_run_action(callback: ecs_app_run_action_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set custom frame action.\n See ecs_app_run_frame.\n\n @param callback The frame action."]
    pub fn ecs_app_set_frame_action(callback: ecs_app_frame_action_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_http_server_t {
    _unused: [u8; 0],
}
#[doc = "A connection manages communication with the remote host"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_http_connection_t {
    pub id: u64,
    pub server: *mut ecs_http_server_t,
    pub host: [::std::os::raw::c_char; 128usize],
    pub port: [::std::os::raw::c_char; 16usize],
}
#[doc = "Helper type used for headers & URL query parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_http_key_value_t {
    pub key: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
}
pub const ecs_http_method_t_EcsHttpGet: ecs_http_method_t = 0;
pub const ecs_http_method_t_EcsHttpPost: ecs_http_method_t = 1;
pub const ecs_http_method_t_EcsHttpPut: ecs_http_method_t = 2;
pub const ecs_http_method_t_EcsHttpDelete: ecs_http_method_t = 3;
pub const ecs_http_method_t_EcsHttpOptions: ecs_http_method_t = 4;
pub const ecs_http_method_t_EcsHttpMethodUnsupported: ecs_http_method_t = 5;
#[doc = "Supported request methods"]
pub type ecs_http_method_t = ::std::os::raw::c_int;
#[doc = "A request"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_http_request_t {
    pub id: u64,
    pub method: ecs_http_method_t,
    pub path: *mut ::std::os::raw::c_char,
    pub body: *mut ::std::os::raw::c_char,
    pub headers: [ecs_http_key_value_t; 32usize],
    pub params: [ecs_http_key_value_t; 32usize],
    pub header_count: i32,
    pub param_count: i32,
    pub conn: *mut ecs_http_connection_t,
}
#[doc = "A reply"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_http_reply_t {
    #[doc = "< default = 200"]
    pub code: ::std::os::raw::c_int,
    #[doc = "< default = \"\""]
    pub body: ecs_strbuf_t,
    #[doc = "< default = OK"]
    pub status: *const ::std::os::raw::c_char,
    #[doc = "< default = application/json"]
    pub content_type: *const ::std::os::raw::c_char,
    #[doc = "< default = \"\""]
    pub headers: ecs_strbuf_t,
}
extern "C" {
    #[doc = "Global statistics."]
    pub static mut ecs_http_request_received_count: i64;
}
extern "C" {
    pub static mut ecs_http_request_invalid_count: i64;
}
extern "C" {
    pub static mut ecs_http_request_handled_ok_count: i64;
}
extern "C" {
    pub static mut ecs_http_request_handled_error_count: i64;
}
extern "C" {
    pub static mut ecs_http_request_not_handled_count: i64;
}
extern "C" {
    pub static mut ecs_http_request_preflight_count: i64;
}
extern "C" {
    pub static mut ecs_http_send_ok_count: i64;
}
extern "C" {
    pub static mut ecs_http_send_error_count: i64;
}
extern "C" {
    pub static mut ecs_http_busy_count: i64;
}
#[doc = "Request callback.\n Invoked for each valid request. The function should populate the reply and\n return true. When the function returns false, the server will reply with a\n 404 (Not found) code."]
pub type ecs_http_reply_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        request: *const ecs_http_request_t,
        reply: *mut ecs_http_reply_t,
        ctx: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "Used with ecs_http_server_init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_http_server_desc_t {
    #[doc = "< Function called for each request"]
    pub callback: ecs_http_reply_action_t,
    #[doc = "< Passed to callback (optional)"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = "< HTTP port"]
    pub port: u16,
    #[doc = "< Interface to listen on (optional)"]
    pub ipaddr: *const ::std::os::raw::c_char,
    #[doc = "< Send queue wait time when empty"]
    pub send_queue_wait_ms: i32,
}
extern "C" {
    #[doc = "Create server.\n Use ecs_http_server_start to start receiving requests.\n\n @param desc Server configuration parameters.\n @return The new server, or NULL if creation failed."]
    pub fn ecs_http_server_init(desc: *const ecs_http_server_desc_t) -> *mut ecs_http_server_t;
}
extern "C" {
    #[doc = "Destroy server.\n This operation will stop the server if it was still running.\n\n @param server The server to destroy."]
    pub fn ecs_http_server_fini(server: *mut ecs_http_server_t);
}
extern "C" {
    #[doc = "Start server.\n After this operation the server will be able to accept requests.\n\n @param server The server to start.\n @return Zero if successful, non-zero if failed."]
    pub fn ecs_http_server_start(server: *mut ecs_http_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Process server requests.\n This operation invokes the reply callback for each received request. No new\n requests will be enqueued while processing requests.\n\n @param server The server for which to process requests."]
    pub fn ecs_http_server_dequeue(server: *mut ecs_http_server_t, delta_time: f32);
}
extern "C" {
    #[doc = "Stop server.\n After this operation no new requests can be received.\n\n @param server The server."]
    pub fn ecs_http_server_stop(server: *mut ecs_http_server_t);
}
extern "C" {
    #[doc = "Emulate a request.\n The request string must be a valid HTTP request. A minimal example:\n   GET /entity/flecs/core/World?label=true HTTP/1.1\n\n @param srv The server.\n @param req The request.\n @param len The length of the request (optional).\n @return The reply."]
    pub fn ecs_http_server_http_request(
        srv: *mut ecs_http_server_t,
        req: *const ::std::os::raw::c_char,
        len: ecs_size_t,
        reply_out: *mut ecs_http_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Convenience wrapper around ecs_http_server_request."]
    pub fn ecs_http_server_request(
        srv: *mut ecs_http_server_t,
        method: *const ::std::os::raw::c_char,
        req: *const ::std::os::raw::c_char,
        reply_out: *mut ecs_http_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get context provided in ecs_http_server_desc_t"]
    pub fn ecs_http_server_ctx(srv: *mut ecs_http_server_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Find header in request.\n\n @param req The request.\n @param name name of the header to find\n @return The header value, or NULL if not found."]
    pub fn ecs_http_get_header(
        req: *const ecs_http_request_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Find query parameter in request.\n\n @param req The request.\n @param name The parameter name.\n @return The decoded parameter value, or NULL if not found."]
    pub fn ecs_http_get_param(
        req: *const ecs_http_request_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub static FLECS__EEcsRest: ecs_entity_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsRest {
    #[doc = "< Port of server (optional, default = 27750)"]
    pub port: u16,
    #[doc = "< Interface address (optional, default = 0.0.0.0)"]
    pub ipaddr: *mut ::std::os::raw::c_char,
    pub impl_: *mut ::std::os::raw::c_void,
}
extern "C" {
    #[doc = "Global statistics"]
    pub static mut ecs_rest_request_count: i64;
}
extern "C" {
    pub static mut ecs_rest_entity_count: i64;
}
extern "C" {
    pub static mut ecs_rest_entity_error_count: i64;
}
extern "C" {
    pub static mut ecs_rest_query_count: i64;
}
extern "C" {
    pub static mut ecs_rest_query_error_count: i64;
}
extern "C" {
    pub static mut ecs_rest_query_name_count: i64;
}
extern "C" {
    pub static mut ecs_rest_query_name_error_count: i64;
}
extern "C" {
    pub static mut ecs_rest_query_name_from_cache_count: i64;
}
extern "C" {
    pub static mut ecs_rest_enable_count: i64;
}
extern "C" {
    pub static mut ecs_rest_enable_error_count: i64;
}
extern "C" {
    pub static mut ecs_rest_delete_count: i64;
}
extern "C" {
    pub static mut ecs_rest_delete_error_count: i64;
}
extern "C" {
    pub static mut ecs_rest_world_stats_count: i64;
}
extern "C" {
    pub static mut ecs_rest_pipeline_stats_count: i64;
}
extern "C" {
    pub static mut ecs_rest_stats_error_count: i64;
}
extern "C" {
    #[doc = "Create HTTP server for REST API.\n This allows for the creation of a REST server that can be managed by the\n application without using Flecs systems.\n\n @param world The world.\n @param desc The HTTP server descriptor.\n @return The HTTP server, or NULL if failed."]
    pub fn ecs_rest_server_init(
        world: *mut ecs_world_t,
        desc: *const ecs_http_server_desc_t,
    ) -> *mut ecs_http_server_t;
}
extern "C" {
    #[doc = "Cleanup REST HTTP server.\n The server must have been created with ecs_rest_server_init."]
    pub fn ecs_rest_server_fini(srv: *mut ecs_http_server_t);
}
extern "C" {
    #[doc = "Module import"]
    pub fn FlecsRestImport(world: *mut ecs_world_t);
}
#[doc = "Component used for one shot/interval timer functionality"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsTimer {
    #[doc = "< Timer timeout period"]
    pub timeout: f32,
    #[doc = "< Incrementing time value"]
    pub time: f32,
    #[doc = "< Used to correct returned interval time"]
    pub overshoot: f32,
    #[doc = "< Number of times ticked"]
    pub fired_count: i32,
    #[doc = "< Is the timer active or not"]
    pub active: bool,
    #[doc = "< Is this a single shot timer"]
    pub single_shot: bool,
}
#[doc = "Apply a rate filter to a tick source"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsRateFilter {
    #[doc = "< Source of the rate filter"]
    pub src: ecs_entity_t,
    #[doc = "< Rate of the rate filter"]
    pub rate: i32,
    #[doc = "< Number of times the rate filter ticked"]
    pub tick_count: i32,
    #[doc = "< Time elapsed since last tick"]
    pub time_elapsed: f32,
}
extern "C" {
    #[doc = "Set timer timeout.\n This operation executes any systems associated with the timer after the\n specified timeout value. If the entity contains an existing timer, the\n timeout value will be reset. The timer can be started and stopped with\n ecs_start_timer and ecs_stop_timer.\n\n The timer is synchronous, and is incremented each frame by delta_time.\n\n The tick_source entity will be be a tick source after this operation. Tick\n sources can be read by getting the EcsTickSource component. If the tick\n source ticked this frame, the 'tick' member will be true. When the tick\n source is a system, the system will tick when the timer ticks.\n\n @param world The world.\n @param tick_source The timer for which to set the timeout (0 to create one).\n @param timeout The timeout value.\n @return The timer entity."]
    pub fn ecs_set_timeout(
        world: *mut ecs_world_t,
        tick_source: ecs_entity_t,
        timeout: f32,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Get current timeout value for the specified timer.\n This operation returns the value set by ecs_set_timeout. If no timer is\n active for this entity, the operation returns 0.\n\n After the timeout expires the EcsTimer component is removed from the entity.\n This means that if ecs_get_timeout is invoked after the timer is expired, the\n operation will return 0.\n\n The timer is synchronous, and is incremented each frame by delta_time.\n\n The tick_source entity will be be a tick source after this operation. Tick\n sources can be read by getting the EcsTickSource component. If the tick\n source ticked this frame, the 'tick' member will be true. When the tick\n source is a system, the system will tick when the timer ticks.\n\n @param world The world.\n @param tick_source The timer.\n @return The current timeout value, or 0 if no timer is active."]
    pub fn ecs_get_timeout(world: *const ecs_world_t, tick_source: ecs_entity_t) -> f32;
}
extern "C" {
    #[doc = "Set timer interval.\n This operation will continously invoke systems associated with the timer\n after the interval period expires. If the entity contains an existing timer,\n the interval value will be reset.\n\n The timer is synchronous, and is incremented each frame by delta_time.\n\n The tick_source entity will be be a tick source after this operation. Tick\n sources can be read by getting the EcsTickSource component. If the tick\n source ticked this frame, the 'tick' member will be true. When the tick\n source is a system, the system will tick when the timer ticks.\n\n @param world The world.\n @param tick_source The timer for which to set the interval (0 to create one).\n @param interval The interval value.\n @return The timer entity."]
    pub fn ecs_set_interval(
        world: *mut ecs_world_t,
        tick_source: ecs_entity_t,
        interval: f32,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Get current interval value for the specified timer.\n This operation returns the value set by ecs_set_interval. If the entity is\n not a timer, the operation will return 0.\n\n @param world The world.\n @param tick_source The timer for which to set the interval.\n @return The current interval value, or 0 if no timer is active."]
    pub fn ecs_get_interval(world: *const ecs_world_t, tick_source: ecs_entity_t) -> f32;
}
extern "C" {
    #[doc = "Start timer.\n This operation resets the timer and starts it with the specified timeout. The\n entity must have the EcsTimer component (added by ecs_set_timeout and\n ecs_set_interval). If the entity does not have the EcsTimer component this\n operation will assert.\n\n @param world The world.\n @param tick_source The timer to start."]
    pub fn ecs_start_timer(world: *mut ecs_world_t, tick_source: ecs_entity_t);
}
extern "C" {
    #[doc = "Stop timer\n This operation stops a timer from triggering. The entity must have the\n EcsTimer component or this operation will assert.\n\n @param world The world.\n @param tick_source The timer to stop."]
    pub fn ecs_stop_timer(world: *mut ecs_world_t, tick_source: ecs_entity_t);
}
extern "C" {
    #[doc = "Set rate filter.\n This operation initializes a rate filter. Rate filters sample tick sources\n and tick at a configurable multiple. A rate filter is a tick source itself,\n which means that rate filters can be chained.\n\n Rate filters enable deterministic system execution which cannot be achieved\n with interval timers alone. For example, if timer A has interval 2.0 and\n timer B has interval 4.0, it is not guaranteed that B will tick at exactly\n twice the multiple of A. This is partly due to the indeterministic nature of\n timers, and partly due to floating point rounding errors.\n\n Rate filters can be combined with timers (or other rate filters) to ensure\n that a system ticks at an exact multiple of a tick source (which can be\n another system). If a rate filter is created with a rate of 1 it will tick\n at the exact same time as its source.\n\n If no tick source is provided, the rate filter will use the frame tick as\n source, which corresponds with the number of times ecs_progress is called.\n\n The tick_source entity will be be a tick source after this operation. Tick\n sources can be read by getting the EcsTickSource component. If the tick\n source ticked this frame, the 'tick' member will be true. When the tick\n source is a system, the system will tick when the timer ticks.\n\n @param world The world.\n @param tick_source The rate filter entity (0 to create one).\n @param rate The rate to apply.\n @param source The tick source (0 to use frames)\n @return The filter entity."]
    pub fn ecs_set_rate(
        world: *mut ecs_world_t,
        tick_source: ecs_entity_t,
        rate: i32,
        source: ecs_entity_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Assign tick source to system.\n Systems can be their own tick source, which can be any of the tick sources\n (one shot timers, interval times and rate filters). However, in some cases it\n is must be guaranteed that different systems tick on the exact same frame.\n\n This cannot be guaranteed by giving two systems the same interval/rate filter\n as it is possible that one system is (for example) disabled, which would\n cause the systems to go out of sync. To provide these guarantees, systems\n must use the same tick source, which is what this operation enables.\n\n When two systems share the same tick source, it is guaranteed that they tick\n in the same frame. The provided tick source can be any entity that is a tick\n source, including another system. If the provided entity is not a tick source\n the system will not be ran.\n\n To disassociate a tick source from a system, use 0 for the tick_source\n parameter.\n\n @param world The world.\n @param system The system to associate with the timer.\n @param tick_source The tick source to associate with the system."]
    pub fn ecs_set_tick_source(
        world: *mut ecs_world_t,
        system: ecs_entity_t,
        tick_source: ecs_entity_t,
    );
}
extern "C" {
    #[doc = "Module"]
    pub fn FlecsTimerImport(world: *mut ecs_world_t);
}
#[doc = "Pipeline descriptor (used with ecs_pipeline_init)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_pipeline_desc_t {
    #[doc = "Existing entity to associate with pipeline (optional)"]
    pub entity: ecs_entity_t,
    #[doc = "Query descriptor. The first term of the query must match the EcsSystem\n component."]
    pub query: ecs_query_desc_t,
}
extern "C" {
    #[doc = "Create a custom pipeline."]
    pub fn ecs_pipeline_init(
        world: *mut ecs_world_t,
        desc: *const ecs_pipeline_desc_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Set a custom pipeline.\n This operation sets the pipeline to run when ecs_progress is invoked.\n\n @param world The world.\n @param pipeline The pipeline to set."]
    pub fn ecs_set_pipeline(world: *mut ecs_world_t, pipeline: ecs_entity_t);
}
extern "C" {
    #[doc = "Get the current pipeline.\n This operation gets the current pipeline.\n\n @param world The world.\n @return The current pipeline."]
    pub fn ecs_get_pipeline(world: *const ecs_world_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Progress a world.\n This operation progresses the world by running all systems that are both\n enabled and periodic on their matching entities.\n\n An application can pass a delta_time into the function, which is the time\n passed since the last frame. This value is passed to systems so they can\n update entity values proportional to the elapsed time since their last\n invocation.\n\n When an application passes 0 to delta_time, ecs_progress will automatically\n measure the time passed since the last frame. If an application does not uses\n time management, it should pass a non-zero value for delta_time (1.0 is\n recommended). That way, no time will be wasted measuring the time.\n\n @param world The world to progress.\n @param delta_time The time passed since the last frame.\n @return false if ecs_quit has been called, true otherwise."]
    pub fn ecs_progress(world: *mut ecs_world_t, delta_time: f32) -> bool;
}
extern "C" {
    #[doc = "Set time scale.\n Increase or decrease simulation speed by the provided multiplier.\n\n @param world The world.\n @param scale The scale to apply (default = 1)."]
    pub fn ecs_set_time_scale(world: *mut ecs_world_t, scale: f32);
}
extern "C" {
    #[doc = "Reset world clock.\n Reset the clock that keeps track of the total time passed in the simulation.\n\n @param world The world."]
    pub fn ecs_reset_clock(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = "Run pipeline.\n This will run all systems in the provided pipeline. This operation may be\n invoked from multiple threads, and only when staging is disabled, as the\n pipeline manages staging and, if necessary, synchronization between threads.\n\n If 0 is provided for the pipeline id, the default pipeline will be ran (this\n is either the builtin pipeline or the pipeline set with set_pipeline()).\n\n When using progress() this operation will be invoked automatically for the\n default pipeline (either the builtin pipeline or the pipeline set with\n set_pipeline()). An application may run additional pipelines.\n\n Note: calling this function from an application currently only works in\n single threaded applications with a single stage.\n\n @param world The world.\n @param pipeline The pipeline to run."]
    pub fn ecs_run_pipeline(world: *mut ecs_world_t, pipeline: ecs_entity_t, delta_time: f32);
}
extern "C" {
    #[doc = "Set number of worker threads.\n Setting this value to a value higher than 1 will start as many threads and\n will cause systems to evenly distribute matched entities across threads. The\n operation may be called multiple times to reconfigure the number of threads\n used, but never while running a system / pipeline.\n Calling ecs_set_threads will also end the use of task threads setup with\n ecs_set_task_threads and vice-versa"]
    pub fn ecs_set_threads(world: *mut ecs_world_t, threads: i32);
}
extern "C" {
    #[doc = "Set number of worker task threads.\n ecs_set_task_threads is similar to ecs_set_threads, except threads are treated\n as short-lived tasks and will be created and joined around each update of the world.\n Creation and joining of these tasks will use the os_api_t tasks APIs rather than the\n the standard thread API functions, although they may be the same if desired.\n This function is useful for multithreading world updates using an external\n asynchronous job system rather than long running threads by providing the APIs\n to create tasks for your job system and then wait on their conclusion.\n The operation may be called multiple times to reconfigure the number of task threads\n used, but never while running a system / pipeline.\n Calling ecs_set_task_threads will also end the use of threads setup with\n ecs_set_threads and vice-versa"]
    pub fn ecs_set_task_threads(world: *mut ecs_world_t, task_threads: i32);
}
extern "C" {
    #[doc = "Returns true if task thread use have been requested."]
    pub fn ecs_using_task_threads(world: *mut ecs_world_t) -> bool;
}
extern "C" {
    #[doc = "Module"]
    pub fn FlecsPipelineImport(world: *mut ecs_world_t);
}
#[doc = "Component used to provide a tick source to systems"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsTickSource {
    #[doc = "< True if providing tick"]
    pub tick: bool,
    #[doc = "< Time elapsed since last tick"]
    pub time_elapsed: f32,
}
#[doc = "Use with ecs_system_init"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_system_desc_t {
    pub _canary: i32,
    #[doc = "Existing entity to associate with system (optional)"]
    pub entity: ecs_entity_t,
    #[doc = "System query parameters"]
    pub query: ecs_query_desc_t,
    #[doc = "Callback that is invoked when a system is ran.\n When left to NULL, the default system runner is used, which calls the\n \"callback\" action for each result returned from the system's query.\n\n It should not be assumed that the input iterator can always be iterated\n with ecs_query_next. When a system is multithreaded and/or paged, the\n iterator can be either a worker or paged iterator. Future use cases may\n introduce additional inputs for a system, such as rules and filters. The\n correct function to use for iteration is ecs_iter_next.\n\n An implementation can test whether the iterator is a query iterator by\n testing whether the it->next value is equal to ecs_query_next."]
    pub run: ecs_run_action_t,
    #[doc = "Callback that is ran for each result returned by the system's query. This\n means that this callback can be invoked multiple times per system per\n frame, typically once for each matching table."]
    pub callback: ecs_iter_action_t,
    #[doc = "Context to be passed to callback (as ecs_iter_t::param)"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = "Binding context, for when system is implemented in other language"]
    pub binding_ctx: *mut ::std::os::raw::c_void,
    #[doc = "Functions that are invoked during system cleanup to free context data.\n When set, functions are called unconditionally, even when the ctx\n pointers are NULL."]
    pub ctx_free: ecs_ctx_free_t,
    pub binding_ctx_free: ecs_ctx_free_t,
    #[doc = "Interval in seconds at which the system should run"]
    pub interval: f32,
    #[doc = "Rate at which the system should run"]
    pub rate: i32,
    #[doc = "External tick soutce that determines when system ticks"]
    pub tick_source: ecs_entity_t,
    #[doc = "If true, system will be ran on multiple threads"]
    pub multi_threaded: bool,
    #[doc = "If true, system will have access to actuall world. Cannot be true at the\n same time as multi_threaded."]
    pub no_readonly: bool,
}
extern "C" {
    #[doc = "Create a system"]
    pub fn ecs_system_init(world: *mut ecs_world_t, desc: *const ecs_system_desc_t)
        -> ecs_entity_t;
}
extern "C" {
    #[doc = "Run a specific system manually.\n This operation runs a single system manually. It is an efficient way to\n invoke logic on a set of entities, as manual systems are only matched to\n tables at creation time or after creation time, when a new table is created.\n\n Manual systems are useful to evaluate lists of prematched entities at\n application defined times. Because none of the matching logic is evaluated\n before the system is invoked, manual systems are much more efficient than\n manually obtaining a list of entities and retrieving their components.\n\n An application may pass custom data to a system through the param parameter.\n This data can be accessed by the system through the param member in the\n ecs_iter_t value that is passed to the system callback.\n\n Any system may interrupt execution by setting the interrupted_by member in\n the ecs_iter_t value. This is particularly useful for manual systems, where\n the value of interrupted_by is returned by this operation. This, in\n cominbation with the param argument lets applications use manual systems\n to lookup entities: once the entity has been found its handle is passed to\n interrupted_by, which is then subsequently returned.\n\n @param world The world.\n @param system The system to run.\n @param delta_time The time passed since the last system invocation.\n @param param A user-defined parameter to pass to the system.\n @return handle to last evaluated entity if system was interrupted."]
    pub fn ecs_run(
        world: *mut ecs_world_t,
        system: ecs_entity_t,
        delta_time: f32,
        param: *mut ::std::os::raw::c_void,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Same as ecs_run, but subdivides entities across number of provided stages.\n\n @param world The world.\n @param system The system to run.\n @param stage_current The id of the current stage.\n @param stage_count The total number of stages.\n @param delta_time The time passed since the last system invocation.\n @param param A user-defined parameter to pass to the system.\n @return handle to last evaluated entity if system was interrupted."]
    pub fn ecs_run_worker(
        world: *mut ecs_world_t,
        system: ecs_entity_t,
        stage_current: i32,
        stage_count: i32,
        delta_time: f32,
        param: *mut ::std::os::raw::c_void,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Run system with offset/limit and type filter.\n This operation is the same as ecs_run, but filters the entities that will be\n iterated by the system.\n\n Entities can be filtered in two ways. Offset and limit control the range of\n entities that is iterated over. The range is applied to all entities matched\n with the system, thus may cover multiple archetypes.\n\n The type filter controls which entity types the system will evaluate. Only\n types that contain all components in the type filter will be iterated over. A\n type filter is only evaluated once per table, which makes filtering cheap if\n the number of entities is large and the number of tables is small, but not as\n cheap as filtering in the system signature.\n\n @param world The world.\n @param system The system to invoke.\n @param delta_time The time passed since the last system invocation.\n @param param A user-defined parameter to pass to the system.\n @return handle to last evaluated entity if system was interrupted."]
    pub fn ecs_run_w_filter(
        world: *mut ecs_world_t,
        system: ecs_entity_t,
        delta_time: f32,
        offset: i32,
        limit: i32,
        param: *mut ::std::os::raw::c_void,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Get the query object for a system.\n Systems use queries under the hood. This enables an application to get access\n to the underlying query object of a system. This can be useful when, for\n example, an application needs to enable sorting for a system.\n\n @param world The world.\n @param system The system from which to obtain the query.\n @return The query."]
    pub fn ecs_system_get_query(
        world: *const ecs_world_t,
        system: ecs_entity_t,
    ) -> *mut ecs_query_t;
}
extern "C" {
    #[doc = "Get system context.\n This operation returns the context pointer set for the system. If\n the provided entity is not a system, the function will return NULL.\n\n @param world The world.\n @param system The system from which to obtain the context.\n @return The context."]
    pub fn ecs_get_system_ctx(
        world: *const ecs_world_t,
        system: ecs_entity_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Get system binding context.\n The binding context is a context typically used to attach any language\n binding specific data that is needed when invoking a callback that is\n implemented in another language.\n\n @param world The world.\n @param system The system from which to obtain the context.\n @return The context."]
    pub fn ecs_get_system_binding_ctx(
        world: *const ecs_world_t,
        system: ecs_entity_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn FlecsSystemImport(world: *mut ecs_world_t);
}
#[doc = "Simple value that indicates current state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_gauge_t {
    pub avg: [f32; 60usize],
    pub min: [f32; 60usize],
    pub max: [f32; 60usize],
}
#[doc = "Monotonically increasing counter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_counter_t {
    #[doc = "< Keep track of deltas too"]
    pub rate: ecs_gauge_t,
    pub value: [f64; 60usize],
}
#[doc = "Make all metrics the same size, so we can iterate over fields"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ecs_metric_t {
    pub gauge: ecs_gauge_t,
    pub counter: ecs_counter_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t {
    pub first_: i64,
    pub entities: ecs_world_stats_t__bindgen_ty_1,
    pub ids: ecs_world_stats_t__bindgen_ty_2,
    pub tables: ecs_world_stats_t__bindgen_ty_3,
    pub queries: ecs_world_stats_t__bindgen_ty_4,
    pub commands: ecs_world_stats_t__bindgen_ty_5,
    pub frame: ecs_world_stats_t__bindgen_ty_6,
    pub performance: ecs_world_stats_t__bindgen_ty_7,
    pub memory: ecs_world_stats_t__bindgen_ty_8,
    pub rest: ecs_world_stats_t__bindgen_ty_9,
    pub http: ecs_world_stats_t__bindgen_ty_10,
    pub last_: i64,
    #[doc = "Current position in ringbuffer"]
    pub t: i32,
}
#[doc = "Entities"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_1 {
    #[doc = "< Number of entities"]
    pub count: ecs_metric_t,
    #[doc = "< Number of not alive (recyclable) entity ids"]
    pub not_alive_count: ecs_metric_t,
}
#[doc = "Components and ids"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_2 {
    #[doc = "< Number of ids (excluding wildcards)"]
    pub count: ecs_metric_t,
    #[doc = "< Number of tag ids (ids without data)"]
    pub tag_count: ecs_metric_t,
    #[doc = "< Number of components ids (ids with data)"]
    pub component_count: ecs_metric_t,
    #[doc = "< Number of pair ids"]
    pub pair_count: ecs_metric_t,
    #[doc = "< Number of wildcard ids"]
    pub wildcard_count: ecs_metric_t,
    #[doc = "< Number of registered types"]
    pub type_count: ecs_metric_t,
    #[doc = "< Number of times id has been created"]
    pub create_count: ecs_metric_t,
    #[doc = "< Number of times id has been deleted"]
    pub delete_count: ecs_metric_t,
}
#[doc = "Tables"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_3 {
    #[doc = "< Number of tables"]
    pub count: ecs_metric_t,
    #[doc = "< Number of empty tables"]
    pub empty_count: ecs_metric_t,
    #[doc = "< Number of tables with only tags"]
    pub tag_only_count: ecs_metric_t,
    #[doc = "< Number of tables with only trivial components"]
    pub trivial_only_count: ecs_metric_t,
    #[doc = "< Number of table cache records"]
    pub record_count: ecs_metric_t,
    #[doc = "< Number of table storages"]
    pub storage_count: ecs_metric_t,
    #[doc = "< Number of times table has been created"]
    pub create_count: ecs_metric_t,
    #[doc = "< Number of times table has been deleted"]
    pub delete_count: ecs_metric_t,
}
#[doc = "Queries & events"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_4 {
    #[doc = "< Number of queries"]
    pub query_count: ecs_metric_t,
    #[doc = "< Number of observers"]
    pub observer_count: ecs_metric_t,
    #[doc = "< Number of systems"]
    pub system_count: ecs_metric_t,
}
#[doc = "Commands"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_5 {
    pub add_count: ecs_metric_t,
    pub remove_count: ecs_metric_t,
    pub delete_count: ecs_metric_t,
    pub clear_count: ecs_metric_t,
    pub set_count: ecs_metric_t,
    pub get_mut_count: ecs_metric_t,
    pub modified_count: ecs_metric_t,
    pub other_count: ecs_metric_t,
    pub discard_count: ecs_metric_t,
    pub batched_entity_count: ecs_metric_t,
    pub batched_count: ecs_metric_t,
}
#[doc = "Frame data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_6 {
    #[doc = "< Number of frames processed."]
    pub frame_count: ecs_metric_t,
    #[doc = "< Number of merges executed."]
    pub merge_count: ecs_metric_t,
    #[doc = "< Number of query rematches"]
    pub rematch_count: ecs_metric_t,
    #[doc = "< Number of system pipeline rebuilds (occurs when an inactive system becomes active)."]
    pub pipeline_build_count: ecs_metric_t,
    #[doc = "< Number of systems ran."]
    pub systems_ran: ecs_metric_t,
    #[doc = "< Number of times an observer was invoked."]
    pub observers_ran: ecs_metric_t,
    #[doc = "< Number of events emitted"]
    pub event_emit_count: ecs_metric_t,
}
#[doc = "Timing"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_7 {
    #[doc = "< Actual time passed since simulation start (first time progress() is called)"]
    pub world_time_raw: ecs_metric_t,
    #[doc = "< Simulation time passed since simulation start. Takes into account time scaling"]
    pub world_time: ecs_metric_t,
    #[doc = "< Time spent processing a frame. Smaller than world_time_total when load is not 100%"]
    pub frame_time: ecs_metric_t,
    #[doc = "< Time spent on running systems."]
    pub system_time: ecs_metric_t,
    #[doc = "< Time spent on notifying observers."]
    pub emit_time: ecs_metric_t,
    #[doc = "< Time spent on merging commands."]
    pub merge_time: ecs_metric_t,
    #[doc = "< Time spent on rematching."]
    pub rematch_time: ecs_metric_t,
    #[doc = "< Frames per second."]
    pub fps: ecs_metric_t,
    #[doc = "< Delta_time."]
    pub delta_time: ecs_metric_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_8 {
    #[doc = "< Allocs per frame"]
    pub alloc_count: ecs_metric_t,
    #[doc = "< Reallocs per frame"]
    pub realloc_count: ecs_metric_t,
    #[doc = "< Frees per frame"]
    pub free_count: ecs_metric_t,
    #[doc = "< Difference between allocs & frees"]
    pub outstanding_alloc_count: ecs_metric_t,
    #[doc = "< Block allocations per frame"]
    pub block_alloc_count: ecs_metric_t,
    #[doc = "< Block frees per frame"]
    pub block_free_count: ecs_metric_t,
    #[doc = "< Difference between allocs & frees"]
    pub block_outstanding_alloc_count: ecs_metric_t,
    #[doc = "< Page allocations per frame"]
    pub stack_alloc_count: ecs_metric_t,
    #[doc = "< Page frees per frame"]
    pub stack_free_count: ecs_metric_t,
    #[doc = "< Difference between allocs & frees"]
    pub stack_outstanding_alloc_count: ecs_metric_t,
}
#[doc = "REST statistics"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_9 {
    pub request_count: ecs_metric_t,
    pub entity_count: ecs_metric_t,
    pub entity_error_count: ecs_metric_t,
    pub query_count: ecs_metric_t,
    pub query_error_count: ecs_metric_t,
    pub query_name_count: ecs_metric_t,
    pub query_name_error_count: ecs_metric_t,
    pub query_name_from_cache_count: ecs_metric_t,
    pub enable_count: ecs_metric_t,
    pub enable_error_count: ecs_metric_t,
    pub world_stats_count: ecs_metric_t,
    pub pipeline_stats_count: ecs_metric_t,
    pub stats_error_count: ecs_metric_t,
}
#[doc = "HTTP statistics"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_10 {
    pub request_received_count: ecs_metric_t,
    pub request_invalid_count: ecs_metric_t,
    pub request_handled_ok_count: ecs_metric_t,
    pub request_handled_error_count: ecs_metric_t,
    pub request_not_handled_count: ecs_metric_t,
    pub request_preflight_count: ecs_metric_t,
    pub send_ok_count: ecs_metric_t,
    pub send_error_count: ecs_metric_t,
    pub busy_count: ecs_metric_t,
}
#[doc = "Statistics for a single query (use ecs_query_stats_get)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_query_stats_t {
    pub first_: i64,
    #[doc = "< Matched non-empty tables"]
    pub matched_table_count: ecs_metric_t,
    #[doc = "< Matched empty tables"]
    pub matched_empty_table_count: ecs_metric_t,
    #[doc = "< Number of matched entities"]
    pub matched_entity_count: ecs_metric_t,
    pub last_: i64,
    #[doc = "Current position in ringbuffer"]
    pub t: i32,
}
#[doc = "Statistics for a single system (use ecs_system_stats_get)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_system_stats_t {
    pub first_: i64,
    #[doc = "< Time spent processing a system"]
    pub time_spent: ecs_metric_t,
    #[doc = "< Number of times system is invoked"]
    pub invoke_count: ecs_metric_t,
    #[doc = "< Whether system is active (is matched with >0 entities)"]
    pub active: ecs_metric_t,
    #[doc = "< Whether system is enabled"]
    pub enabled: ecs_metric_t,
    pub last_: i64,
    #[doc = "< Is system a task"]
    pub task: bool,
    pub query: ecs_query_stats_t,
}
#[doc = "Statistics for all systems in a pipeline."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_pipeline_stats_t {
    #[doc = "Allow for initializing struct with {0}"]
    pub canary_: i8,
    #[doc = "Vector with system ids of all systems in the pipeline. The systems are\n stored in the order they are executed. Merges are represented by a 0."]
    pub systems: ecs_vec_t,
    #[doc = "Map with system statistics. For each system in the systems vector, an\n entry in the map exists of type ecs_system_stats_t."]
    pub system_stats: ecs_map_t,
    #[doc = "Current position in ringbuffer"]
    pub t: i32,
    #[doc = "< Number of systems in pipeline"]
    pub system_count: i32,
    #[doc = "< Number of active systems in pipeline"]
    pub active_system_count: i32,
    #[doc = "< Number of times pipeline has rebuilt"]
    pub rebuild_count: i32,
}
extern "C" {
    #[doc = "Get world statistics.\n\n @param world The world.\n @param stats Out parameter for statistics."]
    pub fn ecs_world_stats_get(world: *const ecs_world_t, stats: *mut ecs_world_stats_t);
}
extern "C" {
    #[doc = "Reduce source measurement window into single destination measurement."]
    pub fn ecs_world_stats_reduce(dst: *mut ecs_world_stats_t, src: *const ecs_world_stats_t);
}
extern "C" {
    #[doc = "Reduce last measurement into previous measurement, restore old value."]
    pub fn ecs_world_stats_reduce_last(
        stats: *mut ecs_world_stats_t,
        old: *const ecs_world_stats_t,
        count: i32,
    );
}
extern "C" {
    #[doc = "Repeat last measurement."]
    pub fn ecs_world_stats_repeat_last(stats: *mut ecs_world_stats_t);
}
extern "C" {
    #[doc = "Copy last measurement from source to destination."]
    pub fn ecs_world_stats_copy_last(dst: *mut ecs_world_stats_t, src: *const ecs_world_stats_t);
}
extern "C" {
    pub fn ecs_world_stats_log(world: *const ecs_world_t, stats: *const ecs_world_stats_t);
}
extern "C" {
    #[doc = "Get query statistics.\n Obtain statistics for the provided query.\n\n @param world The world.\n @param query The query.\n @param stats Out parameter for statistics."]
    pub fn ecs_query_stats_get(
        world: *const ecs_world_t,
        query: *const ecs_query_t,
        stats: *mut ecs_query_stats_t,
    );
}
extern "C" {
    #[doc = "Reduce source measurement window into single destination measurement."]
    pub fn ecs_query_stats_reduce(dst: *mut ecs_query_stats_t, src: *const ecs_query_stats_t);
}
extern "C" {
    #[doc = "Reduce last measurement into previous measurement, restore old value."]
    pub fn ecs_query_stats_reduce_last(
        stats: *mut ecs_query_stats_t,
        old: *const ecs_query_stats_t,
        count: i32,
    );
}
extern "C" {
    #[doc = "Repeat last measurement."]
    pub fn ecs_query_stats_repeat_last(stats: *mut ecs_query_stats_t);
}
extern "C" {
    #[doc = "Copy last measurement from source to destination."]
    pub fn ecs_query_stats_copy_last(dst: *mut ecs_query_stats_t, src: *const ecs_query_stats_t);
}
extern "C" {
    #[doc = "Get system statistics.\n Obtain statistics for the provided system.\n\n @param world The world.\n @param system The system.\n @param stats Out parameter for statistics.\n @return true if success, false if not a system."]
    pub fn ecs_system_stats_get(
        world: *const ecs_world_t,
        system: ecs_entity_t,
        stats: *mut ecs_system_stats_t,
    ) -> bool;
}
extern "C" {
    #[doc = "Reduce source measurement window into single destination measurement"]
    pub fn ecs_system_stats_reduce(dst: *mut ecs_system_stats_t, src: *const ecs_system_stats_t);
}
extern "C" {
    #[doc = "Reduce last measurement into previous measurement, restore old value."]
    pub fn ecs_system_stats_reduce_last(
        stats: *mut ecs_system_stats_t,
        old: *const ecs_system_stats_t,
        count: i32,
    );
}
extern "C" {
    #[doc = "Repeat last measurement."]
    pub fn ecs_system_stats_repeat_last(stats: *mut ecs_system_stats_t);
}
extern "C" {
    #[doc = "Copy last measurement from source to destination."]
    pub fn ecs_system_stats_copy_last(dst: *mut ecs_system_stats_t, src: *const ecs_system_stats_t);
}
extern "C" {
    #[doc = "Get pipeline statistics.\n Obtain statistics for the provided pipeline.\n\n @param world The world.\n @param pipeline The pipeline.\n @param stats Out parameter for statistics.\n @return true if success, false if not a pipeline."]
    pub fn ecs_pipeline_stats_get(
        world: *mut ecs_world_t,
        pipeline: ecs_entity_t,
        stats: *mut ecs_pipeline_stats_t,
    ) -> bool;
}
extern "C" {
    #[doc = "Free pipeline stats.\n\n @param stats The stats to free."]
    pub fn ecs_pipeline_stats_fini(stats: *mut ecs_pipeline_stats_t);
}
extern "C" {
    #[doc = "Reduce source measurement window into single destination measurement"]
    pub fn ecs_pipeline_stats_reduce(
        dst: *mut ecs_pipeline_stats_t,
        src: *const ecs_pipeline_stats_t,
    );
}
extern "C" {
    #[doc = "Reduce last measurement into previous measurement, restore old value."]
    pub fn ecs_pipeline_stats_reduce_last(
        stats: *mut ecs_pipeline_stats_t,
        old: *const ecs_pipeline_stats_t,
        count: i32,
    );
}
extern "C" {
    #[doc = "Repeat last measurement."]
    pub fn ecs_pipeline_stats_repeat_last(stats: *mut ecs_pipeline_stats_t);
}
extern "C" {
    #[doc = "Copy last measurement to destination.\n This operation copies the last measurement into the destination. It does not\n modify the cursor.\n\n @param dst The metrics.\n @param src The metrics to copy."]
    pub fn ecs_pipeline_stats_copy_last(
        dst: *mut ecs_pipeline_stats_t,
        src: *const ecs_pipeline_stats_t,
    );
}
extern "C" {
    #[doc = "Reduce all measurements from a window into a single measurement."]
    pub fn ecs_metric_reduce(
        dst: *mut ecs_metric_t,
        src: *const ecs_metric_t,
        t_dst: i32,
        t_src: i32,
    );
}
extern "C" {
    #[doc = "Reduce last measurement into previous measurement"]
    pub fn ecs_metric_reduce_last(m: *mut ecs_metric_t, t: i32, count: i32);
}
extern "C" {
    #[doc = "Copy measurement"]
    pub fn ecs_metric_copy(m: *mut ecs_metric_t, dst: i32, src: i32);
}
extern "C" {
    pub static mut FLECS__EFlecsMetrics: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMetric: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMetric: ecs_entity_t;
}
extern "C" {
    pub static mut EcsCounter: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsCounter: ecs_entity_t;
}
extern "C" {
    pub static mut EcsCounterIncrement: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsCounterIncrement: ecs_entity_t;
}
extern "C" {
    pub static mut EcsCounterId: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsCounterId: ecs_entity_t;
}
extern "C" {
    pub static mut EcsGauge: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsGauge: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMetricInstance: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMetricValue: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMetricSource: ecs_entity_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsMetricValue {
    pub value: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsMetricSource {
    pub entity: ecs_entity_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_metric_desc_t {
    pub _canary: i32,
    #[doc = "Entity associated with metric"]
    pub entity: ecs_entity_t,
    #[doc = "Entity associated with member that stores metric value. Must not be set\n at the same time as id. Cannot be combined with EcsCounterId."]
    pub member: ecs_entity_t,
    #[doc = "Tracks whether entities have the specified component id. Must not be set\n at the same time as member."]
    pub id: ecs_id_t,
    #[doc = "If id is a (R, *) wildcard and relationship R has the OneOf property,\n setting this value to true will track individual targets.\n If the kind is EcsCountId and the id is a (R, *) wildcard, this value\n will create a metric per target."]
    pub targets: bool,
    #[doc = "Must be EcsGauge, EcsCounter, EcsCounterIncrement or EcsCounterId"]
    pub kind: ecs_entity_t,
    #[doc = "Description of metric. Will only be set if FLECS_DOC addon is enabled"]
    pub brief: *const ::std::os::raw::c_char,
}
extern "C" {
    #[doc = "Create a new metric.\n Metrics are entities that store values measured from a range of different\n properties in the ECS storage. Metrics provide a single unified interface to\n discovering and reading these values, which can be useful for monitoring\n utilities, or for debugging.\n\n Examples of properties that can be measured by metrics are:\n  - Component member values\n  - How long an entity has had a specific component\n  - How long an entity has had a specific target for a relationship\n  - How many entities have a specific component\n\n Metrics can either be created as a \"gauge\" or \"counter\". A gauge is a metric\n that represents the value of something at a specific point in time, for\n example \"velocity\". A counter metric represents a value that is monotonically\n increasing, for example \"miles driven\".\n\n There are three different kinds of counter metric kinds:\n - EcsCounter\n   When combined with a member, this will store the actual value of the member\n   in the metric. This is useful for values that are already counters, such as\n   a MilesDriven component.\n   This kind creates a metric per entity that has the member/id.\n\n - EcsCounterIncrement\n   When combined with a member, this will increment the value of the metric by\n   the value of the member * delta_time. This is useful for values that are\n   not counters, such as a Velocity component.\n   This kind creates a metric per entity that has the member.\n\n - EcsCounterId\n   This metric kind will count the number of entities with a specific\n   (component) id. This kind creates a single metric instance for regular ids,\n   and a metric instance per target for wildcard ids when targets is set.\n\n @param world The world.\n @param desc Metric description.\n @return The metric entity."]
    pub fn ecs_metric_init(world: *mut ecs_world_t, desc: *const ecs_metric_desc_t)
        -> ecs_entity_t;
}
extern "C" {
    #[doc = "Module import"]
    pub fn FlecsMetricsImport(world: *mut ecs_world_t);
}
extern "C" {
    pub static mut FLECS__EFlecsAlerts: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsAlert: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsAlertInstance: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsAlertsActive: ecs_entity_t;
}
extern "C" {
    pub static mut EcsAlertInfo: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsAlertInfo: ecs_entity_t;
}
extern "C" {
    pub static mut EcsAlertWarning: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsAlertWarning: ecs_entity_t;
}
extern "C" {
    pub static mut EcsAlertError: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsAlertError: ecs_entity_t;
}
extern "C" {
    pub static mut EcsAlertCritical: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsAlertCritical: ecs_entity_t;
}
#[doc = "Alert information. Added to each alert instance"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsAlertInstance {
    pub message: *mut ::std::os::raw::c_char,
}
#[doc = "Map with active alerts for entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsAlertsActive {
    pub alerts: ecs_map_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_alert_desc_t {
    pub _canary: i32,
    #[doc = "Entity associated with alert"]
    pub entity: ecs_entity_t,
    #[doc = "Alert query. An alert will be created for each entity that matches the\n specified query. The query must have at least one term that uses the\n $this variable (default)."]
    pub filter: ecs_filter_desc_t,
    #[doc = "Template for alert message. This string is used to generate the alert\n message and may refer to variables in the query result. The format for\n the template expressions is as specified by ecs_interpolate_string.\n\n Examples:\n   \"$this has Position but not Velocity\"\n   \"$this has a parent entity $parent without Position\""]
    pub message: *const ::std::os::raw::c_char,
    #[doc = "Description of metric. Will only be set if FLECS_DOC addon is enabled"]
    pub brief: *const ::std::os::raw::c_char,
    #[doc = "Metric kind. Must be EcsAlertInfo, EcsAlertWarning, EcsAlertError or\n EcsAlertCritical. Defaults to EcsAlertError."]
    pub severity: ecs_entity_t,
}
extern "C" {
    #[doc = "Create a new alert.\n An alert is a query that is evaluated periodically and creates alert\n instances for each entity that matches the query. Alerts can be used to\n automate detection of errors in an application.\n\n Alerts are automatically cleared when a query is no longer true for an alert\n instance. At most one alert instance will be created per matched entity.\n\n Alert instances have three components:\n - AlertInstance: contains the alert message for the instance\n - MetricSource: contains the entity that triggered the alert\n - MetricValue: contains how long the alert has been active\n\n Alerts reuse components from the metrics addon so that alert instances can be\n tracked and discovered as metrics. Just like metrics, alert instances are\n created as children of the alert.\n\n When an entity has active alerts, it will have the EcsAlertsActive component\n which contains a map with active alerts for the entity. This component\n will be automatically removed once all alerts are cleared for the entity.\n\n @param world The world.\n @param desc Alert description.\n @return The alert entity."]
    pub fn ecs_alert_init(world: *mut ecs_world_t, desc: *const ecs_alert_desc_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Return number of active alerts for entity.\n When a valid alert entity is specified for the alert parameter, the operation\n will return whether the specified alert is active for the entity. When no\n alert is specified, the operation will return the total number of active\n alerts for the entity.\n\n @param world The world.\n @param entity The entity.\n @param alert The alert to test for (optional).\n @return The number of active alerts for the entity."]
    pub fn ecs_get_alert_count(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        alert: ecs_entity_t,
    ) -> i32;
}
extern "C" {
    #[doc = "Return alert instance for specified alert.\n This operation returns the alert instance for the specified alert. If the\n alert is not active for the entity, the operation will return 0.\n\n @param world The world.\n @param entity The entity.\n @param alert The alert to test for.\n @return The alert instance for the specified alert."]
    pub fn ecs_get_alert(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        alert: ecs_entity_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Module import"]
    pub fn FlecsAlertsImport(world: *mut ecs_world_t);
}
extern "C" {
    pub static mut FLECS__EFlecsMonitor: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsWorldStats: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsPipelineStats: ecs_entity_t;
}
extern "C" {
    pub static mut EcsPeriod1s: ecs_entity_t;
}
extern "C" {
    pub static mut EcsPeriod1m: ecs_entity_t;
}
extern "C" {
    pub static mut EcsPeriod1h: ecs_entity_t;
}
extern "C" {
    pub static mut EcsPeriod1d: ecs_entity_t;
}
extern "C" {
    pub static mut EcsPeriod1w: ecs_entity_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsStatsHeader {
    pub elapsed: f32,
    pub reduce_count: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EcsWorldStats {
    pub hdr: EcsStatsHeader,
    pub stats: ecs_world_stats_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsPipelineStats {
    pub hdr: EcsStatsHeader,
    pub stats: ecs_pipeline_stats_t,
}
extern "C" {
    #[doc = "Module import"]
    pub fn FlecsMonitorImport(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = "Module import"]
    pub fn FlecsCoreDocImport(world: *mut ecs_world_t);
}
extern "C" {
    pub static FLECS__EEcsDocDescription: ecs_entity_t;
}
extern "C" {
    pub static EcsDocBrief: ecs_entity_t;
}
extern "C" {
    pub static EcsDocDetail: ecs_entity_t;
}
extern "C" {
    pub static EcsDocLink: ecs_entity_t;
}
extern "C" {
    pub static EcsDocColor: ecs_entity_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsDocDescription {
    pub value: *mut ::std::os::raw::c_char,
}
extern "C" {
    #[doc = "Add human-readable name to entity.\n Contrary to entity names, human readable names do not have to be unique and\n can contain special characters used in the query language like '*'.\n\n @param world The world.\n @param entity The entity to which to add the name.\n @param name The name to add."]
    pub fn ecs_doc_set_name(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "Add brief description to entity.\n\n @param world The world.\n @param entity The entity to which to add the description.\n @param description The description to add."]
    pub fn ecs_doc_set_brief(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        description: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "Add detailed description to entity.\n\n @param world The world.\n @param entity The entity to which to add the description.\n @param description The description to add."]
    pub fn ecs_doc_set_detail(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        description: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "Add link to external documentation to entity.\n\n @param world The world.\n @param entity The entity to which to add the link.\n @param link The link to add."]
    pub fn ecs_doc_set_link(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        link: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "Add color to entity.\n UIs can use color as hint to improve visualizing entities.\n\n @param world The world.\n @param entity The entity to which to add the link.\n @param color The color to add."]
    pub fn ecs_doc_set_color(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        color: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "Get human readable name from entity.\n If entity does not have an explicit human readable name, this operation will\n return the entity name.\n\n To test if an entity has a human readable name, use:\n   ecs_has_pair(world, e, ecs_id(EcsDescription), EcsName);\n Or in C++:\n   e.has<flecs::Description>(flecs::Name);\n\n @param world The world.\n @param entity The entity from which to get the name.\n @return The name."]
    pub fn ecs_doc_get_name(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Get brief description from entity.\n\n @param world The world.\n @param entity The entity from which to get the description.\n @return The description."]
    pub fn ecs_doc_get_brief(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Get detailed description from entity.\n\n @param world The world.\n @param entity The entity from which to get the description.\n @return The description."]
    pub fn ecs_doc_get_detail(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Get link to external documentation from entity.\n\n @param world The world.\n @param entity The entity from which to get the link.\n @return The link."]
    pub fn ecs_doc_get_link(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Get color from entity.\n\n @param world The world.\n @param entity The entity from which to get the link.\n @return The color."]
    pub fn ecs_doc_get_color(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Module import"]
    pub fn FlecsDocImport(world: *mut ecs_world_t);
}
#[doc = "Used with ecs_ptr_from_json, ecs_entity_from_json."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_from_json_desc_t {
    #[doc = "Name of expression (used for logging)"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "Full expression (used for logging)"]
    pub expr: *const ::std::os::raw::c_char,
    pub lookup_action: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ecs_world_t,
            value: *const ::std::os::raw::c_char,
            ctx: *mut ::std::os::raw::c_void,
        ) -> ecs_entity_t,
    >,
    pub lookup_ctx: *mut ::std::os::raw::c_void,
}
extern "C" {
    #[doc = "Parse JSON string into value.\n This operation parses a JSON expression into the provided pointer. The\n memory pointed to must be large enough to contain a value of the used type.\n\n @param world The world.\n @param type The type of the expression to parse.\n @param ptr Pointer to the memory to write to.\n @param json The JSON expression to parse.\n @param desc Configuration parameters for deserializer.\n @return Pointer to the character after the last one read, or NULL if failed."]
    pub fn ecs_ptr_from_json(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        ptr: *mut ::std::os::raw::c_void,
        json: *const ::std::os::raw::c_char,
        desc: *const ecs_from_json_desc_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Parse JSON object with multiple component values into entity. The format\n is the same as the one outputted by ecs_entity_to_json, but at the moment\n only supports the \"ids\" and \"values\" member.\n\n @param world The world.\n @param entity The entity to serialize to.\n @param json The JSON expression to parse (see entity in JSON format manual).\n @param desc Configuration parameters for deserializer.\n @return Pointer to the character after the last one read, or NULL if failed."]
    pub fn ecs_entity_from_json(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        json: *const ::std::os::raw::c_char,
        desc: *const ecs_from_json_desc_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Parse JSON object with multiple entities into the world. The format is the\n same as the one outputted by ecs_world_to_json.\n\n @param world The world.\n @param json The JSON expression to parse (see iterator in JSON format manual)."]
    pub fn ecs_world_from_json(
        world: *mut ecs_world_t,
        json: *const ::std::os::raw::c_char,
        desc: *const ecs_from_json_desc_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Serialize array into JSON string.\n This operation serializes a value of the provided type to a JSON string. The\n memory pointed to must be large enough to contain a value of the used type.\n\n If count is 0, the function will serialize a single value, not wrapped in\n array brackets. If count is >= 1, the operation will serialize values to a\n a comma-separated list inside of array brackets.\n\n @param world The world.\n @param type The type of the value to serialize.\n @param data The value to serialize.\n @param count The number of elements to serialize.\n @return String with JSON expression, or NULL if failed."]
    pub fn ecs_array_to_json(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        data: *const ::std::os::raw::c_void,
        count: i32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Serialize array into JSON string buffer.\n Same as ecs_array_to_json_buf, but serializes to an ecs_strbuf_t instance.\n\n @param world The world.\n @param type The type of the value to serialize.\n @param data The value to serialize.\n @param count The number of elements to serialize.\n @param buf_out The strbuf to append the string to.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_array_to_json_buf(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        data: *const ::std::os::raw::c_void,
        count: i32,
        buf_out: *mut ecs_strbuf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Serialize value into JSON string.\n Same as ecs_array_to_json, with count = 0.\n\n @param world The world.\n @param type The type of the value to serialize.\n @param data The value to serialize.\n @return String with JSON expression, or NULL if failed."]
    pub fn ecs_ptr_to_json(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Serialize value into JSON string buffer.\n Same as ecs_ptr_to_json, but serializes to an ecs_strbuf_t instance.\n\n @param world The world.\n @param type The type of the value to serialize.\n @param data The value to serialize.\n @param buf_out The strbuf to append the string to.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_ptr_to_json_buf(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        data: *const ::std::os::raw::c_void,
        buf_out: *mut ecs_strbuf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Serialize type info to JSON.\n This serializes type information to JSON, and can be used to store/transmit\n the structure of a (component) value.\n\n If the provided type does not have reflection data, \"0\" will be returned.\n\n @param world The world.\n @param type The type to serialize to JSON.\n @return A JSON string with the serialized type info, or NULL if failed."]
    pub fn ecs_type_info_to_json(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Serialize type info into JSON string buffer.\n Same as ecs_type_info_to_json, but serializes to an ecs_strbuf_t instance.\n\n @param world The world.\n @param type The type to serialize.\n @param buf_out The strbuf to append the string to.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_type_info_to_json_buf(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        buf_out: *mut ecs_strbuf_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = "Used with ecs_iter_to_json."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_entity_to_json_desc_t {
    #[doc = "< Serialize full pathname"]
    pub serialize_path: bool,
    #[doc = "< Serialize 'meta' ids (Name, ChildOf, etc)"]
    pub serialize_meta_ids: bool,
    #[doc = "< Serialize doc name"]
    pub serialize_label: bool,
    #[doc = "< Serialize brief doc description"]
    pub serialize_brief: bool,
    #[doc = "< Serialize doc link (URL)"]
    pub serialize_link: bool,
    #[doc = "< Serialize doc color"]
    pub serialize_color: bool,
    #[doc = "< Serialize labels of (component) ids"]
    pub serialize_id_labels: bool,
    #[doc = "< Serialize base components"]
    pub serialize_base: bool,
    #[doc = "< Serialize private components"]
    pub serialize_private: bool,
    #[doc = "< Serialize ids hidden by override"]
    pub serialize_hidden: bool,
    #[doc = "< Serialize component values"]
    pub serialize_values: bool,
    #[doc = "< Serialize type info (requires serialize_values)"]
    pub serialize_type_info: bool,
    #[doc = "< Serialize active alerts for entity"]
    pub serialize_alerts: bool,
}
extern "C" {
    #[doc = "Serialize entity into JSON string.\n This creates a JSON object with the entity's (path) name, which components\n and tags the entity has, and the component values.\n\n The operation may fail if the entity contains components with invalid values.\n\n @param world The world.\n @param entity The entity to serialize to JSON.\n @return A JSON string with the serialized entity data, or NULL if failed."]
    pub fn ecs_entity_to_json(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        desc: *const ecs_entity_to_json_desc_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Serialize entity into JSON string buffer.\n Same as ecs_entity_to_json, but serializes to an ecs_strbuf_t instance.\n\n @param world The world.\n @param entity The entity to serialize.\n @param buf_out The strbuf to append the string to.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_entity_to_json_buf(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        buf_out: *mut ecs_strbuf_t,
        desc: *const ecs_entity_to_json_desc_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = "Used with ecs_iter_to_json."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_iter_to_json_desc_t {
    #[doc = "< Serialize term (query) component ids"]
    pub serialize_term_ids: bool,
    #[doc = "< Serialize actual (matched) component ids"]
    pub serialize_ids: bool,
    #[doc = "< Serialize sources"]
    pub serialize_sources: bool,
    #[doc = "< Serialize variables"]
    pub serialize_variables: bool,
    #[doc = "< Serialize is_set (for optional terms)"]
    pub serialize_is_set: bool,
    #[doc = "< Serialize component values"]
    pub serialize_values: bool,
    #[doc = "< Serialize entities (for This terms)"]
    pub serialize_entities: bool,
    #[doc = "< Serialize doc name for entities"]
    pub serialize_entity_labels: bool,
    #[doc = "< Serialize numerical ids for entities"]
    pub serialize_entity_ids: bool,
    #[doc = "< Serialize names (not paths) for entities"]
    pub serialize_entity_names: bool,
    #[doc = "< Serialize doc name for variables"]
    pub serialize_variable_labels: bool,
    #[doc = "< Serialize numerical ids for variables"]
    pub serialize_variable_ids: bool,
    #[doc = "< Serialize doc color for entities"]
    pub serialize_colors: bool,
    #[doc = "< Serialize evaluation duration"]
    pub measure_eval_duration: bool,
    #[doc = "< Serialize type information"]
    pub serialize_type_info: bool,
    #[doc = "< Serialize entire table vs. matched components"]
    pub serialize_table: bool,
}
extern "C" {
    #[doc = "Serialize iterator into JSON string.\n This operation will iterate the contents of the iterator and serialize them\n to JSON. The function acccepts iterators from any source.\n\n @param world The world.\n @param iter The iterator to serialize to JSON.\n @return A JSON string with the serialized iterator data, or NULL if failed."]
    pub fn ecs_iter_to_json(
        world: *const ecs_world_t,
        iter: *mut ecs_iter_t,
        desc: *const ecs_iter_to_json_desc_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Serialize iterator into JSON string buffer.\n Same as ecs_iter_to_json, but serializes to an ecs_strbuf_t instance.\n\n @param world The world.\n @param iter The iterator to serialize.\n @param buf_out The strbuf to append the string to.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_iter_to_json_buf(
        world: *const ecs_world_t,
        iter: *mut ecs_iter_t,
        buf_out: *mut ecs_strbuf_t,
        desc: *const ecs_iter_to_json_desc_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = "Used with ecs_iter_to_json."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_world_to_json_desc_t {
    #[doc = "Exclude flecs modules & contents"]
    pub serialize_builtin: bool,
    #[doc = "Exclude modules & contents"]
    pub serialize_modules: bool,
}
extern "C" {
    #[doc = "Serialize world into JSON string.\n This operation iterates the contents of the world to JSON. The operation is\n equivalent to the following code:\n\n ecs_filter_t *f = ecs_filter(world, {\n   .terms = {{ .id = EcsAny }}\n });\n\n ecs_iter_t it = ecs_filter_init(world, &f);\n ecs_iter_to_json_desc_t desc = { .serialize_table = true };\n ecs_iter_to_json(world, iter, &desc);\n\n @param world The world to serialize.\n @return A JSON string with the serialized iterator data, or NULL if failed."]
    pub fn ecs_world_to_json(
        world: *mut ecs_world_t,
        desc: *const ecs_world_to_json_desc_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Serialize world into JSON string buffer.\n Same as ecs_world_to_json, but serializes to an ecs_strbuf_t instance.\n\n @param world The world to serialize.\n @param buf_out The strbuf to append the string to.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_world_to_json_buf(
        world: *mut ecs_world_t,
        buf_out: *mut ecs_strbuf_t,
        desc: *const ecs_world_to_json_desc_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut EcsUnitPrefixes: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsUnitPrefixes: ecs_entity_t;
}
extern "C" {
    pub static mut EcsYocto: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsYocto: ecs_entity_t;
}
extern "C" {
    pub static mut EcsZepto: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsZepto: ecs_entity_t;
}
extern "C" {
    pub static mut EcsAtto: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsAtto: ecs_entity_t;
}
extern "C" {
    pub static mut EcsFemto: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsFemto: ecs_entity_t;
}
extern "C" {
    pub static mut EcsPico: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsPico: ecs_entity_t;
}
extern "C" {
    pub static mut EcsNano: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsNano: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMicro: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMicro: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMilli: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMilli: ecs_entity_t;
}
extern "C" {
    pub static mut EcsCenti: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsCenti: ecs_entity_t;
}
extern "C" {
    pub static mut EcsDeci: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsDeci: ecs_entity_t;
}
extern "C" {
    pub static mut EcsDeca: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsDeca: ecs_entity_t;
}
extern "C" {
    pub static mut EcsHecto: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsHecto: ecs_entity_t;
}
extern "C" {
    pub static mut EcsKilo: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsKilo: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMega: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMega: ecs_entity_t;
}
extern "C" {
    pub static mut EcsGiga: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsGiga: ecs_entity_t;
}
extern "C" {
    pub static mut EcsTera: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsTera: ecs_entity_t;
}
extern "C" {
    pub static mut EcsPeta: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsPeta: ecs_entity_t;
}
extern "C" {
    pub static mut EcsExa: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsExa: ecs_entity_t;
}
extern "C" {
    pub static mut EcsZetta: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsZetta: ecs_entity_t;
}
extern "C" {
    pub static mut EcsYotta: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsYotta: ecs_entity_t;
}
extern "C" {
    pub static mut EcsKibi: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsKibi: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMebi: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMebi: ecs_entity_t;
}
extern "C" {
    pub static mut EcsGibi: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsGibi: ecs_entity_t;
}
extern "C" {
    pub static mut EcsTebi: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsTebi: ecs_entity_t;
}
extern "C" {
    pub static mut EcsPebi: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsPebi: ecs_entity_t;
}
extern "C" {
    pub static mut EcsExbi: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsExbi: ecs_entity_t;
}
extern "C" {
    pub static mut EcsZebi: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsZebi: ecs_entity_t;
}
extern "C" {
    pub static mut EcsYobi: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsYobi: ecs_entity_t;
}
extern "C" {
    pub static mut EcsDuration: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsDuration: ecs_entity_t;
}
extern "C" {
    pub static mut EcsPicoSeconds: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsPicoSeconds: ecs_entity_t;
}
extern "C" {
    pub static mut EcsNanoSeconds: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsNanoSeconds: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMicroSeconds: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMicroSeconds: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMilliSeconds: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMilliSeconds: ecs_entity_t;
}
extern "C" {
    pub static mut EcsSeconds: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsSeconds: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMinutes: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMinutes: ecs_entity_t;
}
extern "C" {
    pub static mut EcsHours: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsHours: ecs_entity_t;
}
extern "C" {
    pub static mut EcsDays: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsDays: ecs_entity_t;
}
extern "C" {
    pub static mut EcsTime: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsTime: ecs_entity_t;
}
extern "C" {
    pub static mut EcsDate: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsDate: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMass: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMass: ecs_entity_t;
}
extern "C" {
    pub static mut EcsGrams: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsGrams: ecs_entity_t;
}
extern "C" {
    pub static mut EcsKiloGrams: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsKiloGrams: ecs_entity_t;
}
extern "C" {
    pub static mut EcsElectricCurrent: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsElectricCurrent: ecs_entity_t;
}
extern "C" {
    pub static mut EcsAmpere: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsAmpere: ecs_entity_t;
}
extern "C" {
    pub static mut EcsAmount: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsAmount: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMole: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMole: ecs_entity_t;
}
extern "C" {
    pub static mut EcsLuminousIntensity: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsLuminousIntensity: ecs_entity_t;
}
extern "C" {
    pub static mut EcsCandela: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsCandela: ecs_entity_t;
}
extern "C" {
    pub static mut EcsForce: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsForce: ecs_entity_t;
}
extern "C" {
    pub static mut EcsNewton: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsNewton: ecs_entity_t;
}
extern "C" {
    pub static mut EcsLength: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsLength: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMeters: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMeters: ecs_entity_t;
}
extern "C" {
    pub static mut EcsPicoMeters: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsPicoMeters: ecs_entity_t;
}
extern "C" {
    pub static mut EcsNanoMeters: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsNanoMeters: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMicroMeters: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMicroMeters: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMilliMeters: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMilliMeters: ecs_entity_t;
}
extern "C" {
    pub static mut EcsCentiMeters: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsCentiMeters: ecs_entity_t;
}
extern "C" {
    pub static mut EcsKiloMeters: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsKiloMeters: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMiles: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMiles: ecs_entity_t;
}
extern "C" {
    pub static mut EcsPixels: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsPixels: ecs_entity_t;
}
extern "C" {
    pub static mut EcsPressure: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsPressure: ecs_entity_t;
}
extern "C" {
    pub static mut EcsPascal: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsPascal: ecs_entity_t;
}
extern "C" {
    pub static mut EcsBar: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsBar: ecs_entity_t;
}
extern "C" {
    pub static mut EcsSpeed: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsSpeed: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMetersPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMetersPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut EcsKiloMetersPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsKiloMetersPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut EcsKiloMetersPerHour: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsKiloMetersPerHour: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMilesPerHour: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMilesPerHour: ecs_entity_t;
}
extern "C" {
    pub static mut EcsTemperature: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsTemperature: ecs_entity_t;
}
extern "C" {
    pub static mut EcsKelvin: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsKelvin: ecs_entity_t;
}
extern "C" {
    pub static mut EcsCelsius: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsCelsius: ecs_entity_t;
}
extern "C" {
    pub static mut EcsFahrenheit: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsFahrenheit: ecs_entity_t;
}
extern "C" {
    pub static mut EcsData: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsData: ecs_entity_t;
}
extern "C" {
    pub static mut EcsBits: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsBits: ecs_entity_t;
}
extern "C" {
    pub static mut EcsKiloBits: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsKiloBits: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMegaBits: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMegaBits: ecs_entity_t;
}
extern "C" {
    pub static mut EcsGigaBits: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsGigaBits: ecs_entity_t;
}
extern "C" {
    pub static mut EcsBytes: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsBytes: ecs_entity_t;
}
extern "C" {
    pub static mut EcsKiloBytes: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsKiloBytes: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMegaBytes: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMegaBytes: ecs_entity_t;
}
extern "C" {
    pub static mut EcsGigaBytes: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsGigaBytes: ecs_entity_t;
}
extern "C" {
    pub static mut EcsKibiBytes: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsKibiBytes: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMebiBytes: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMebiBytes: ecs_entity_t;
}
extern "C" {
    pub static mut EcsGibiBytes: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsGibiBytes: ecs_entity_t;
}
extern "C" {
    pub static mut EcsDataRate: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsDataRate: ecs_entity_t;
}
extern "C" {
    pub static mut EcsBitsPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsBitsPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut EcsKiloBitsPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsKiloBitsPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMegaBitsPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMegaBitsPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut EcsGigaBitsPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsGigaBitsPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut EcsBytesPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsBytesPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut EcsKiloBytesPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsKiloBytesPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMegaBytesPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMegaBytesPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut EcsGigaBytesPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsGigaBytesPerSecond: ecs_entity_t;
}
extern "C" {
    pub static mut EcsAngle: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsAngle: ecs_entity_t;
}
extern "C" {
    pub static mut EcsRadians: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsRadians: ecs_entity_t;
}
extern "C" {
    pub static mut EcsDegrees: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsDegrees: ecs_entity_t;
}
extern "C" {
    pub static mut EcsFrequency: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsFrequency: ecs_entity_t;
}
extern "C" {
    pub static mut EcsHertz: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsHertz: ecs_entity_t;
}
extern "C" {
    pub static mut EcsKiloHertz: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsKiloHertz: ecs_entity_t;
}
extern "C" {
    pub static mut EcsMegaHertz: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsMegaHertz: ecs_entity_t;
}
extern "C" {
    pub static mut EcsGigaHertz: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsGigaHertz: ecs_entity_t;
}
extern "C" {
    pub static mut EcsUri: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsUri: ecs_entity_t;
}
extern "C" {
    pub static mut EcsUriHyperlink: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsUriHyperlink: ecs_entity_t;
}
extern "C" {
    pub static mut EcsUriImage: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsUriImage: ecs_entity_t;
}
extern "C" {
    pub static mut EcsUriFile: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsUriFile: ecs_entity_t;
}
extern "C" {
    pub static mut EcsAcceleration: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsAcceleration: ecs_entity_t;
}
extern "C" {
    pub static mut EcsPercentage: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsPercentage: ecs_entity_t;
}
extern "C" {
    pub static mut EcsBel: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsBel: ecs_entity_t;
}
extern "C" {
    pub static mut EcsDeciBel: ecs_entity_t;
}
extern "C" {
    pub static mut FLECS__EEcsDeciBel: ecs_entity_t;
}
extern "C" {
    #[doc = "Module"]
    pub fn FlecsUnitsImport(world: *mut ecs_world_t);
}
#[doc = "Primitive type definitions.\n These typedefs allow the builtin primitives to be used as regular components:\n   ecs_set(world, e, ecs_i32_t, {10});\n\n Or a more useful example (create an enum constant with a manual value):\n   ecs_set_pair_object(world, e, EcsConstant, ecs_i32_t, {10});"]
pub type ecs_bool_t = bool;
pub type ecs_char_t = ::std::os::raw::c_char;
pub type ecs_byte_t = ::std::os::raw::c_uchar;
pub type ecs_u8_t = u8;
pub type ecs_u16_t = u16;
pub type ecs_u32_t = u32;
pub type ecs_u64_t = u64;
pub type ecs_uptr_t = usize;
pub type ecs_i8_t = i8;
pub type ecs_i16_t = i16;
pub type ecs_i32_t = i32;
pub type ecs_i64_t = i64;
pub type ecs_iptr_t = isize;
pub type ecs_f32_t = f32;
pub type ecs_f64_t = f64;
pub type ecs_string_t = *mut ::std::os::raw::c_char;
extern "C" {
    pub static FLECS__EEcsMetaType: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsMetaTypeSerialized: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsPrimitive: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsEnum: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsBitmask: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsMember: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsStruct: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsArray: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsVector: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsOpaque: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsUnit: ecs_entity_t;
}
extern "C" {
    pub static FLECS__EEcsUnitPrefix: ecs_entity_t;
}
extern "C" {
    pub static EcsConstant: ecs_entity_t;
}
extern "C" {
    pub static EcsQuantity: ecs_entity_t;
}
extern "C" {
    pub static FLECS__Eecs_bool_t: ecs_entity_t;
}
extern "C" {
    pub static FLECS__Eecs_char_t: ecs_entity_t;
}
extern "C" {
    pub static FLECS__Eecs_byte_t: ecs_entity_t;
}
extern "C" {
    pub static FLECS__Eecs_u8_t: ecs_entity_t;
}
extern "C" {
    pub static FLECS__Eecs_u16_t: ecs_entity_t;
}
extern "C" {
    pub static FLECS__Eecs_u32_t: ecs_entity_t;
}
extern "C" {
    pub static FLECS__Eecs_u64_t: ecs_entity_t;
}
extern "C" {
    pub static FLECS__Eecs_uptr_t: ecs_entity_t;
}
extern "C" {
    pub static FLECS__Eecs_i8_t: ecs_entity_t;
}
extern "C" {
    pub static FLECS__Eecs_i16_t: ecs_entity_t;
}
extern "C" {
    pub static FLECS__Eecs_i32_t: ecs_entity_t;
}
extern "C" {
    pub static FLECS__Eecs_i64_t: ecs_entity_t;
}
extern "C" {
    pub static FLECS__Eecs_iptr_t: ecs_entity_t;
}
extern "C" {
    pub static FLECS__Eecs_f32_t: ecs_entity_t;
}
extern "C" {
    pub static FLECS__Eecs_f64_t: ecs_entity_t;
}
extern "C" {
    pub static FLECS__Eecs_string_t: ecs_entity_t;
}
extern "C" {
    pub static FLECS__Eecs_entity_t: ecs_entity_t;
}
pub const ecs_type_kind_t_EcsPrimitiveType: ecs_type_kind_t = 0;
pub const ecs_type_kind_t_EcsBitmaskType: ecs_type_kind_t = 1;
pub const ecs_type_kind_t_EcsEnumType: ecs_type_kind_t = 2;
pub const ecs_type_kind_t_EcsStructType: ecs_type_kind_t = 3;
pub const ecs_type_kind_t_EcsArrayType: ecs_type_kind_t = 4;
pub const ecs_type_kind_t_EcsVectorType: ecs_type_kind_t = 5;
pub const ecs_type_kind_t_EcsOpaqueType: ecs_type_kind_t = 6;
pub const ecs_type_kind_t_EcsTypeKindLast: ecs_type_kind_t = 6;
#[doc = "Type kinds supported by reflection type system"]
pub type ecs_type_kind_t = ::std::os::raw::c_int;
#[doc = "Component that is automatically added to every type with the right kind."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsMetaType {
    pub kind: ecs_type_kind_t,
    #[doc = "< Did the type exist or is it populated from reflection"]
    pub existing: bool,
    #[doc = "< Is the reflection data a partial type description"]
    pub partial: bool,
    #[doc = "< Computed size"]
    pub size: ecs_size_t,
    #[doc = "< Computed alignment"]
    pub alignment: ecs_size_t,
}
pub const ecs_primitive_kind_t_EcsBool: ecs_primitive_kind_t = 1;
pub const ecs_primitive_kind_t_EcsChar: ecs_primitive_kind_t = 2;
pub const ecs_primitive_kind_t_EcsByte: ecs_primitive_kind_t = 3;
pub const ecs_primitive_kind_t_EcsU8: ecs_primitive_kind_t = 4;
pub const ecs_primitive_kind_t_EcsU16: ecs_primitive_kind_t = 5;
pub const ecs_primitive_kind_t_EcsU32: ecs_primitive_kind_t = 6;
pub const ecs_primitive_kind_t_EcsU64: ecs_primitive_kind_t = 7;
pub const ecs_primitive_kind_t_EcsI8: ecs_primitive_kind_t = 8;
pub const ecs_primitive_kind_t_EcsI16: ecs_primitive_kind_t = 9;
pub const ecs_primitive_kind_t_EcsI32: ecs_primitive_kind_t = 10;
pub const ecs_primitive_kind_t_EcsI64: ecs_primitive_kind_t = 11;
pub const ecs_primitive_kind_t_EcsF32: ecs_primitive_kind_t = 12;
pub const ecs_primitive_kind_t_EcsF64: ecs_primitive_kind_t = 13;
pub const ecs_primitive_kind_t_EcsUPtr: ecs_primitive_kind_t = 14;
pub const ecs_primitive_kind_t_EcsIPtr: ecs_primitive_kind_t = 15;
pub const ecs_primitive_kind_t_EcsString: ecs_primitive_kind_t = 16;
pub const ecs_primitive_kind_t_EcsEntity: ecs_primitive_kind_t = 17;
pub const ecs_primitive_kind_t_EcsPrimitiveKindLast: ecs_primitive_kind_t = 17;
pub type ecs_primitive_kind_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsPrimitive {
    pub kind: ecs_primitive_kind_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsMember {
    pub type_: ecs_entity_t,
    pub count: i32,
    pub unit: ecs_entity_t,
    pub offset: i32,
}
#[doc = "Element type of members vector in EcsStruct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_member_t {
    #[doc = "Must be set when used with ecs_struct_desc_t"]
    pub name: *const ::std::os::raw::c_char,
    pub type_: ecs_entity_t,
    #[doc = "May be set when used with ecs_struct_desc_t"]
    pub count: i32,
    pub offset: i32,
    #[doc = "May be set when used with ecs_struct_desc_t, will be auto-populated if\n type entity is also a unit"]
    pub unit: ecs_entity_t,
    #[doc = "Should not be set by ecs_struct_desc_t"]
    pub size: ecs_size_t,
    pub member: ecs_entity_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsStruct {
    #[doc = "vector<ecs_member_t>"]
    pub members: ecs_vec_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_enum_constant_t {
    #[doc = "Must be set when used with ecs_enum_desc_t"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "May be set when used with ecs_enum_desc_t"]
    pub value: i32,
    #[doc = "Should not be set by ecs_enum_desc_t"]
    pub constant: ecs_entity_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsEnum {
    #[doc = "map<i32_t, ecs_enum_constant_t>"]
    pub constants: ecs_map_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_bitmask_constant_t {
    #[doc = "Must be set when used with ecs_bitmask_desc_t"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "May be set when used with ecs_bitmask_desc_t"]
    pub value: ecs_flags32_t,
    #[doc = "Should not be set by ecs_bitmask_desc_t"]
    pub constant: ecs_entity_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsBitmask {
    #[doc = "map<u32_t, ecs_bitmask_constant_t>"]
    pub constants: ecs_map_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsArray {
    pub type_: ecs_entity_t,
    pub count: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsVector {
    pub type_: ecs_entity_t,
}
#[doc = "Serializer interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_serializer_t {
    #[doc = "Serialize value"]
    pub value: ::std::option::Option<
        unsafe extern "C" fn(
            ser: *const ecs_serializer_t,
            type_: ecs_entity_t,
            value: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "Serialize member"]
    pub member: ::std::option::Option<
        unsafe extern "C" fn(
            ser: *const ecs_serializer_t,
            member: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub world: *const ecs_world_t,
    pub ctx: *mut ::std::os::raw::c_void,
}
#[doc = "Callback invoked serializing an opaque type."]
pub type ecs_meta_serialize_t = ::std::option::Option<
    unsafe extern "C" fn(
        ser: *const ecs_serializer_t,
        src: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsOpaque {
    #[doc = "< Type that describes the serialized output"]
    pub as_type: ecs_entity_t,
    #[doc = "< Serialize action"]
    pub serialize: ecs_meta_serialize_t,
    #[doc = "Assign bool value"]
    pub assign_bool:
        ::std::option::Option<unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void, value: bool)>,
    #[doc = "Assign char value"]
    pub assign_char: ::std::option::Option<
        unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void, value: ::std::os::raw::c_char),
    >,
    #[doc = "Assign int value"]
    pub assign_int:
        ::std::option::Option<unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void, value: i64)>,
    #[doc = "Assign unsigned int value"]
    pub assign_uint:
        ::std::option::Option<unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void, value: u64)>,
    #[doc = "Assign float value"]
    pub assign_float:
        ::std::option::Option<unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void, value: f64)>,
    #[doc = "Assign string value"]
    pub assign_string: ::std::option::Option<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            value: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = "Assign entity value"]
    pub assign_entity: ::std::option::Option<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            world: *mut ecs_world_t,
            entity: ecs_entity_t,
        ),
    >,
    #[doc = "Assign null value"]
    pub assign_null: ::std::option::Option<unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void)>,
    #[doc = "Clear collection elements"]
    pub clear: ::std::option::Option<unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void)>,
    #[doc = "Ensure & get collection element"]
    pub ensure_element: ::std::option::Option<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            elem: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = "Ensure & get element"]
    pub ensure_member: ::std::option::Option<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            member: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = "Return number of elements"]
    pub count:
        ::std::option::Option<unsafe extern "C" fn(dst: *const ::std::os::raw::c_void) -> usize>,
    #[doc = "Resize to number of elements"]
    pub resize:
        ::std::option::Option<unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void, count: usize)>,
}
#[doc = "Helper type to describe translation between two units. Note that this\n is not intended as a generic approach to unit conversions (e.g. from celsius\n to fahrenheit) but to translate between units that derive from the same base\n (e.g. meters to kilometers).\n\n Note that power is applied to the factor. When describing a translation of\n 1000, either use {factor = 1000, power = 1} or {factor = 1, power = 3}."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_unit_translation_t {
    #[doc = "< Factor to apply (e.g. \"1000\", \"1000000\", \"1024\")"]
    pub factor: i32,
    #[doc = "< Power to apply to factor (e.g. \"1\", \"3\", \"-9\")"]
    pub power: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsUnit {
    pub symbol: *mut ::std::os::raw::c_char,
    #[doc = "< Order of magnitude prefix relative to derived"]
    pub prefix: ecs_entity_t,
    #[doc = "< Base unit (e.g. \"meters\")"]
    pub base: ecs_entity_t,
    #[doc = "< Over unit (e.g. \"per second\")"]
    pub over: ecs_entity_t,
    #[doc = "< Translation for derived unit"]
    pub translation: ecs_unit_translation_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsUnitPrefix {
    #[doc = "< Symbol of prefix (e.g. \"K\", \"M\", \"Ki\")"]
    pub symbol: *mut ::std::os::raw::c_char,
    #[doc = "< Translation of prefix"]
    pub translation: ecs_unit_translation_t,
}
pub const ecs_meta_type_op_kind_t_EcsOpArray: ecs_meta_type_op_kind_t = 0;
pub const ecs_meta_type_op_kind_t_EcsOpVector: ecs_meta_type_op_kind_t = 1;
pub const ecs_meta_type_op_kind_t_EcsOpOpaque: ecs_meta_type_op_kind_t = 2;
pub const ecs_meta_type_op_kind_t_EcsOpPush: ecs_meta_type_op_kind_t = 3;
pub const ecs_meta_type_op_kind_t_EcsOpPop: ecs_meta_type_op_kind_t = 4;
#[doc = "< Marks last constant that can open/close a scope"]
pub const ecs_meta_type_op_kind_t_EcsOpScope: ecs_meta_type_op_kind_t = 5;
pub const ecs_meta_type_op_kind_t_EcsOpEnum: ecs_meta_type_op_kind_t = 6;
pub const ecs_meta_type_op_kind_t_EcsOpBitmask: ecs_meta_type_op_kind_t = 7;
#[doc = "< Marks first constant that's a primitive"]
pub const ecs_meta_type_op_kind_t_EcsOpPrimitive: ecs_meta_type_op_kind_t = 8;
pub const ecs_meta_type_op_kind_t_EcsOpBool: ecs_meta_type_op_kind_t = 9;
pub const ecs_meta_type_op_kind_t_EcsOpChar: ecs_meta_type_op_kind_t = 10;
pub const ecs_meta_type_op_kind_t_EcsOpByte: ecs_meta_type_op_kind_t = 11;
pub const ecs_meta_type_op_kind_t_EcsOpU8: ecs_meta_type_op_kind_t = 12;
pub const ecs_meta_type_op_kind_t_EcsOpU16: ecs_meta_type_op_kind_t = 13;
pub const ecs_meta_type_op_kind_t_EcsOpU32: ecs_meta_type_op_kind_t = 14;
pub const ecs_meta_type_op_kind_t_EcsOpU64: ecs_meta_type_op_kind_t = 15;
pub const ecs_meta_type_op_kind_t_EcsOpI8: ecs_meta_type_op_kind_t = 16;
pub const ecs_meta_type_op_kind_t_EcsOpI16: ecs_meta_type_op_kind_t = 17;
pub const ecs_meta_type_op_kind_t_EcsOpI32: ecs_meta_type_op_kind_t = 18;
pub const ecs_meta_type_op_kind_t_EcsOpI64: ecs_meta_type_op_kind_t = 19;
pub const ecs_meta_type_op_kind_t_EcsOpF32: ecs_meta_type_op_kind_t = 20;
pub const ecs_meta_type_op_kind_t_EcsOpF64: ecs_meta_type_op_kind_t = 21;
pub const ecs_meta_type_op_kind_t_EcsOpUPtr: ecs_meta_type_op_kind_t = 22;
pub const ecs_meta_type_op_kind_t_EcsOpIPtr: ecs_meta_type_op_kind_t = 23;
pub const ecs_meta_type_op_kind_t_EcsOpString: ecs_meta_type_op_kind_t = 24;
pub const ecs_meta_type_op_kind_t_EcsOpEntity: ecs_meta_type_op_kind_t = 25;
pub const ecs_meta_type_op_kind_t_EcsMetaTypeOpKindLast: ecs_meta_type_op_kind_t = 25;
#[doc = "Serializer utilities"]
pub type ecs_meta_type_op_kind_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_meta_type_op_t {
    pub kind: ecs_meta_type_op_kind_t,
    #[doc = "< Offset of current field"]
    pub offset: ecs_size_t,
    pub count: i32,
    #[doc = "< Name of value (only used for struct members)"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Number of operations until next field or end"]
    pub op_count: i32,
    #[doc = "< Size of type of operation"]
    pub size: ecs_size_t,
    pub type_: ecs_entity_t,
    pub unit: ecs_entity_t,
    #[doc = "< string -> member index (structs only)"]
    pub members: *mut ecs_hashmap_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsMetaTypeSerialized {
    #[doc = "< vector<ecs_meta_type_op_t>"]
    pub ops: ecs_vec_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_meta_scope_t {
    #[doc = "< The type being iterated"]
    pub type_: ecs_entity_t,
    #[doc = "< The type operations (see ecs_meta_type_op_t)"]
    pub ops: *mut ecs_meta_type_op_t,
    #[doc = "< Number of operations in ops array to process"]
    pub op_count: i32,
    #[doc = "< Current operation"]
    pub op_cur: i32,
    #[doc = "< Current element (for collections)"]
    pub elem_cur: i32,
    #[doc = "< Depth to restore, in case dotmember was used"]
    pub prev_depth: i32,
    #[doc = "< Pointer to the value being iterated"]
    pub ptr: *mut ::std::os::raw::c_void,
    #[doc = "< Pointer to component, in case size/alignment is needed"]
    pub comp: *const EcsComponent,
    #[doc = "< Opaque type interface"]
    pub opaque: *const EcsOpaque,
    #[doc = "< Current vector, in case a vector is iterated"]
    pub vector: *mut ecs_vec_t,
    #[doc = "< string -> member index"]
    pub members: *mut ecs_hashmap_t,
    #[doc = "< Is the scope iterating elements?"]
    pub is_collection: bool,
    #[doc = "< Is the scope iterating an inline array?"]
    pub is_inline_array: bool,
    #[doc = "< Was scope populated (for collections)"]
    pub is_empty_scope: bool,
}
#[doc = "Type that enables iterating/populating a value using reflection data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_meta_cursor_t {
    pub world: *const ecs_world_t,
    pub scope: [ecs_meta_scope_t; 32usize],
    pub depth: i32,
    pub valid: bool,
    #[doc = "< If in root scope, this allows for a push for primitive types"]
    pub is_primitive_scope: bool,
    #[doc = "Custom entity lookup action for overriding default ecs_lookup_fullpath"]
    pub lookup_action: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ecs_world_t,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_void,
        ) -> ecs_entity_t,
    >,
    pub lookup_ctx: *mut ::std::os::raw::c_void,
}
extern "C" {
    pub fn ecs_meta_cursor(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ecs_meta_cursor_t;
}
extern "C" {
    #[doc = "Get pointer to current field"]
    pub fn ecs_meta_get_ptr(cursor: *mut ecs_meta_cursor_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Move cursor to next field"]
    pub fn ecs_meta_next(cursor: *mut ecs_meta_cursor_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Move cursor to a element"]
    pub fn ecs_meta_elem(cursor: *mut ecs_meta_cursor_t, elem: i32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Move cursor to member"]
    pub fn ecs_meta_member(
        cursor: *mut ecs_meta_cursor_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Move cursor to member, supports dot-separated nested members"]
    pub fn ecs_meta_dotmember(
        cursor: *mut ecs_meta_cursor_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Push a scope (required/only valid for structs & collections)"]
    pub fn ecs_meta_push(cursor: *mut ecs_meta_cursor_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Pop a struct or collection scope (must follow a push)"]
    pub fn ecs_meta_pop(cursor: *mut ecs_meta_cursor_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Is the current scope a collection?"]
    pub fn ecs_meta_is_collection(cursor: *const ecs_meta_cursor_t) -> bool;
}
extern "C" {
    #[doc = "Get type of current element."]
    pub fn ecs_meta_get_type(cursor: *const ecs_meta_cursor_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Get unit of current element."]
    pub fn ecs_meta_get_unit(cursor: *const ecs_meta_cursor_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Get member name of current member"]
    pub fn ecs_meta_get_member(cursor: *const ecs_meta_cursor_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Set field with boolean value"]
    pub fn ecs_meta_set_bool(cursor: *mut ecs_meta_cursor_t, value: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set field with char value"]
    pub fn ecs_meta_set_char(
        cursor: *mut ecs_meta_cursor_t,
        value: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set field with int value"]
    pub fn ecs_meta_set_int(cursor: *mut ecs_meta_cursor_t, value: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set field with uint value"]
    pub fn ecs_meta_set_uint(cursor: *mut ecs_meta_cursor_t, value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set field with float value"]
    pub fn ecs_meta_set_float(cursor: *mut ecs_meta_cursor_t, value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set field with string value"]
    pub fn ecs_meta_set_string(
        cursor: *mut ecs_meta_cursor_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set field with string literal value (has enclosing \"\")"]
    pub fn ecs_meta_set_string_literal(
        cursor: *mut ecs_meta_cursor_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set field with entity value"]
    pub fn ecs_meta_set_entity(
        cursor: *mut ecs_meta_cursor_t,
        value: ecs_entity_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set field with null value"]
    pub fn ecs_meta_set_null(cursor: *mut ecs_meta_cursor_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set field with dynamic value"]
    pub fn ecs_meta_set_value(
        cursor: *mut ecs_meta_cursor_t,
        value: *const ecs_value_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get field value as boolean."]
    pub fn ecs_meta_get_bool(cursor: *const ecs_meta_cursor_t) -> bool;
}
extern "C" {
    #[doc = "Get field value as char."]
    pub fn ecs_meta_get_char(cursor: *const ecs_meta_cursor_t) -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Get field value as signed integer."]
    pub fn ecs_meta_get_int(cursor: *const ecs_meta_cursor_t) -> i64;
}
extern "C" {
    #[doc = "Get field value as unsigned integer."]
    pub fn ecs_meta_get_uint(cursor: *const ecs_meta_cursor_t) -> u64;
}
extern "C" {
    #[doc = "Get field value as float."]
    pub fn ecs_meta_get_float(cursor: *const ecs_meta_cursor_t) -> f64;
}
extern "C" {
    #[doc = "Get field value as string.\n This operation does not perform conversions. If the field is not a string,\n this operation will fail."]
    pub fn ecs_meta_get_string(cursor: *const ecs_meta_cursor_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Get field value as entity.\n This operation does not perform conversions."]
    pub fn ecs_meta_get_entity(cursor: *const ecs_meta_cursor_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Convert pointer of primitive kind to float."]
    pub fn ecs_meta_ptr_to_float(
        type_kind: ecs_primitive_kind_t,
        ptr: *const ::std::os::raw::c_void,
    ) -> f64;
}
#[doc = "Used with ecs_primitive_init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_primitive_desc_t {
    #[doc = "< Existing entity to use for type (optional)"]
    pub entity: ecs_entity_t,
    pub kind: ecs_primitive_kind_t,
}
extern "C" {
    #[doc = "Create a new primitive type"]
    pub fn ecs_primitive_init(
        world: *mut ecs_world_t,
        desc: *const ecs_primitive_desc_t,
    ) -> ecs_entity_t;
}
#[doc = "Used with ecs_enum_init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_enum_desc_t {
    #[doc = "< Existing entity to use for type (optional)"]
    pub entity: ecs_entity_t,
    pub constants: [ecs_enum_constant_t; 32usize],
}
extern "C" {
    #[doc = "Create a new enum type"]
    pub fn ecs_enum_init(world: *mut ecs_world_t, desc: *const ecs_enum_desc_t) -> ecs_entity_t;
}
#[doc = "Used with ecs_bitmask_init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_bitmask_desc_t {
    #[doc = "< Existing entity to use for type (optional)"]
    pub entity: ecs_entity_t,
    pub constants: [ecs_bitmask_constant_t; 32usize],
}
extern "C" {
    #[doc = "Create a new bitmask type"]
    pub fn ecs_bitmask_init(
        world: *mut ecs_world_t,
        desc: *const ecs_bitmask_desc_t,
    ) -> ecs_entity_t;
}
#[doc = "Used with ecs_array_init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_array_desc_t {
    #[doc = "< Existing entity to use for type (optional)"]
    pub entity: ecs_entity_t,
    pub type_: ecs_entity_t,
    pub count: i32,
}
extern "C" {
    #[doc = "Create a new array type"]
    pub fn ecs_array_init(world: *mut ecs_world_t, desc: *const ecs_array_desc_t) -> ecs_entity_t;
}
#[doc = "Used with ecs_vector_init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_vector_desc_t {
    #[doc = "< Existing entity to use for type (optional)"]
    pub entity: ecs_entity_t,
    pub type_: ecs_entity_t,
}
extern "C" {
    #[doc = "Create a new vector type"]
    pub fn ecs_vector_init(world: *mut ecs_world_t, desc: *const ecs_vector_desc_t)
        -> ecs_entity_t;
}
#[doc = "Used with ecs_struct_init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_struct_desc_t {
    #[doc = "< Existing entity to use for type (optional)"]
    pub entity: ecs_entity_t,
    pub members: [ecs_member_t; 32usize],
}
extern "C" {
    #[doc = "Create a new struct type"]
    pub fn ecs_struct_init(world: *mut ecs_world_t, desc: *const ecs_struct_desc_t)
        -> ecs_entity_t;
}
#[doc = "Used with ecs_opaque_init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_opaque_desc_t {
    pub entity: ecs_entity_t,
    pub type_: EcsOpaque,
}
extern "C" {
    #[doc = "Create a new opaque type.\n Opaque types are types of which the layout doesn't match what can be modelled\n with the primitives of the meta framework, but which have a structure\n that can be described with meta primitives. Typical examples are STL types\n such as std::string or std::vector, types with a nontrivial layout, and types\n that only expose getter/setter methods.\n\n An opaque type is a combination of a serialization function, and a handle to\n a meta type which describes the structure of the serialized output. For\n example, an opaque type for std::string would have a serializer function that\n accesses .c_str(), and with type ecs_string_t.\n\n The serializer callback accepts a serializer object and a pointer to the\n value of the opaque type to be serialized. The serializer has two methods:\n\n - value, which serializes a value (such as .c_str())\n - member, which specifies a member to be serialized (in the case of a struct)"]
    pub fn ecs_opaque_init(world: *mut ecs_world_t, desc: *const ecs_opaque_desc_t)
        -> ecs_entity_t;
}
#[doc = "Used with ecs_unit_init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_unit_desc_t {
    #[doc = "Existing entity to associate with unit (optional)"]
    pub entity: ecs_entity_t,
    #[doc = "Unit symbol, e.g. \"m\", \"%\", \"g\". (optional)"]
    pub symbol: *const ::std::os::raw::c_char,
    #[doc = "Unit quantity, e.g. distance, percentage, weight. (optional)"]
    pub quantity: ecs_entity_t,
    #[doc = "Base unit, e.g. \"meters\" (optional)"]
    pub base: ecs_entity_t,
    #[doc = "Over unit, e.g. \"per second\" (optional)"]
    pub over: ecs_entity_t,
    #[doc = "Translation to apply to derived unit (optional)"]
    pub translation: ecs_unit_translation_t,
    #[doc = "Prefix indicating order of magnitude relative to the derived unit. If set\n together with \"translation\", the values must match. If translation is not\n set, setting prefix will autopopulate it.\n Additionally, setting the prefix will enforce that the symbol (if set)\n is consistent with the prefix symbol + symbol of the derived unit. If the\n symbol is not set, it will be auto populated."]
    pub prefix: ecs_entity_t,
}
extern "C" {
    #[doc = "Create a new unit"]
    pub fn ecs_unit_init(world: *mut ecs_world_t, desc: *const ecs_unit_desc_t) -> ecs_entity_t;
}
#[doc = "Used with ecs_unit_prefix_init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_unit_prefix_desc_t {
    #[doc = "Existing entity to associate with unit prefix (optional)"]
    pub entity: ecs_entity_t,
    #[doc = "Unit symbol, e.g. \"m\", \"%\", \"g\". (optional)"]
    pub symbol: *const ::std::os::raw::c_char,
    #[doc = "Translation to apply to derived unit (optional)"]
    pub translation: ecs_unit_translation_t,
}
extern "C" {
    #[doc = "Create a new unit prefix"]
    pub fn ecs_unit_prefix_init(
        world: *mut ecs_world_t,
        desc: *const ecs_unit_prefix_desc_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Create a new quantity"]
    pub fn ecs_quantity_init(
        world: *mut ecs_world_t,
        desc: *const ecs_entity_desc_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Module import"]
    pub fn FlecsMetaImport(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = "Write an escaped character.\n Write a character to an output string, insert escape character if necessary.\n\n @param out The string to write the character to.\n @param in The input character.\n @param delimiter The delimiiter used (for example '\"')\n @return Pointer to the character after the last one written."]
    pub fn ecs_chresc(
        out: *mut ::std::os::raw::c_char,
        in_: ::std::os::raw::c_char,
        delimiter: ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Parse an escaped character.\n Parse a character with a potential escape sequence.\n\n @param in Pointer to character in input string.\n @param out Output string.\n @return Pointer to the character after the last one read."]
    pub fn ecs_chrparse(
        in_: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Write an escaped string.\n Write an input string to an output string, escape characters where necessary.\n To determine the size of the output string, call the operation with a NULL\n argument for 'out', and use the returned size to allocate a string that is\n large enough.\n\n @param out Pointer to output string (msut be).\n @param size Maximum number of characters written to output.\n @param delimiter The delimiter used (for example '\"').\n @param in The input string.\n @return The number of characters that (would) have been written."]
    pub fn ecs_stresc(
        out: *mut ::std::os::raw::c_char,
        size: ecs_size_t,
        delimiter: ::std::os::raw::c_char,
        in_: *const ::std::os::raw::c_char,
    ) -> ecs_size_t;
}
extern "C" {
    #[doc = "Return escaped string.\n Return escaped version of input string. Same as ecs_stresc, but returns an\n allocated string of the right size.\n\n @param delimiter The delimiter used (for example '\"').\n @param in The input string.\n @return Escaped string."]
    pub fn ecs_astresc(
        delimiter: ::std::os::raw::c_char,
        in_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = "Storage for parser variables. Variables make it possible to parameterize\n expression strings, and are referenced with the $ operator (e.g. $var)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_expr_var_t {
    pub name: *mut ::std::os::raw::c_char,
    pub value: ecs_value_t,
    #[doc = "Set to false if ecs_vars_t should not take ownership of var"]
    pub owned: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_expr_var_scope_t {
    pub var_index: ecs_hashmap_t,
    pub vars: ecs_vec_t,
    pub parent: *mut ecs_expr_var_scope_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_vars_t {
    pub world: *mut ecs_world_t,
    pub root: ecs_expr_var_scope_t,
    pub cur: *mut ecs_expr_var_scope_t,
}
extern "C" {
    #[doc = "Init variable storage"]
    pub fn ecs_vars_init(world: *mut ecs_world_t, vars: *mut ecs_vars_t);
}
extern "C" {
    #[doc = "Cleanup variable storage"]
    pub fn ecs_vars_fini(vars: *mut ecs_vars_t);
}
extern "C" {
    #[doc = "Push variable scope"]
    pub fn ecs_vars_push(vars: *mut ecs_vars_t);
}
extern "C" {
    #[doc = "Pop variable scope"]
    pub fn ecs_vars_pop(vars: *mut ecs_vars_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Declare variable in current scope"]
    pub fn ecs_vars_declare(
        vars: *mut ecs_vars_t,
        name: *const ::std::os::raw::c_char,
        type_: ecs_entity_t,
    ) -> *mut ecs_expr_var_t;
}
extern "C" {
    #[doc = "Declare variable in current scope from value.\n This operation takes ownership of the value. The value pointer must be\n allocated with ecs_value_new."]
    pub fn ecs_vars_declare_w_value(
        vars: *mut ecs_vars_t,
        name: *const ::std::os::raw::c_char,
        value: *mut ecs_value_t,
    ) -> *mut ecs_expr_var_t;
}
extern "C" {
    #[doc = "Lookup variable in scope and parent scopes"]
    pub fn ecs_vars_lookup(
        vars: *const ecs_vars_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ecs_expr_var_t;
}
#[doc = "Used with ecs_parse_expr."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_parse_expr_desc_t {
    pub name: *const ::std::os::raw::c_char,
    pub expr: *const ::std::os::raw::c_char,
    pub lookup_action: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ecs_world_t,
            value: *const ::std::os::raw::c_char,
            ctx: *mut ::std::os::raw::c_void,
        ) -> ecs_entity_t,
    >,
    pub lookup_ctx: *mut ::std::os::raw::c_void,
    pub vars: *mut ecs_vars_t,
}
extern "C" {
    #[doc = "Parse expression into value.\n This operation parses a flecs expression into the provided pointer. The\n memory pointed to must be large enough to contain a value of the used type.\n\n If no type and pointer are provided for the value argument, the operation\n will discover the type from the expression and allocate storage for the\n value. The allocated value must be freed with ecs_value_free.\n\n @param world The world.\n @param ptr The pointer to the expression to parse.\n @param value The value containing type & pointer to write to.\n @param desc Configuration parameters for deserializer.\n @return Pointer to the character after the last one read, or NULL if failed."]
    pub fn ecs_parse_expr(
        world: *mut ecs_world_t,
        ptr: *const ::std::os::raw::c_char,
        value: *mut ecs_value_t,
        desc: *const ecs_parse_expr_desc_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Serialize value into expression string.\n This operation serializes a value of the provided type to a string. The\n memory pointed to must be large enough to contain a value of the used type.\n\n @param world The world.\n @param type The type of the value to serialize.\n @param data The value to serialize.\n @return String with expression, or NULL if failed."]
    pub fn ecs_ptr_to_expr(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Serialize value into expression buffer.\n Same as ecs_ptr_to_expr, but serializes to an ecs_strbuf_t instance.\n\n @param world The world.\n @param type The type of the value to serialize.\n @param data The value to serialize.\n @param buf The strbuf to append the string to.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_ptr_to_expr_buf(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        data: *const ::std::os::raw::c_void,
        buf: *mut ecs_strbuf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Similar as ecs_ptr_to_expr, but serializes values to string.\n Whereas the output of ecs_ptr_to_expr is a valid expression, the output of\n ecs_ptr_to_str is a string representation of the value. In most cases the\n output of the two operations is the same, but there are some differences:\n - Strings are not quoted\n\n @param world The world.\n @param type The type of the value to serialize.\n @param data The value to serialize.\n @return String with result, or NULL if failed."]
    pub fn ecs_ptr_to_str(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Serialize value into string buffer.\n Same as ecs_ptr_to_str, but serializes to an ecs_strbuf_t instance.\n\n @param world The world.\n @param type The type of the value to serialize.\n @param data The value to serialize.\n @param buf The strbuf to append the string to.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_ptr_to_str_buf(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        data: *const ::std::os::raw::c_void,
        buf: *mut ecs_strbuf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Serialize primitive value into string buffer.\n Serializes a primitive value to an ecs_strbuf_t instance. This operation can\n be reused by other serializers to avoid having to write boilerplate code that\n serializes primitive values to a string.\n\n @param world The world.\n @param kind The kind of primitive value.\n @param data The value ot serialize\n @param buf The strbuf to append the string to.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_primitive_to_expr_buf(
        world: *const ecs_world_t,
        kind: ecs_primitive_kind_t,
        data: *const ::std::os::raw::c_void,
        buf: *mut ecs_strbuf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Parse expression token.\n Expression tokens can contain more characters (such as '|') than tokens\n parsed by the query (term) parser.\n\n @param name The name of the expression (used for debug logs).\n @param expr The full expression (used for debug logs).\n @param ptr The pointer to the expression to parse.\n @param token The buffer to write to (must have size ECS_MAX_TOKEN_SIZE)\n @return Pointer to the character after the last one read, or NULL if failed."]
    pub fn ecs_parse_expr_token(
        name: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        ptr: *const ::std::os::raw::c_char,
        token: *mut ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Evaluate interpolated expressions in string.\n This operation evaluates expressions in a string, and replaces them with\n their evaluated result. Supported expression formats are:\n  - $variable_name\n  - {expression}\n\n The $, { and } characters can be escaped with a backslash (\\).\n\n @param world The world.\n @param str The string to evaluate.\n @param vars The variables to use for evaluation."]
    pub fn ecs_interpolate_string(
        world: *mut ecs_world_t,
        str_: *const ::std::os::raw::c_char,
        vars: *const ecs_vars_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Convert iterator to vars\n This operation converts an iterator to a variable array. This allows for\n using iterator results in expressions. The operation only converts a\n single result at a time, and does not progress the iterator.\n\n Iterator fields with data will be made available as variables with as name\n the field index (e.g. \"$1\"). The operation does not check if reflection data\n is registered for a field type. If no reflection data is registered for the\n type, using the field variable in expressions will fail.\n\n Field variables will only contain single elements, even if the iterator\n returns component arrays. The offset parameter can be used to specify which\n element in the component arrays to return. The offset parameter must be\n smaller than it->count.\n\n The operation will create a variable for query variables that contain a\n single entity.\n\n The operation will attempt to use existing variables. If a variable does not\n yet exist, the operation will create it. If an existing variable exists with\n a mismatching type, the operation will fail.\n\n Accessing variables after progressing the iterator or after the iterator is\n destroyed will result in undefined behavior.\n\n If vars contains a variable that is not present in the iterator, the variable\n will not be modified.\n\n @param it The iterator to convert to variables.\n @param vars The variables to write to.\n @param offset The offset to the current element."]
    pub fn ecs_iter_to_vars(
        it: *const ecs_iter_t,
        vars: *mut ecs_vars_t,
        offset: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "Populate meta information from type descriptor."]
    pub fn ecs_meta_from_desc(
        world: *mut ecs_world_t,
        component: ecs_entity_t,
        kind: ecs_type_kind_t,
        desc: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut FLECS__EEcsScript: ecs_entity_t;
}
#[doc = "Script component"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsScript {
    pub using_: ecs_vec_t,
    pub script: *mut ::std::os::raw::c_char,
    pub prop_defaults: ecs_vec_t,
    pub world: *mut ecs_world_t,
}
extern "C" {
    #[doc = "Parse plecs string.\n This parses a plecs string and instantiates the entities in the world.\n\n @param world The world.\n @param name The script name (typically the file).\n @param str The plecs string.\n @return Zero if success, non-zero otherwise."]
    pub fn ecs_plecs_from_str(
        world: *mut ecs_world_t,
        name: *const ::std::os::raw::c_char,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Parse plecs file.\n This parses a plecs file and instantiates the entities in the world. This\n operation is equivalent to loading the file contents and passing it to\n ecs_plecs_from_str.\n\n @param world The world.\n @param filename The plecs file name.\n @return Zero if success, non-zero otherwise."]
    pub fn ecs_plecs_from_file(
        world: *mut ecs_world_t,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = "Used with ecs_script_init"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_script_desc_t {
    #[doc = "Set to customize entity handle associated with script"]
    pub entity: ecs_entity_t,
    #[doc = "Set to load script from file"]
    pub filename: *const ::std::os::raw::c_char,
    #[doc = "Set to parse script from string"]
    pub str_: *const ::std::os::raw::c_char,
}
extern "C" {
    #[doc = "Load managed script.\n A managed script tracks which entities it creates, and keeps those entities\n synchronized when the contents of the script are updated. When the script is\n updated, entities that are no longer in the new version will be deleted.\n\n This feature is experimental.\n\n @param world The world.\n @param desc Script descriptor."]
    pub fn ecs_script_init(world: *mut ecs_world_t, desc: *const ecs_script_desc_t)
        -> ecs_entity_t;
}
extern "C" {
    #[doc = "Update script with new code.\n\n @param world The world.\n @param script The script entity.\n @param instance An assembly instance (optional).\n @param str The script code.\n @param vars Optional preset variables for script parameterization."]
    pub fn ecs_script_update(
        world: *mut ecs_world_t,
        script: ecs_entity_t,
        instance: ecs_entity_t,
        str_: *const ::std::os::raw::c_char,
        vars: *mut ecs_vars_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Clear all entities associated with script.\n\n @param world The world.\n @param script The script entity.\n @param instance The script instance."]
    pub fn ecs_script_clear(world: *mut ecs_world_t, script: ecs_entity_t, instance: ecs_entity_t);
}
extern "C" {
    #[doc = "Module import"]
    pub fn FlecsScriptImport(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = "Create a rule.\n A rule accepts the same descriptor as a filter, but has the additional\n ability to use query variables.\n\n Query variables can be used to constrain wildcards across multiple terms to\n the same entity. Regular ECS queries do this in a limited form, as querying\n for Position, Velocity only returns entities that have both components.\n\n Query variables expand this to constrain entities that are resolved while the\n query is being matched. Consider a query for all entities and the mission\n they are on:\n   (Mission, *)\n\n If an entity is on multiple missions, the wildcard will match it multiple\n times. Now say we want to only list combat missions. Naively we could try:\n   (Mission, *), CombatMission(*)\n\n But this doesn't work, as term 1 returns entities with missions, and term 2\n returns all combat missions for all entities. Query variables make it\n possible to apply CombatMission to the found mission:\n   (Mission, $M), CombatMission($M)\n\n By using the same variable ('M') we ensure that CombatMission is applied to\n the mission found in the current result.\n\n Variables can be used in each part of the term (predicate, subject, object).\n This is a valid query:\n   Likes($X, $Y), Likes($Y, $X)\n\n This is also a valid query:\n   _Component, Serializable(_Component)\n\n In the query expression syntax, variables are prefixed with a $. When using\n the descriptor, specify the variable kind:\n   desc.terms\\[0\\].second = { .name = \"X\", .var = EcsVarIsVariable }\n\n Different terms with the same variable name are automatically correlated by\n the query engine.\n\n A rule needs to be explicitly deleted with ecs_rule_fini.\n\n @param world The world.\n @param desc The descriptor (see ecs_filter_desc_t)\n @return The rule."]
    pub fn ecs_rule_init(
        world: *mut ecs_world_t,
        desc: *const ecs_filter_desc_t,
    ) -> *mut ecs_rule_t;
}
extern "C" {
    #[doc = "Delete a rule.\n\n @param rule The rule."]
    pub fn ecs_rule_fini(rule: *mut ecs_rule_t);
}
extern "C" {
    #[doc = "Obtain filter from rule.\n This operation returns the filter with which the rule was created.\n\n @param rule The rule.\n @return The filter."]
    pub fn ecs_rule_get_filter(rule: *const ecs_rule_t) -> *const ecs_filter_t;
}
extern "C" {
    #[doc = "Return number of variables in rule.\n\n @param rule The rule.\n @return The number of variables/"]
    pub fn ecs_rule_var_count(rule: *const ecs_rule_t) -> i32;
}
extern "C" {
    #[doc = "Find variable index.\n This operation looks up the index of a variable in the rule. This index can\n be used in operations like ecs_iter_set_var and ecs_iter_get_var.\n\n @param rule The rule.\n @param name The variable name.\n @return The variable index."]
    pub fn ecs_rule_find_var(rule: *const ecs_rule_t, name: *const ::std::os::raw::c_char) -> i32;
}
extern "C" {
    #[doc = "Get variable name.\n This operation returns the variable name for an index.\n\n @param rule The rule.\n @param var_id The variable index."]
    pub fn ecs_rule_var_name(rule: *const ecs_rule_t, var_id: i32)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Test if variable is an entity.\n Internally the rule engine has entity variables and table variables. When\n iterating through rule variables (by using ecs_rule_variable_count) only\n the values for entity variables are accessible. This operation enables an\n appliction to check if a variable is an entity variable.\n\n @param rule The rule.\n @param var_id The variable id."]
    pub fn ecs_rule_var_is_entity(rule: *const ecs_rule_t, var_id: i32) -> bool;
}
extern "C" {
    #[doc = "Iterate a rule.\n Note that rule iterators may allocate memory, and that unless the iterator\n is iterated until completion, it may still hold resources. When stopping\n iteration before ecs_rule_next has returned false, use ecs_iter_fini to\n cleanup any remaining resources.\n\n @param world The world.\n @param rule The rule.\n @return An iterator."]
    pub fn ecs_rule_iter(world: *const ecs_world_t, rule: *const ecs_rule_t) -> ecs_iter_t;
}
extern "C" {
    #[doc = "Progress rule iterator.\n\n @param it The iterator."]
    pub fn ecs_rule_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = "Progress instanced iterator.\n Should not be called unless you know what you're doing :-)\n\n @param it The iterator."]
    pub fn ecs_rule_next_instanced(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = "Convert rule to a string.\n This will convert the rule program to a string which can aid in debugging\n the behavior of a rule.\n\n The returned string must be freed with ecs_os_free.\n\n @param rule The rule.\n @return The string"]
    pub fn ecs_rule_str(rule: *const ecs_rule_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Convert rule to string with profile.\n To use this you must set the EcsIterProfile flag on an iterator before\n starting uteration:\n   it.flags |= EcsIterProfile\n\n @param rule The rule.\n @return The string"]
    pub fn ecs_rule_str_w_profile(
        rule: *const ecs_rule_t,
        it: *const ecs_iter_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Populate variables from key-value string.\n Convenience function to set rule variables from a key-value string separated\n by comma's. The string must have the followig format:\n   var_a: value, var_b: value\n\n The key-value list may optionally be enclosed in parenthesis.\n\n @param rule The rule.\n @param it The iterator for which to set the variables.\n @param expr The key-value expression."]
    pub fn ecs_rule_parse_vars(
        rule: *mut ecs_rule_t,
        it: *mut ecs_iter_t,
        expr: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_snapshot_t {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Create a snapshot.\n This operation makes a copy of the current state of the world.\n\n @param world The world to snapshot.\n @return The snapshot."]
    pub fn ecs_snapshot_take(world: *mut ecs_world_t) -> *mut ecs_snapshot_t;
}
extern "C" {
    #[doc = "Create a filtered snapshot.\n This operation is the same as ecs_snapshot_take, but accepts an iterator so\n an application can control what is stored by the snapshot.\n\n @param iter An iterator to the data to be stored by the snapshot.\n @return The snapshot."]
    pub fn ecs_snapshot_take_w_iter(iter: *mut ecs_iter_t) -> *mut ecs_snapshot_t;
}
extern "C" {
    #[doc = "Restore a snapshot.\n This operation restores the world to the state it was in when the specified\n snapshot was taken. A snapshot can only be used once for restoring, as its\n data replaces the data that is currently in the world.\n This operation also resets the last issued entity handle, so any calls to\n ecs_new may return entity ids that have been issued before restoring the\n snapshot.\n\n The world in which the snapshot is restored must be the same as the world in\n which the snapshot is taken.\n\n @param world The world to restore the snapshot to.\n @param snapshot The snapshot to restore."]
    pub fn ecs_snapshot_restore(world: *mut ecs_world_t, snapshot: *mut ecs_snapshot_t);
}
extern "C" {
    #[doc = "Obtain iterator to snapshot data.\n\n @param snapshot The snapshot to iterate over.\n @return Iterator to snapshot data."]
    pub fn ecs_snapshot_iter(snapshot: *mut ecs_snapshot_t) -> ecs_iter_t;
}
extern "C" {
    #[doc = "Progress snapshot iterator.\n\n @param iter The snapshot iterator.\n @return True if more data is available, otherwise false."]
    pub fn ecs_snapshot_next(iter: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = "Free snapshot resources.\n This frees resources associated with a snapshot without restoring it.\n\n @param snapshot The snapshot to free."]
    pub fn ecs_snapshot_free(snapshot: *mut ecs_snapshot_t);
}
extern "C" {
    #[doc = "Skip whitespace characters.\n This function skips whitespace characters. Does not skip newlines.\n\n @param ptr Pointer to (potential) whitespaces to skip.\n @return Pointer to the next non-whitespace character."]
    pub fn ecs_parse_ws(ptr: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Skip whitespace and newline characters.\n This function skips whitespace characters.\n\n @param ptr Pointer to (potential) whitespaces to skip.\n @return Pointer to the next non-whitespace character."]
    pub fn ecs_parse_ws_eol(ptr: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Utility function to parse an identifier"]
    pub fn ecs_parse_identifier(
        name: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        ptr: *const ::std::os::raw::c_char,
        token_out: *mut ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Parse digit.\n This function will parse until the first non-digit character is found. The\n provided expression must contain at least one digit character.\n\n @param ptr The expression to parse.\n @param token The output buffer.\n @return Pointer to the first non-digit character."]
    pub fn ecs_parse_digit(
        ptr: *const ::std::os::raw::c_char,
        token: *mut ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Parse a single token.\n This function can be used as simple tokenizer by other parsers.\n\n @param name of program (used for logging).\n @param expr pointer to token to parse.\n @param ptr pointer to first character to parse.\n @param token_out Parsed token (buffer should be ECS_MAX_TOKEN_SIZE large)\n @return Pointer to the next token, or NULL if error occurred."]
    pub fn ecs_parse_token(
        name: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        ptr: *const ::std::os::raw::c_char,
        token_out: *mut ::std::os::raw::c_char,
        delim: ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Parse term in expression.\n This operation parses a single term in an expression and returns a pointer\n to the next term expression.\n\n If the returned pointer points to the 0-terminator, the expression is fully\n parsed. The function would typically be called in a while loop:\n\n const char *ptr = expr;\n while (ptr\\[0\\] && (ptr = ecs_parse_term(world, name, expr, ptr, &term))) { }\n\n The operation does not attempt to find entity ids from the names in the\n expression. Use the ecs_term_resolve_ids function to resolve the identifiers\n in the parsed term.\n\n The returned term will in most cases contain allocated resources, which\n should freed (or used) by the application. To free the resources for a term,\n use the ecs_term_free function.\n\n The parser accepts expressions in the legacy string format.\n\n @param world The world.\n @param name The name of the expression (optional, improves error logs)\n @param expr The expression to parse (optional, improves error logs)\n @param ptr The pointer to the current term (must be in expr).\n @param term_out Out parameter for the term.\n @return pointer to next term if successful, NULL if failed."]
    pub fn ecs_parse_term(
        world: *const ecs_world_t,
        name: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        ptr: *const ::std::os::raw::c_char,
        term_out: *mut ecs_term_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecs_set_os_api_impl();
}
extern "C" {
    #[doc = "Import a module.\n This operation will load a modules and store the public module handles in the\n handles_out out parameter. The module name will be used to verify if the\n module was already loaded, in which case it won't be reimported. The name\n will be translated from PascalCase to an entity path (pascal.case) before the\n lookup occurs.\n\n Module contents will be stored as children of the module entity. This\n prevents modules from accidentally defining conflicting identifiers. This is\n enforced by setting the scope before and after loading the module to the\n module entity id.\n\n A more convenient way to import a module is by using the ECS_IMPORT macro.\n\n @param world The world.\n @param module The module import function.\n @param module_name The name of the module.\n @return The module entity."]
    pub fn ecs_import(
        world: *mut ecs_world_t,
        module: ecs_module_action_t,
        module_name: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Same as ecs_import, but with name to scope conversion.\n PascalCase names are automatically converted to scoped names.\n\n @param world The world.\n @param module The module import function.\n @param module_name_c The name of the module.\n @return The module entity."]
    pub fn ecs_import_c(
        world: *mut ecs_world_t,
        module: ecs_module_action_t,
        module_name_c: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Import a module from a library.\n Similar to ecs_import, except that this operation will attempt to load the\n module from a dynamic library.\n\n A library may contain multiple modules, which is why both a library name and\n a module name need to be provided. If only a library name is provided, the\n library name will be reused for the module name.\n\n The library will be looked up using a canonical name, which is in the same\n form as a module, like `flecs.components.transform`. To transform this\n identifier to a platform specific library name, the operation relies on the\n module_to_dl callback of the os_api which the application has to override if\n the default does not yield the correct library name.\n\n @param world The world.\n @param library_name The name of the library to load.\n @param module_name The name of the module to load."]
    pub fn ecs_import_from_library(
        world: *mut ecs_world_t,
        library_name: *const ::std::os::raw::c_char,
        module_name: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = "Register a new module."]
    pub fn ecs_module_init(
        world: *mut ecs_world_t,
        c_name: *const ::std::os::raw::c_char,
        desc: *const ecs_component_desc_t,
    ) -> ecs_entity_t;
}
extern "C" {
    pub fn ecs_cpp_get_type_name(
        type_name: *mut ::std::os::raw::c_char,
        func_name: *const ::std::os::raw::c_char,
        len: usize,
        front_len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecs_cpp_get_symbol_name(
        symbol_name: *mut ::std::os::raw::c_char,
        type_name: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecs_cpp_get_constant_name(
        constant_name: *mut ::std::os::raw::c_char,
        func_name: *const ::std::os::raw::c_char,
        len: usize,
        back_len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecs_cpp_trim_module(
        world: *mut ecs_world_t,
        type_name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecs_cpp_component_validate(
        world: *mut ecs_world_t,
        id: ecs_entity_t,
        name: *const ::std::os::raw::c_char,
        symbol: *const ::std::os::raw::c_char,
        size: usize,
        alignment: usize,
        implicit_name: bool,
    );
}
extern "C" {
    pub fn ecs_cpp_component_register(
        world: *mut ecs_world_t,
        id: ecs_entity_t,
        name: *const ::std::os::raw::c_char,
        symbol: *const ::std::os::raw::c_char,
        size: ecs_size_t,
        alignment: ecs_size_t,
        implicit_name: bool,
        existing_out: *mut bool,
    ) -> ecs_entity_t;
}
extern "C" {
    pub fn ecs_cpp_component_register_explicit(
        world: *mut ecs_world_t,
        s_id: ecs_entity_t,
        id: ecs_entity_t,
        name: *const ::std::os::raw::c_char,
        type_name: *const ::std::os::raw::c_char,
        symbol: *const ::std::os::raw::c_char,
        size: usize,
        alignment: usize,
        is_component: bool,
        existing_out: *mut bool,
    ) -> ecs_entity_t;
}
extern "C" {
    pub fn ecs_cpp_enum_init(world: *mut ecs_world_t, id: ecs_entity_t);
}
extern "C" {
    pub fn ecs_cpp_enum_constant_register(
        world: *mut ecs_world_t,
        parent: ecs_entity_t,
        id: ecs_entity_t,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> ecs_entity_t;
}
extern "C" {
    pub fn ecs_cpp_reset_count_get() -> i32;
}
extern "C" {
    pub fn ecs_cpp_reset_count_inc() -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_event_id_record_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_table_cache_hdr_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_rule_var_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_rule_op_t {
    pub _address: u8,
}
#[doc = "Operation-specific state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_rule_op_ctx_t {
    pub _address: u8,
}
