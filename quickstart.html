<!DOCTYPE HTML>
<html lang="en" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>quickstart - Flecs Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for the Rust bindings of Flecs ECS">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/tabs.css">
        <link rel="stylesheet" href="theme/mdbook-admonish.css">
        <link rel="stylesheet" href="theme/mdbook-admonish.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Flecs Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Indra-db/Flecs-Rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Indra-db/Flecs-Rust/edit/main/flecs_ecs/doc/src/quickstart.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="flecs-quickstart"><a class="header" href="#flecs-quickstart">Flecs Quickstart</a></h1>
<p>This document provides a quick overview of the different features and concepts in Flecs with short examples. This is a good resource if you're just getting started or just want to get a better idea of what kind of features are available in Flecs!</p>
<h2 id="concepts"><a class="header" href="#concepts">Concepts</a></h2>
<p>This section contains an overview of all the different concepts in Flecs and how they wire together. The sections in the quickstart go over them in more detail and with code examples.</p>
<p><img src="img/flecs-quickstart-overview.png" alt="Flecs Overview" /></p>
<h3 id="world"><a class="header" href="#world">World</a></h3>
<p>The world is the container for all ECS data. It stores the entities and their components, does queries and runs systems. Typically there is only a single world, but there is no limit on the number of worlds an application can create.</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let world = World::new();

// Do the ECS stuff
<span class="boring">}</span></code></pre>
<h3 id="entity"><a class="header" href="#entity">Entity</a></h3>
<p>An entity is a unique thing in the world, and is represented by a 64 bit id. Entities can be created and deleted. If an entity is deleted it is no longer considered "alive". A world can contain up to 4 billion(!) alive entities. Entity identifiers contain a few bits that make it possible to check whether an entity is alive or not.</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>let e = world.entity();
e.is_alive(); // true!

e.destruct();
e.is_alive(); // false!
<span class="boring">}</span></code></pre>
<p>Entities can have names which makes it easier to identify them in an application. In Rust the name can be passed using <code>entity_named</code>. If a name is provided during entity creation time and an entity with that name already exists, the existing entity will be returned.</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>let e = world.entity_named("bob");

println!("Entity name: {}", e.name());
<span class="boring">}</span></code></pre>
<p>Entities can be looked up by name with the <code>lookup</code> function:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span><span class="boring">let _ = world.entity_named("bob");
</span>let e = world.lookup("bob");
<span class="boring">}</span></code></pre>
<h3 id="id"><a class="header" href="#id">Id</a></h3>
<p>An id is a 64 bit number that can encode anything that can be added to an entity. In flecs this can be either a component, tag or a pair. A component is data that can be added to an entity. A tag is an "empty" component. A pair is a combination of two component/tag ids which is used to encode entity relationships. All entity/component/tag identifiers are valid ids, but not all ids are valid entity identifier.</p>
<p>The following sections describe components, tags and pairs in more detail.</p>
<h3 id="component"><a class="header" href="#component">Component</a></h3>
<p>A component is a type of which instances can be added and removed to entities. Each component can be added only once to an entity (though not really, see <a href="#pair">Pair</a>).</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span>#[derive(Component)]
struct Position { x: f32, y: f32 }
#[derive(Default, Component)]
struct Velocity { x: f32, y: f32 }
 
<span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>let e = world.entity();

// Add a component. This creates the component in the ECS storage, but does not
// assign it with a value. To add a component, it needs to be derived with the
// Default trait otherwise it will panic at compile time.
e.add(id::&lt;Velocity&gt;());

// Set the value for the Position &amp; Velocity components. A component will be
// added if the entity doesn't have it yet.
e.set(Position { x: 10.0, y: 20.0 })
 .set(Velocity { x: 1.0, y: 2.0 });

// Get a component
e.get::&lt;&amp;Position&gt;(|p| {
    println!("Position: ({}, {})", p.x, p.y);
});

// Remove component
e.remove(id::&lt;Position&gt;());
<span class="boring">}</span></code></pre>
<p>Each component is associated by a unique entity identifier by Flecs. This makes it possible to inspect component data, or attach your own data to components.</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Position { x: f32, y: f32 }
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Serializable;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>let pos_e = world.entity_from::&lt;Position&gt;();

println!("Name: {}", pos_e.name()); // outputs 'Name: Position'

// It's possible to add components like you would for any entity
pos_e.add(id::&lt;Serializable&gt;());
<span class="boring">}</span></code></pre>
<p>The thing that makes an ordinary entity a component is the <code>Component</code> trait. This tells Flecs how much space is needed to store a component, and can be inspected by applications:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Position { x: f32, y: f32 }
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>let pos_e = world.entity_from::&lt;Position&gt;();

pos_e.get::&lt;&amp;flecs::Component&gt;(|c| {
    println!("Component size: {}", c.size);
});
<span class="boring">}</span></code></pre>
<p>Because components are stored as regular entities, they can in theory also be deleted. To prevent unexpected accidents however, by default components are registered with a tag that prevents them from being deleted. If this tag were to be removed, deleting a component would cause it to be removed from all entities. For more information on these policies, see <a href="Relationships.html#cleanup-properties">Relationship cleanup properties</a>.</p>
<h3 id="tag"><a class="header" href="#tag">Tag</a></h3>
<p>A tag is a component that does not have any data. In Flecs tags are empty types marked with the <code>Component</code> trait. Tags can be added &amp; removed using the same APIs as adding &amp; removing components, but because tags have no data, they cannot be assigned a value. Because tags (like components) are regular entities, they can be created &amp; deleted at runtime.</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>// Option 1: create Tag as empty struct
#[derive(Component)]
struct Enemy;

// Create entity, add Enemy tag
let e = world.entity().add(id::&lt;Enemy&gt;());
e.has(id::&lt;Enemy&gt;()); // true!

e.remove(id::&lt;Enemy&gt;());
e.has(id::&lt;Enemy&gt;()); // false!

// Option 2: create Tag as entity
let enemy = world.entity();

// Create entity, add Enemy tag
let e = world.entity().add(enemy);
e.has(enemy); // true!

e.remove(enemy);
e.has(enemy); // false!
<span class="boring">}</span></code></pre>
<p>Note that both options achieve the same effect. The only difference is that in option 1 the tag is fixed at compile time, whereas in option 2 the tag can be created dynamically at runtime.</p>
<p>When a tag is deleted, the same rules apply as for components (see <a href="Relationships.html#cleanup-properties">Relationship cleanup properties</a>).</p>
<h3 id="pair"><a class="header" href="#pair">Pair</a></h3>
<p>A pair is a combination of two entity ids. Pairs can be used to store entity relationships, where the first id represents the relationship kind and the second id represents the relationship target (called "object"). This is best explained by an example:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>// Create Likes relationship as empty type (tag)
#[derive(Component)]
struct Likes;

// Create a small graph with two entities that like each other
let bob = world.entity();
let alice = world.entity();

bob.add((id::&lt;Likes&gt;(), alice)); // bob likes alice
alice.add((id::&lt;Likes&gt;(), bob)); // alice likes bob
bob.has((id::&lt;Likes&gt;(), alice)); // true!

bob.remove((id::&lt;Likes&gt;(), alice));
bob.has((id::&lt;Likes&gt;(), alice)); // false!
<span class="boring">}</span></code></pre>
<p>A pair can be encoded in a single 64 bit identifier using the <code>world.id_first</code> function:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Likes;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span><span class="boring">let bob = world.entity();
</span>let id = world.id_view_from(id::&lt;Likes&gt;(),bob);
<span class="boring">}</span></code></pre>
<p>The following examples show how to get back the elements from a pair:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Likes;
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Apples;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>let id = world.id_view_from((id::&lt;Likes&gt;(), id::&lt;Apples&gt;()));
if id.is_pair() {
    let relationship = id.first_id();
    let target = id.second_id();
}
<span class="boring">}</span></code></pre>
<p>A component or tag can be added multiple times to the same entity as long as it is part of a pair, and the pair itself is unique:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span><span class="boring">let eats = world.entity();
</span><span class="boring">let grows = world.entity();
</span><span class="boring">let apples = world.entity();
</span><span class="boring">let pears = world.entity();
</span>let bob = world.entity();
bob.add((eats, apples));
bob.add((eats, pears));
bob.add((grows, pears));

bob.has((eats, apples)); // true!
bob.has((eats, pears)); // true!
bob.has((grows, pears)); // true!
<span class="boring">}</span></code></pre>
<p>The <code>target</code> function can be used to get the object for a relationship:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Likes;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span><span class="boring">let bob = world.entity();
</span>let alice = world.entity().add((id::&lt;Likes&gt;(), bob));
let o = alice.target(id::&lt;Likes&gt;(),0); // Returns bob
<span class="boring">}</span></code></pre>
<p>Entity relationships enable lots of interesting patterns and possibilities. Make sure to check out the <a href="Relationships.html">Relationships manual</a>.</p>
<h3 id="hierarchies"><a class="header" href="#hierarchies">Hierarchies</a></h3>
<p>Flecs has builtin support for hierarchies with the builtin <code>ChildOf</code> relationship. A hierarchy can be created with the regular relationship API or with the .child_of` function:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>let parent = world.entity();
let child = world.entity().child_of(parent);

// Deleting the parent also deletes its children
parent.destruct();
<span class="boring">}</span></code></pre>
<p>When entities have names, they can be used together with hierarchies to generate path names or do relative lookups:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>let parent = world.entity_named("parent");
let child = world.entity_named("child").child_of(parent);

println!("Child path: {}", child.path().unwrap()); // output: 'parent::child'

world.lookup("parent::child"); // returns child
parent.lookup("child"); // returns child
<span class="boring">}</span></code></pre>
<p>Queries (see below) can use hierarchies to order data breadth-first, which can come in handy when you're implementing a transform system:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Position { x: f32, y: f32 }
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>let q = world
    .query::&lt;(&amp;Position, &amp;mut Position)&gt;()
    .term_at(1)
    .parent()
    .cascade()
    // cascade queries need to be cached
    .set_cached()
    .build();

q.each(|(p, p_parent)| {
    // Do the thing
});
<span class="boring">}</span></code></pre>
<h3 id="type"><a class="header" href="#type">Type</a></h3>
<p>The type (often referred to as "archetype") is the list of ids an entity has. Types can be used for introspection which is useful when debugging, or when for example building an entity editor. The most common thing to do with a type is to convert it to text and print it:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Default, Component)]
</span><span class="boring">struct Position { x: f32, y: f32 }
</span><span class="boring">#[derive(Default, Component)]
</span><span class="boring">struct Velocity { x: f32, y: f32 }
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>let e = world.entity().add(id::&lt;Position&gt;()).add(id::&lt;Velocity&gt;());

println!("Components: {}", e.archetype().to_string().unwrap()); // output: 'Position,Velocity'
<span class="boring">}</span></code></pre>
<p>A type can also be iterated by an application:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Default, Component)]
</span><span class="boring">struct Position { x: f32, y: f32 }
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span><span class="boring">let e = world.entity().add(id::&lt;Position&gt;());
</span>e.each_component(|id| {
    if id == world.component_id::&lt;Position&gt;() {
        // Found Position component!
    }
});
<span class="boring">}</span></code></pre>
<h3 id="singleton"><a class="header" href="#singleton">Singleton</a></h3>
<p>A singleton is a single instance of a component that can be retrieved without an entity. The functions for singletons are very similar to the regular API:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Gravity { x: i32, y: i32 }
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>// Set singleton component
world.set(Gravity { x: 10, y: 20 });

// Get singleton component
world.get::&lt;&amp;Gravity&gt;(|g| {
    println!("Gravity: {}, {}", g.x, g.y);
});
<span class="boring">}</span></code></pre>
<p>Singleton components are created by adding the component to its own entity id. The above code examples are shortcuts for these regular API calls:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Gravity { x: i32, y: i32 }
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>let grav_e = world.entity_from::&lt;Gravity&gt;();

grav_e.set(Gravity { x: 10, y: 20 });

grav_e.get::&lt;&amp;Gravity&gt;(|g| {
    println!("Gravity: {}, {}", g.x, g.y);
});
<span class="boring">}</span></code></pre>
<p>The following examples show how to query for a singleton component:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Velocity { x: f32, y: f32 }
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Gravity { x: i32, y: i32 }
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>world
    .query::&lt;(&amp;Velocity, &amp;Gravity)&gt;()
    .term_at(1)
    .singleton()
    .build();
<span class="boring">}</span></code></pre>
<h3 id="query"><a class="header" href="#query">Query</a></h3>
<p>Queries are the main mechanism for finding and iterating through entities. Queries are used in many parts of the API, such as for systems and observers. The following example shows a simple query:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Position { x: f32, y: f32 }
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Velocity { x: f32, y: f32 }
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Mesh;
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Transform;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span><span class="boring">let parent = world.entity();
</span>// For simple queries the world::each function can be used
world.each::&lt;(&amp;mut Position, &amp;Velocity)&gt;(|(p, v)| {
    // EntityView argument is optional, use each_entity to get it
    p.x += v.x;
    p.y += v.y;
});

// More complex queries can first be created, then iterated
let q = world
    .query::&lt;&amp;Position&gt;()
    .with_id((flecs::ChildOf::ID, parent))
    .build();

// Option 1: the each() callback iterates over each entity
q.each_entity(|e, p| {
    println!("{}: ({}, {})", e.name(), p.x, p.y);
}); 

// Option 2: the run() callback offers more control over the iteration
q.run(|mut it| {
    while it.next() {
        let p = it.field::&lt;Position&gt;(0).unwrap();

        for i in it.iter() {
            println!("{}: ({}, {})", it.entity(i).unwrap().name(), p[i].x, p[i].y);
        }
    }
});
<span class="boring">}</span></code></pre>
<p>Queries can use operators to exclude components, optionally match components or match one out of a list of components. Additionally filters may contain wildcards for terms which is especially useful when combined with pairs.</p>
<p>The following example shows a query that matches all entities with a parent that do not have <code>Position</code>:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Position { x: f32, y: f32 }
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>let q = world
    .query::&lt;()&gt;()
    .with::&lt;(flecs::ChildOf, flecs::Wildcard)&gt;()
    .with(id::&lt;Position&gt;())
    .set_oper(OperKind::Not)
    .build();

// Iteration code is the same
<span class="boring">}</span></code></pre>
<p>See the <a href="Queries.html">query manual</a> for more details.</p>
<h3 id="system"><a class="header" href="#system">System</a></h3>
<p>A system is a query combined with a callback. Systems can be either ran manually or ran as part of an ECS-managed main loop (see <a href="#pipeline">Pipeline</a>). The system API looks similar to queries:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Position { x: f32, y: f32 }
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Velocity { x: f32, y: f32 }
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>// Use each_entity() function that iterates each individual entity
let move_sys = world
    .system::&lt;(&amp;mut Position, &amp;Velocity)&gt;()
    .each_iter(|it, i, (p, v)| {
        p.x += v.x * it.delta_time();
        p.y += v.y * it.delta_time();
    });

// Just like with queries, systems have both the run() and
// each() methods to iterate entities.

move_sys.run();
<span class="boring">}</span></code></pre>
<p>Systems are stored as entities with additional components, similar to components. That means that an application can use a system as a regular entity:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Position { x: f32, y: f32 }
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Velocity { x: f32, y: f32 }
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span><span class="boring">let move_sys = world
</span><span class="boring">   .system::&lt;(&amp;mut Position, &amp;Velocity)&gt;()
</span><span class="boring">   .each_iter(|it, i, (p, v)| {
</span><span class="boring">       p.x += v.x * it.delta_time();
</span><span class="boring">       p.y += v.y * it.delta_time();
</span><span class="boring">   });
</span>println!("System: {}", move_sys.name());
move_sys.add(id::&lt;flecs::pipeline::OnUpdate&gt;());
move_sys.destruct();
<span class="boring">}</span></code></pre>
<h3 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h3>
<p>A pipeline is a list of tags that when matched, produces a list of systems to run. These tags are also referred to as a system "phase". Flecs comes with a default pipeline that has the following phases:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>flecs::pipeline::OnLoad;
flecs::pipeline::PostLoad;
flecs::pipeline::PreUpdate;
flecs::pipeline::OnUpdate;
flecs::pipeline::OnValidate;
flecs::pipeline::PostUpdate;
flecs::pipeline::PreStore;
flecs::pipeline::OnStore;
<span class="boring">}</span></code></pre>
<p>When a pipeline is executed, systems are ran in the order of the phases. This makes pipelines and phases the primary mechanism for defining ordering between systems. The following code shows how to assign systems to a pipeline, and how to run the pipeline with the <code>progress()</code> function:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Position { x: f32, y: f32 }
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Velocity { x: f32, y: f32 }
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Transform { x: f32, y: f32 }
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Mesh { id: u32 }
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>world
    .system_named::&lt;(&amp;mut Position, &amp;Velocity)&gt;("Move")
    .has(id::&lt;flecs::pipeline::OnUpdate&gt;())
    .each(|(p, v)| {});

world
    .system_named::&lt;(&amp;mut Position, &amp;Transform)&gt;("Transform")
    .has(id::&lt;flecs::pipeline::PostUpdate&gt;())
    .each(|(p, t)| {});
    
world
    .system_named::&lt;(&amp;Transform, &amp;mut Mesh)&gt;("Render")
    .has(id::&lt;flecs::pipeline::OnStore&gt;())
    .each(|(t, m)| {});

world.progress();
<span class="boring">}</span></code></pre>
<p>Because phases are just tags that are added to systems, applications can use the regular API to add/remove systems to a phase:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Position { x: f32, y: f32 }
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Velocity { x: f32, y: f32 }
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span><span class="boring">let move_sys = world
</span><span class="boring">   .system::&lt;(&amp;mut Position, &amp;Velocity)&gt;()
</span><span class="boring">   .each_iter(|it, i, (p, v)| {
</span><span class="boring">       p.x += v.x * it.delta_time();
</span><span class="boring">       p.y += v.y * it.delta_time();
</span><span class="boring">   });
</span>move_sys.add(id::&lt;flecs::pipeline::OnUpdate&gt;());
move_sys.remove(id::&lt;flecs::pipeline::PostUpdate&gt;());
<span class="boring">}</span></code></pre>
<p>Inside a phase, systems are guaranteed to be ran in their declaration order.</p>
<h3 id="observer"><a class="header" href="#observer">Observer</a></h3>
<p>Observers are callbacks that are invoked when one or more events matches the query of an observer. Events can be either user defined or builtin. Examples of builtin events are <code>OnAdd</code>, <code>OnRemove</code> and <code>OnSet</code>.</p>
<p>When an observer has a query with more than one component, the observer will not be invoked until the entity for which the event is emitted satisfies the entire query.</p>
<p>An example of an observer with two components:</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Position { x: f32, y: f32 }
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Velocity { x: f32, y: f32 }
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>world
    .observer_named::&lt;flecs::OnSet, (&amp;Position, &amp;Velocity)&gt;("OnSetPosition")
    .each(|(p, v)| {}); // Callback code is same as system

let e = world.entity(); // Doesn't invoke the observer
e.set(Position { x: 10.0, y: 20.0 }); // Doesn't invoke the observer
e.set(Velocity { x: 1.0, y: 2.0 }); // Invokes the observer
e.set(Position { x: 30.0, y: 40.0 }); // Invokes the observer
<span class="boring">}</span></code></pre>
<h3 id="module"><a class="header" href="#module">Module</a></h3>
<p>A module is a function that imports and organizes components, systems, triggers, observers, prefabs into the world as reusable units of code. A well designed module has no code that directly relies on code of another module, except for components definitions. All module contents are stored as child entities inside the module scope with the <code>ChildOf</code> relationship.</p>
<pre><code class="language-rust"><span class="boring">extern crate flecs_ecs;
</span><span class="boring">use flecs_ecs::prelude::*;
</span><span class="boring">
</span>#[derive(Component)]
struct MyModule;

impl Module for MyModule {
    fn module(world: &amp;World) {
        world.module::&lt;MyModule&gt;("MyModule");
        // Define components, systems, triggers, ... as usual. They will be
        // automatically created inside the scope of the module.
    }
}

<span class="boring">fn main() {
</span><span class="boring">let world = World::new();
</span>// Import code
world.import::&lt;MyModule&gt;();
<span class="boring">}</span></code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/tabs.js"></script>


    </div>
    </body>
</html>
