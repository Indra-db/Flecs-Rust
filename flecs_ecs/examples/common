#[allow(unused_imports)]
pub use flecs_ecs::prelude::*;

#[derive(Debug, Component)]
pub struct Position {
    pub x: f32,
    pub y: f32,
}

#[derive(Debug, Component)]
pub struct Velocity {
    pub x: f32,
    pub y: f32,
}

#[derive(Component)]
pub struct Mass {
    pub value: f32,
}

#[derive(Component)]
pub struct Eats;

#[derive(Component)]
pub struct EatsAmount {
    pub amount: i32,
}

#[derive(Component)]
pub struct Apples;

#[derive(Component)]
pub struct Pears;

#[derive(Component)]
pub struct Walking;

#[derive(Component)]
pub struct Tag;

#[derive(Component)]
pub struct Human;

#[derive(Component)]
pub struct Attack {
    pub value: f32,
}

#[derive(Component, Debug)]
pub struct Defence {
    pub value: f32,
}

#[derive(Component)]
pub struct Damage {
    pub value: f32,
}

#[derive(Component)]
pub struct FreightCapacity {
    pub value: f32,
}

#[derive(Component)]
pub struct ImpulseSpeed {
    pub value: f32,
}

#[derive(Component)]
pub struct HasFlt;

#[derive(Component)]
pub struct First;

#[derive(Component)]
pub struct Second;

#[derive(Component)]
pub struct Third;

#[derive(Component)]
pub struct Group;

#[allow(dead_code)]
fn main_() {
    //this file is for common structs and functions used in the examples
}

#[allow(unused_macros)]
macro_rules! fprintln {
    ($world:expr) => {
        {
            let world = ($world).world();
            world.get_mut::<Snap>().push(format!("\n"));
            println!();
        }
    };
    ($world:expr, $format_string:expr) => {
        {
            let world = ($world).world();
            world.get_mut::<Snap>().push(format!($format_string));
            println!($format_string);
        }
    };
    ($world:expr, $format_string:expr, $($arg:expr),*) => {
        {
            let world = ($world).world();
            world.get_mut::<Snap>().push(format!($format_string, $($arg),*));
            println!($format_string, $($arg),*);
        }
    };
}

#[derive(Component)]
pub struct Snap {
    pub str: Vec<String>,
}

impl Module for Snap {
    fn module(world: &World) {
        let snap = Snap::setup_snapshot_test();
        world.emplace(snap);
    }
}

impl std::process::Termination for Snap {
    fn report(self) -> std::process::ExitCode {
        std::process::ExitCode::SUCCESS
    }
}

#[allow(dead_code)]
impl Snap {
    pub fn setup_snapshot_test() -> Snap {
        Snap { str: Vec::new() }
    }

    pub fn push(&mut self, str: String) {
        self.str.push(str);
    }

    pub fn count(&self) -> usize {
        self.str.len()
    }

    pub fn test(&self) {
        insta::with_settings!({filters => vec![
            (r"id: (\d+)\s", "[ID] ")
        ]}, {
            insta::assert_yaml_snapshot!(self.str);

        });
    }

    pub fn from(world: &World) -> Self {
        Self {
            str: std::mem::take(&mut world.get_mut::<Snap>().str),
        }
    }
}
